{"meta":{"title":"artly的小窝","subtitle":"","description":"test description","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2023-07-18T01:36:16.268Z","updated":"2023-07-18T01:36:16.268Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"哈喽😄，进来的朋友~首先感谢您来到我博客，再是您访问了这个页面来了解。 鄙人杨世豪，现就读于天津中德应用技术大学21级物联网工程专业。 中文常用昵称“夏漱石”，因为高中期间喜欢比较喜欢夏目漱石老师，再加上喜欢动漫，爱看fate，对历史人物人很有感触，就给自己取了这么一个名字，但后来这个名字容易撞车，就用自己另一个喜欢的动漫角色取了“artly1”这个名字。本人并不优秀，就是普普通通的一名学生，对于自己的未来依旧很迷茫，但怎么说呢，一步一步走走看吧。 目前这个博客主要用来总结自己系统学习的相关内容，内容也没有多深奥，主要是总结方便自己之后回忆。所以有巨佬请勿喷😵——以上。 Ps：如果想要交换友链的话，那就在下边留下你的信息。"},{"title":"所有分类","date":"2023-06-27T02:52:53.596Z","updated":"2023-06-27T02:52:53.596Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2023-06-27T02:42:54.000Z","updated":"2023-06-27T02:42:54.377Z","comments":true,"path":"archives/index.html","permalink":"http://yoursite.com/archives/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2023-06-27T02:57:53.373Z","updated":"2023-06-27T02:57:53.373Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":""},{"title":"Page","date":"2013-12-26T14:52:56.000Z","updated":"2023-03-31T12:13:05.237Z","comments":true,"path":"page/index.html","permalink":"http://yoursite.com/page/index.html","excerpt":"","text":"This is a page test."},{"title":"所有标签","date":"2023-06-27T02:52:01.217Z","updated":"2023-06-27T02:52:01.217Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"学生管理系统-后端5-创建数据库与配置数据库","slug":"学生管理系统-后端5-创建数据库与配置数据库","date":"2023-08-06T02:27:35.000Z","updated":"2023-08-06T09:10:22.113Z","comments":true,"path":"2023/08/06/学生管理系统-后端5-创建数据库与配置数据库/","link":"","permalink":"http://yoursite.com/2023/08/06/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E5%90%8E%E7%AB%AF5-%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"创建数据库对于数据库的知识如果有遗漏，可以查看这篇博客mysql常用命令_artly1的博客-CSDN博客 sql代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647-- 创建demo数据库CREATE DATABASE demo;-- 使用demo数据库USE demo;-- 创建student表（使用你之前提供的结构）CREATE TABLE student ( id bigint(20) NOT NULL AUTO_INCREMENT, number varchar(255) NOT NULL, name varchar(255) NOT NULL, age int(11) NOT NULL, chi int(11) NOT NULL, math int(11) NOT NULL, eng int(11) NOT NULL, PRIMARY KEY (id)) ENGINE=InnoDB AUTO_INCREMENT=138 DEFAULT CHARSET=utf8;-- 创建user表CREATE TABLE user ( id bigint(20) NOT NULL AUTO_INCREMENT, username varchar(255) NOT NULL, password varchar(255) NOT NULL, PRIMARY KEY (id)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;-- 插入学生数据INSERT INTO student (number, name, age, chi, math, eng) VALUES(1,&#x27;101&#x27;,&#x27;张三&#x27;,18,99,99,99),(2,&#x27;102&#x27;,&#x27;李四&#x27;,19,92,80,55),(3,&#x27;103&#x27;,&#x27;王五&#x27;,20,88,79,88),(4,&#x27;104&#x27;,&#x27;马六&#x27;,21,75,88,99),(5,&#x27;105&#x27;,&#x27;赵七&#x27;,17,88,54,67),(6,&#x27;106&#x27;,&#x27;陈八&#x27;,24,87,77,33),(7,&#x27;107&#x27;,&#x27;朱九&#x27;,23,91,44,56),(8,&#x27;108&#x27;,&#x27;小红&#x27;,8,82,77,90),(9,&#x27;109&#x27;,&#x27;小强&#x27;,8,78,67,88),(10,&#x27;110&#x27;,&#x27;大白&#x27;,17,73,72,71),(11,&#x27;111&#x27;,&#x27;小花&#x27;,20,73,73,88),(12,&#x27;112&#x27;,&#x27;小新&#x27;,7,59,59,59),(13,&#x27;113&#x27;,&#x27;小黄&#x27;,14,78,99,93);-- 插入用户数据INSERT INTO user (username, password) VALUES(&#x27;abc&#x27;, &#x27;123&#x27;),(&#x27;111&#x27;, &#x27;123&#x27;); 连接数据库 代码12345datasource: username: root password: &#x27;123456&#x27; url: jdbc:mysql://127.0.0.1:3306/demo?characterEncoding=UTF-8&amp;serverTimezone=UTC driver-class-name: com.mysql.cj.jdbc.Driver username: 数据库用户名 password: ‘数据库密码’ url: jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;数据库名?characterEncoding&#x3D;UTF-8&amp;serverTimezone&#x3D;UTC","categories":[{"name":"项目实战","slug":"项目实战","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"},{"name":"学生管理系统","slug":"项目实战/学生管理系统","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"学生管理系统-后端4-创建mapper与实体类","slug":"学生管理系统-后端4-创建mapper与实体类","date":"2023-08-06T02:26:56.000Z","updated":"2023-08-06T05:06:55.050Z","comments":true,"path":"2023/08/06/学生管理系统-后端4-创建mapper与实体类/","link":"","permalink":"http://yoursite.com/2023/08/06/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E5%90%8E%E7%AB%AF4-%E5%88%9B%E5%BB%BAmapper%E4%B8%8E%E5%AE%9E%E4%BD%93%E7%B1%BB/","excerpt":"","text":"我们按照这种格式去创建我们的实体类和mapper 创建实体类实体类是与数据库表对应的 Java 类。它们通常具有与表中列相对应的属性，用于在应用程序和数据库之间传递数据。由于我们还没有创建数据库，可以先到5中去看数据库表 定义实体类： 创建一个 Java 类，用于表示数据库表中的一行数据。该类的属性应与表中的列相匹配。 1234public class User &#123; private String username; private String password;&#125; 添加注解：使用适当的注解来映射实体类与数据库表。 1@Data 使用 @Data 注解会自动生成 User 类的 getter、setter、equals、hashCode 和 toString 方法。这样你就无需手动编写这些方法了。大大简化了代码 代码Student 123456789101112package org.example.pojo;import lombok.Data;@Datapublic class Student &#123; private long id; private String number; private String name; private int age; private int chi; private int math; private int eng;&#125; User 1234567package org.example.pojo;import lombok.Data;@Datapublic class User &#123; private String username; private String password;&#125; 一定要写@Data注解，这样会省很多代码。 创建 MapperMapper 是用于执行数据库操作的接口或类，它们与实体类紧密相关，用于增删改查等操作。因为我们已经引入了MyBatis Plus，在 MyBatis Plus 中，你只需要继承 BaseMapper 接口，并指定泛型类型（即对应的实体类），框架会自动为你生成常见的增删改查方法，无需手动编写。。 注意：创建时选择接口，不是java类 使用 Mapper： 在应用程序中使用依赖注入或其他方式，将 Mapper 注入到需要的地方，执行数据库操作。 代码​ StudentMapper 12345678package org.example.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import org.example.pojo.Student;//mapper接口需要继承base所以extendspublic interface StudentMapper extends BaseMapper&lt;Student&gt; &#123;//&lt;&gt;中写入要传的实体类&#125; ​ UserMapper 123456package org.example.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import org.example.pojo.User;public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125;","categories":[{"name":"项目实战","slug":"项目实战","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"},{"name":"学生管理系统","slug":"项目实战/学生管理系统","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"学生管理系统-后端3-创建application和controller类","slug":"学生管理系统-后端3-创建application和controller类","date":"2023-08-06T02:26:06.000Z","updated":"2023-08-06T04:45:29.535Z","comments":true,"path":"2023/08/06/学生管理系统-后端3-创建application和controller类/","link":"","permalink":"http://yoursite.com/2023/08/06/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E5%90%8E%E7%AB%AF3-%E5%88%9B%E5%BB%BAapplication%E5%92%8Ccontroller%E7%B1%BB/","excerpt":"","text":"Application类1. 概述Application 类是一个Spring Boot应用的入口类，通过 @SpringBootApplication 注解标记，用于启动和初始化整个应用程序。同时，该类使用 @MapperScan 注解扫描指定的包路径，以自动发现和注册MyBatis的Mapper接口。 2. 主要功能Application 类主要完成以下功能： 初始化和启动Spring Boot应用程序。 自动扫描并注册MyBatis的Mapper接口。 提供 main 方法，用于执行应用程序的入口逻辑。 3. 使用方法3.1. 导入项目在项目的源代码中，导入 Application.java 文件。 1234567891011121314package org.example;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication//通过这个类，就可以把这个类标志成启动类@MapperScan(&quot;org.example.mapper&quot;)//扫描mapper包public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args);//这个类的class对象 &#125;&#125; 3.2. 注解说明 @SpringBootApplication: 该注解标识了一个Spring Boot应用的启动类。它会自动启用Spring Boot的自动配置，并扫描同级包及其子包下的组件。 @MapperScan(&quot;org.example.mapper&quot;): 该注解用于扫描指定的包路径，自动发现和注册MyBatis的Mapper接口。 3.3. 启动应用程序运行 main 方法，即可启动Spring Boot应用程序。 Controller类1. 概述Controller 类是一个Spring Boot中的REST控制器，用于处理来自前端的HTTP请求并与数据库交互。通过各种不同的请求映射方法，它实现了学生信息的增、删、改、查操作，以及用户登录和注册功能。 2. 主要功能Controller 类主要完成以下功能： 获取学生信息列表并返回给前端。 插入新的学生信息到数据库。 根据学生ID删除数据库中的学生信息。 根据学生ID更新数据库中的学生信息。 用户登录验证，返回结果表示登录成功或失败。 用户注册，将用户信息插入数据库。 3. 使用方法3.1. 导入项目在项目的源代码中，导入 Controller.java 文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package org.example;import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;import com.google.gson.Gson;import org.example.mapper.StudentMapper;import org.example.mapper.UserMapper;import org.example.pojo.Student;import org.example.pojo.User;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import java.util.List;@SuppressWarnings(&quot;all&quot;) // 去除所有警告@CrossOrigin(origins = &#123;&quot;*&quot;, &quot;null&quot;&#125;) // * 表示任何地方发过来的请求都能响应，解决跨域问题@RestController // 标志这个文件是一个 controller 类public class Controller &#123; @Autowired // 自动连接，通过实体类去连接数据库 private StudentMapper studentMapper; // 创建一个 StudentMapper 去定义 studentMapper 属性 @Autowired private UserMapper userMapper; private Gson gson = new Gson(); // 将查出来的数据转为字符串 // 获取所有学生信息列表并返回给前端 @GetMapping(&quot;/students&quot;) // 在 8080/students 页面下会执行下边的函数 public String getStudents() &#123; List&lt;Student&gt; students = studentMapper.selectList(null); return gson.toJson(students); // 把数据转成字符串后的列表返回给前端 &#125; // 插入新的学生信息到数据库 @PostMapping(&quot;/insert&quot;) public void insertStudent(@RequestBody Student student) &#123; studentMapper.insert(student); &#125; // 根据学生ID删除数据库中的学生信息 @PostMapping(&quot;/delete&quot;) public void deleteStudent(@RequestBody Student student) &#123; studentMapper.deleteById(student.getId()); &#125; // 根据学生ID更新数据库中的学生信息 @PostMapping(&quot;/update&quot;) public void updateStudent(@RequestBody Student student) &#123; studentMapper.updateById(student); &#125; // 用户登录验证，返回结果表示登录成功或失败 @PostMapping(&quot;/login&quot;) public String loginStudent(@RequestBody User user) &#123; QueryWrapper&lt;User&gt; userQueryWrapper = new QueryWrapper&lt;&gt;(); userQueryWrapper.setEntity(user); User userSelected = userMapper.selectOne(userQueryWrapper); if (userSelected == null) &#123; return &quot;0&quot;; // 登录失败，返回 &quot;0&quot; &#125; return &quot;1&quot;; // 登录成功，返回 &quot;1&quot; &#125; // 用户注册，将用户信息插入数据库 @PostMapping(&quot;/register&quot;) public void register(@RequestBody User user) &#123; userMapper.insert(user); &#125;&#125;//写的方法看着没错如果实现不了还没有报错，有可能是没有用autowird，没有注入他的mapper。所以在实际使用中，确保 StudentMapper 和 UserMapper 被正确注入，否则会导致无法正常连接数据库。 3.2. 注解说明 @CrossOrigin(origins = &#123;&quot;*&quot;, &quot;null&quot;&#125;): 该注解解决跨域问题，允许任何来源的请求访问。 @RestController: 标识该类为一个控制器类，处理HTTP请求并返回REST响应。 @Autowired: 自动连接到其他Spring管理的Bean。 3.3. API说明以下是 Controller 类中定义的API方法及其功能： GET /students: 获取所有学生信息列表。 POST /insert: 插入新的学生信息到数据库。 POST /delete: 根据学生ID删除数据库中的学生信息。 POST /update: 根据学生ID更新数据库中的学生信息。 POST /login: 用户登录验证，返回结果表示登录成功或失败。 POST /register: 用户注册，将用户信息插入数据库。","categories":[{"name":"项目实战","slug":"项目实战","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"},{"name":"学生管理系统","slug":"项目实战/学生管理系统","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"学生管理系统-后端2-引入pom依赖","slug":"学生管理系统-后端2-引入pom依赖","date":"2023-08-06T02:23:16.000Z","updated":"2023-08-06T03:01:39.775Z","comments":true,"path":"2023/08/06/学生管理系统-后端2-引入pom依赖/","link":"","permalink":"http://yoursite.com/2023/08/06/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E5%90%8E%E7%AB%AF2-%E5%BC%95%E5%85%A5pom%E4%BE%9D%E8%B5%96/","excerpt":"","text":"在后端开发中，Maven是一个常用的构建工具和依赖管理工具。在Maven项目中，POM（Project Object Model）文件是一个重要的配置文件，用于定义项目的基本信息、依赖关系以及构建配置。本文将解释我们将会在POM文件中所引入的各项依赖内容。 引入maven后要更新一下，然后会自动下载拟引入的maven，时间可能会比较长，耐心等待 1. 基本信息在POM文件中，&lt;groupId&gt;、&lt;artifactId&gt;和&lt;version&gt;元素定义了项目的基本信息： &lt;groupId&gt;：项目的组织或团队标识，通常使用反转的域名（类似Java包名）。 &lt;artifactId&gt;：项目的唯一标识符，通常是项目的名称。 &lt;version&gt;：项目的版本号。 123&lt;groupId&gt;com.example&lt;/groupId&gt;&lt;artifactId&gt;demo&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; 2. 依赖项1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- Maven项目描述文件，定义了项目的基本信息和依赖 --&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;!-- 指定模型版本 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 父依赖，基于Spring Boot的父项目 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- 从仓库查找父项目 --&gt; &lt;/parent&gt; &lt;!-- 项目的基本信息 --&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;!-- 定义属性 --&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;tomcat.version&gt;9.0.60&lt;/tomcat.version&gt; &lt;/properties&gt; Spring Boot Starter Parent 依赖：这是 Spring Boot 的父依赖，它提供了一系列默认的依赖版本，使您的项目能够快速集成 Spring Boot 框架。 org.springframework.boot:spring-boot-starter-parent:2.7.0 项目基本信息：在这部分中，定义了项目的基本信息，如项目的组织、唯一标识、版本、名称和描述等。 groupId：项目的组织或团队标识。 artifactId：项目的唯一标识符，通常是项目的名称。 version：项目的版本号。 name：项目的名称。 description：项目的描述。 属性定义：在这部分中，定义了项目中所使用的一些属性，如 Java 版本和 Tomcat 版本。 java.version：Java 版本。 tomcat.version：Tomcat 版本。 &lt;dependencies&gt;元素在&lt;dependencies&gt;元素下，列出了项目所依赖的库和框架。每个&lt;dependency&gt;元素表示一个依赖项，其中包括&lt;groupId&gt;、&lt;artifactId&gt;和&lt;version&gt;元素来指定依赖的组织、库和版本号。 Spring Boot Web 依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 这个依赖用于启用 Spring Boot 的 Web 支持。它包含了许多在 Web 开发中常用的库和组件，包括 HTTP 请求处理、控制器、视图解析器等。您可以使用这个依赖来构建和处理 Web 请求以及创建 RESTful API。 Gson 依赖12345&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.5&lt;/version&gt;&lt;/dependency&gt; Gson 是 Google 提供的一个 Java 库，用于将 Java 对象和 JSON 数据进行相互转换。它使您能够在后端应用程序中轻松处理 JSON 格式的数据，例如解析 JSON 数据、将 Java 对象序列化为 JSON 等。 Lombok 依赖123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; Lombok 是一个 Java 库，它通过注解自动为您生成 Java 类的代码，从而减少了冗余的样板代码。使用 Lombok，您可以轻松地为实体类生成 getter、setter、构造方法等。&lt;scope&gt;provided&lt;/scope&gt; 表示这个依赖在编译时提供，但在运行时不会被包含在项目中。 MySQL 连接驱动依赖12345&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 这个依赖包含了 MySQL 数据库的 Java 连接驱动，使得您可以在后端应用程序中连接、查询和操作 MySQL 数据库。 MyBatis-Plus 依赖12345&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt;&lt;/dependency&gt; MyBatis-Plus 是一个在 MyBatis 框架基础上的增强工具库。它提供了更多的便捷方法和功能，用于简化数据库操作，包括 CRUD 操作、分页查询等。 Spring Boot 内嵌 Tomcat 依赖123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;version&gt;2.6.6&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 这个依赖包含了 Spring Boot 内嵌的 Tomcat 服务器。它允许您在开发和测试环境中直接运行 Web 应用程序，而无需单独安装和配置外部的 Web 服务器。 3. 总的pom文件配置这是总的pom依赖，可以直接用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- Maven项目描述文件，定义了项目的基本信息和依赖 --&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;!-- 指定模型版本 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 父依赖，基于Spring Boot的父项目 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- 从仓库查找父项目 --&gt; &lt;/parent&gt; &lt;!-- 项目的基本信息 --&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;!-- 定义属性 --&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;tomcat.version&gt;9.0.60&lt;/tomcat.version&gt; &lt;/properties&gt; &lt;!-- 项目的依赖 --&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Web依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Gson依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Lombok依赖，用于简化Java类的开发 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- MySQL连接驱动依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot整合MyBatis-Plus的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring Boot Web依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Boot内嵌Tomcat依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;version&gt;2.6.6&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 项目构建配置 --&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- Spring Boot Maven插件，用于打包和运行Spring Boot应用 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 4. 注意由于各种依赖版本问题，可能最新的会有bug，所以最好选择稳定的去使用 可以在Maven Repository: Search&#x2F;Browse&#x2F;Explore (mvnrepository.com)网站中搜索你需要的依赖，选择版本后复制maven代码过来即可。 如还有其他问题建议csdn去搜索。","categories":[{"name":"项目实战","slug":"项目实战","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"},{"name":"学生管理系统","slug":"项目实战/学生管理系统","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"学生管理系统-后端1-创建文件","slug":"学生管理系统-后端","date":"2023-08-06T01:15:04.000Z","updated":"2023-08-06T02:22:52.197Z","comments":true,"path":"2023/08/06/学生管理系统-后端/","link":"","permalink":"http://yoursite.com/2023/08/06/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E5%90%8E%E7%AB%AF/","excerpt":"","text":"概述学生管理系统的后端部分负责处理与学生信息相关的业务逻辑，包括学生信息的增加、修改、查询和删除，以及与数据库的交互。该后端使用Spring Boot框架、MyBatis-Plus作为持久层框架，以及Gson库来处理数据的序列化和反序列化。 技术栈 Spring Boot 2：用于构建后端应用程序的框架。 MyBatis-Plus：简化数据库操作的持久层框架。 Gson：处理Java对象和JSON数据之间的转换。 MySQL：用于存储学生信息的关系型数据库。 创建项目创建maven文件 创建路径，我这里用back 项目目录，照着这个来建 在一个典型的Maven项目中，各个文件夹和目录有不同的作用，用于组织和管理项目的不同部分。以下是一个后端Maven项目中各个文件夹的一般作用说明： src&#x2F;main&#x2F;java: 这是项目的主要Java源代码目录，包含了项目的所有Java源代码文件。您的应用程序的主要逻辑和功能将在这个目录下的包和类中实现。 src&#x2F;main&#x2F;resources: 这个目录包含项目的资源文件，例如配置文件、静态文件、模板文件等。这些文件通常在运行时被读取和使用。 src&#x2F;test&#x2F;java: 这是项目的测试代码目录，包含了用于单元测试和集成测试的Java源代码文件。测试可以帮助您验证代码的正确性和稳定性。 src&#x2F;test&#x2F;resources: 这个目录包含了测试所需的资源文件，例如测试配置文件、测试数据等。 target: 这是Maven构建过程的输出目录，包含了编译后的Java类文件、打包后的可执行文件等。在构建过程中，Maven会将生成的文件放在这个目录下。 pom.xml: 这是项目的核心配置文件，用于指定项目的元数据、依赖项、构建配置等信息。Maven根据这个文件来管理项目的构建和依赖关系。","categories":[{"name":"项目实战","slug":"项目实战","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"},{"name":"学生管理系统","slug":"项目实战/学生管理系统","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"学生管理系统-简介","slug":"学生管理系统-简介","date":"2023-08-06T00:38:48.000Z","updated":"2023-08-06T01:13:28.139Z","comments":true,"path":"2023/08/06/学生管理系统-简介/","link":"","permalink":"http://yoursite.com/2023/08/06/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E7%AE%80%E4%BB%8B/","excerpt":"","text":"学生管理系统 项目预览 项目概述本学生管理系统是一个基于java和vue实现的，通过连接数据库实现对数据的增删改查。是一个比较简单的Java项目。 项目简介 前端 Vue2: Vue.js是一个流行的JavaScript前端框架，用于构建用户界面和单页应用程序。它具有响应式数据绑定和组件化架构，使得开发复杂的Web应用变得更加简单和高效。 Vue.js - 渐进式 JavaScript 框架 | Vue.js (vuejs.org) element-ui: Element UI是一个基于Vue.js的UI组件库，提供了一套美观、易于使用的UI组件，可以帮助开发人员快速构建各种Web界面。 Element - 网站快速成型工具 bootstrap5: Bootstrap是一个流行的HTML、CSS和JavaScript框架，用于构建响应式和现代化的Web界面。Bootstrap 5是最新版本，提供了丰富的样式和组件。 Get started with Bootstrap · Bootstrap v5.3 (getbootstrap.com) axios: Axios是一个用于在浏览器和Node.js中发送HTTP请求的JavaScript库，它可以帮助前端应用与后端服务器进行数据通信。 起步 | Axios 中文文档 | Axios 中文网 (axios-http.cn) 后端 springboot2: Spring Boot是一个用于简化Spring应用程序开发的框架，它提供了自动配置和快速开发的特性，使得构建后端服务变得更加简单和高效。 mybatis-plus: MyBatis-Plus是MyBatis框架的增强工具，它简化了数据库访问层的开发，提供了更多的便利和功能，如自动生成SQL、分页查询等。 Gson: Gson是Google提供的一个用于在Java对象和JSON数据之间进行序列化和反序列化的库，它可以帮助将Java对象转换为JSON格式，或者将JSON数据解析为Java对象 数据库 mysql: MySQL是一个开源的关系型数据库管理系统，广泛用于存储和管理结构化数据。它支持多用户、多线程，并且具有高性能和可靠性。 开发工具 社区版idea: 这可能是指JetBrains开发的IntelliJ IDEA，它是一个强大的集成开发环境（IDE），主要用于Java开发，但也支持其他编程语言和技术。 vs: 这可能指的是Microsoft的Visual Studio系列，其中包括Visual Studio Code（VS Code）和Visual Studio IDE。VS Code是一个轻量级的开源代码编辑器，适用于多种编程语言和框架。Visual Studio IDE则是一个更全功能的集成开发环境，主要用于Windows应用程序开发。 想要实现项目默认你具有H5，C3、JS、java、面向对象基础、mysql相关基础，其实也不难。","categories":[{"name":"项目实战","slug":"项目实战","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"},{"name":"学生管理系统","slug":"项目实战/学生管理系统","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"数据结构与算法","slug":"数据结构与算法","date":"2023-07-17T07:24:40.000Z","updated":"2023-07-24T13:02:24.614Z","comments":true,"path":"2023/07/17/数据结构与算法/","link":"","permalink":"http://yoursite.com/2023/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","excerpt":"","text":"第一章（数据结构和算法）数据结构 官方定义-没有统一 解决问题的方法效率，跟数据的组织方式有关 空间的使用 解决问题的方法效率，跟空间的利用率有关 算法的效率 解决问题的方法效率，跟算法的巧妙程度有关 抽象数据类型 算法 定义 1.一个有限指令集 2.接收一些输入 3.产生输出 4.在一定有限步骤后结束 5.每一条指令必须有充分明确的目标，不可以有歧义，在计算机处理范围内，描述不依赖于任何一种计算机语言以及具体的实现手段 算法的好坏 时间复杂度S（n）和空间复杂度T（n) 最坏情况复杂度T worst (n) 平均复杂度T avg (n) Tworst(n)&gt;&#x3D;Tavg(n 复杂度分析 复杂度分析的一些小窍门 T(n)是表示算法的时间复杂度。 O(n)是一种表示算法复杂度的符号,例如，T(n) &#x3D; O(n^2)表示算法的时间复杂度为n的平方。 f(n)”在算法复杂度分析中通常用来表示函数关于输入规模n的增长率,f(n)”可以是一个具体的函数,也可以是一个泛指的函数。 第二章(线性表 堆栈 队列)线性表 多项式表示 顺序储存结构直接表示 顺序储存结构表示非零项 每个多项式可以看成系数和指数二元组的集合 链式结构储存非零项 链表中每个节点储存一个非零项，每个节点包括两个数据域和一个指针域 coef expon link 系数 指数 next，指向下一个结构 123456789// 多项式结点的指针类型，用于表示一个多项式typedef struct PolyNode *Polynomial;// 多项式结点的定义struct PolyNode&#123; int cofe; // 系数（coefficient）：表示项的常数系数 int expon; // 指数（exponent）：表示项的幂次 Polynomial link; // 指向下一个项的指针（用于构建链表结构）&#125;; 链表的储存形式为： 线性表顺序储存 线性表是由同类型数据元素构成有序序列的线性集合 表中元素个数成为线性表的长度 表中若无元素，称之为空表 表中的起始位置称为表头，结束位置称为表尾 ​ 线性表的抽象数据类型描述 线性表利用数组连续存储空间的顺序存放线性表的各元素 123456789101112// 定义一个名为 List 的指向结构体 LNode 的指针类型typedef struct LNode* List;// 定义结构体 LNode，表示线性表struct LNode&#123; ElementType Data[Maxsize]; // ElementType 可以是任何你想存储的数据类型 int Last; // Last 表示线性表的最后一个元素的索引&#125;;// 声明一个结构体 LNode 类型的变量 L，用于创建线性表struct LNode L;// 声明一个 List 类型的指针变量 Ptrl，用于指向线性表的头节点List Ptrl; 访问下表为i的元素方法为：L.Data[i]或者PtrL-&gt;Data[i]线性表的长度为L.last+1或者PtrL-&gt;Last+1 初始化 12345678910111213// 函数名：MakeEmpty// 功能：创建一个空的线性表，并返回指向线性表头节点的指针// 返回值：返回指向线性表头节点的指针 ListList MakeEmpty()&#123; List PtrL; // 声明一个 List 类型的指针变量 PtrL，用于指向线性表的头节点 // 使用 malloc 分配内存来创建一个新的线性表头节点，并将其地址赋值给 PtrL PtrL = (List)malloc(sizeof(struct LNode)); // 初始化线性表，将 Last 设置为 -1，表示当前线性表为空 PtrL-&gt;Last = -1; // 返回指向新创建线性表头节点的指针 return PtrL;&#125; 查找 1234567891011121314151617181920// 函数名：Find// 功能：在线性表 PtrL 中查找元素 X 的位置// 参数：// - ElementType X: 要查找的元素// - List PtrL: 指向线性表头节点的指针// 返回值：// - 成功找到元素 X 返回其在线性表中的位置（索引），从 0 开始// - 没有找到元素 X 返回 -1int Find(ElementType X, List PtrL)&#123; int i = 0; // 初始化计数器 i，用于遍历线性表中的元素 // 循环遍历线性表，查找元素 X while (i &lt;= PtrL-&gt;Last &amp;&amp; PtrL-&gt;Data[i] != X) i++; // 若找到元素 X，则返回其在线性表中的位置（索引） if (i &gt; PtrL-&gt;Last) return -1; // 没有找到元素 X，返回 -1 else return i; // 成功找到元素 X，返回其位置（索引）&#125; 顺序储存的插入和删除 插入（在i的位置上插入一个值为X的元素（1&lt;&#x3D;i&lt;&#x3D;n+1) 先移动再插入 123456789101112131415161718192021222324252627282930313233// 函数名：Insert// 功能：向线性表 PtrL 中的第 i 个位置插入元素 X// 参数：// - ElementType X: 要插入的元素// - int i: 要插入的位置（索引），从 1 开始// - List PtrL: 指向线性表头节点的指针// 返回值：无void Insert(ElementType X, int i, List PtrL)&#123; int j; // 定义临时变量 j，用于循环中的计数 // 判断线性表是否已满，如果已满则无法插入元素 if (PtrL-&gt;Last == MAXSIZE - 1)//通过比较线性表的最后一个元素索引 Last 和线性表的最大容量 MAXSIZE-1 来判断线性表是否已满。 &#123; printf(&quot;该表已满&quot;); return; &#125; // 判断插入位置 i 是否合法 if (i &gt;= PtrL-&gt;Last + 2 || i &lt; 1)//检查插入位置 i 是否合法，不能超过当前线性表长度加 1，且不能小于 1。 &#123; printf(&quot;位置不合法&quot;); return; &#125; // 从后往前遍历线性表，将第 i 个位置及其后的元素都往后移动一个位置 for (j = PtrL-&gt;Last; j &gt;= i - 1; j--) &#123; PtrL-&gt;Data[j + 1] = PtrL-&gt;Data[j]; &#125; // 将元素 X 插入到第 i 个位置 // 注意：由于数组下标从 0 开始，而 i 从 1 开始计数，所以插入位置应为 i-1 PtrL-&gt;Data[i - 1] = X; // 更新线性表的最后一个元素的索引，将 Last 加 1，使其指向最后一个元素 PtrL-&gt;Last++;&#125; 删除操作(删除第i个元素）后面元素依次向前移动 123456789101112131415161718192021222324// 函数名：Delete// 功能：删除线性表 PtrL 中的第 i 个位置上的元素// 参数：// - int i: 要删除的位置（索引），从 1 开始// - List PtrL: 指向线性表头节点的指针// 返回值：无void Delete(int i, List PtrL)&#123; int j; // 定义临时变量 j，用于循环中的计数 // 检查插入位置 i 是否合法 if (i &gt;= PtrL-&gt;Last + 2 || i &lt; 1) &#123; printf(&quot;不存在第%d个元素&quot;, i); return; &#125; // 从第 i 个位置开始，将后面的元素依次往前移动一个位置 for (j = i; j &lt;= PtrL-&gt;Last; j++) &#123; PtrL-&gt;Data[j - 1] = PtrL-&gt;Data[j]; &#125; // 更新线性表的最后一个元素的索引，将 Last 减 1，表示删除了一个元素 PtrL-&gt;Last--; return;&#125; 链式储存和查找 链式储存解决了线性整体移动的问题，不要求逻辑上相邻的两个元素物理上也相邻，通过链建立数据元素之间的逻辑关系 插入删除不需要移动数据元素，只需要修改“链” 123456789101112// 定义指向结构体 LNode 的指针类型 Listtypedef struct LNode *List;// 定义结构体 LNode，表示链表节点struct LNode&#123; ElementType Data; // 存储节点的数据，ElementType 可以是任何你希望存储的数据类型 List Next; // 指向下一个节点的指针&#125;;// 声明一个结构体 LNode 类型的变量 L，用于创建链表的头节点struct LNode L;// 声明一个 List 类型的指针变量 PtrL，用于指向链表的头节点List PtrL; 求表长 12345678910111213141516171819// 函数名：Length// 功能：计算链表 PtrL 的长度（节点个数）// 参数：// - List PtrL: 指向链表头节点的指针// 返回值：链表的长度（节点个数）int Length(List PtrL)&#123; // 令 p 指向表的第一个节点，即头节点之后的第一个实际节点 List p = PtrL-&gt;Next; int j = 0; // 初始化计数器 j，用于记录节点个数 // 循环遍历链表，直到到达链表的结尾 while (p) &#123; p = p-&gt;Next; // 移动到下一个节点 j++; // 计数器 j 自增，记录节点个数 &#125; return j; // 返回计数器 j，即为链表的长度&#125; 查找 按序号查找 123456789101112131415161718192021222324// 函数名：Findkth// 功能：在链表 PtrL 中查找第 k 个节点// 参数：// - int k: 要查找的节点位置（索引），从 1 开始计数// - List PtrL: 指向链表头节点的指针// 返回值：// - 如果找到第 k 个节点，返回指向该节点的指针// - 如果没有找到第 k 个节点或链表为空，返回 NULLList Findkth(int k, List PtrL)&#123; List p = PtrL; // 令 p 指向链表的头节点 int i = 1; // 初始化计数器 i，用于记录当前节点的位置（索引） // 循环遍历链表，查找第 k 个节点或链表的结尾 while (p != NULL &amp;&amp; i &lt; k) &#123; p = p-&gt;Next; // 移动到下一个节点 i++; // 计数器 i 自增，记录当前节点的位置（索引） &#125; // 如果找到第 k 个节点，则返回指向该节点的指针 p if (i == k) return p; else return NULL; // 没有找到第 k 个节点或链表为空，返回 NULL&#125; 按值查找 // 函数名：Find // 功能：在链表 PtrL 中查找元素 X 的节点 // 参数： // - ElementType X: 要查找的元素 // - List PtrL: 指向链表头节点的指针 // 返回值： // - 如果找到元素 X 的节点，返回指向该节点的指针 // - 如果没有找到元素 X 或链表为空，返回 NULL List Find(ElementType X, List PtrL) &#123; List p = PtrL; // 令 p 指向链表的头节点 // 循环遍历链表，查找元素 X 的节点或链表的结尾 while (p != NULL &amp;&amp; p-&gt;Data != X) p = p-&gt;Next; // 移动到下一个节点 // 如果找到元素 X 的节点，则返回指向该节点的指针 p // 如果没有找到元素 X 或链表为空，则返回 NULL return p; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525. #### 链式储存的插入和删除- 插入操作（在第i个结点位置上插入一个值为X的新结点，换句话说就是在第i-1个结点后插入一个值为X的新节点） - 构造一个新结点用s指 - 找到链表的第i-1个结点，用p指 - 修改指针 ```c // 函数名：Insert // 功能：向链表 PtrL 的第 i 个位置插入元素 X // 参数： // - ElementType X: 要插入的元素 // - int i: 要插入的位置（索引），从 1 开始 // - List PtrL: 指向链表头节点的指针 // 返回值：返回指向链表头节点的指针 List Insert(ElementType X, int i, List PtrL) &#123; List p, s; // 在链表头插入元素 if (i == 1) &#123; // 申请一个新的节点 s s = (List)malloc(sizeof(struct LNode)); s-&gt;Data = X; s-&gt;Next = PtrL; // 返回指向新头节点 s 的指针，即链表的新头指针 return s; &#125; // 在其他位置插入元素 // 此处查找的节点为第 i-1 个节点 p = Findkth(i - 1, PtrL); // 如果第 i-1 个节点不存在 if (p == NULL) &#123; printf(&quot;参数出错&quot;); return NULL; &#125; else &#123; // 申请一个新的节点 s s = (List)malloc(sizeof(struct LNode)); s-&gt;Data = X; // 将新节点 s 插入到第 i-1 个节点后面 s-&gt;Next = p-&gt;Next; p-&gt;Next = s; // 返回原链表的头指针 PtrL，表示链表没有改变头节点 return PtrL; &#125; &#125; ![](https://cdn.jsdelivr.net/gh/artly1/Image/202307171636241.png) ​ 删除操作（删除第i个结点）（1&lt;&#x3D;i&lt;&#x3D;n) 先找到第i-1个结点，用p指向 然后用s指针指向第i个结点，即为p结点的下一个结点 修改指针，删除s所指向的结点 最后释放s所指向结点的空间free 12345678910111213141516171819202122232425262728293031323334353637383940414243// 函数名：Delete// 功能：删除链表 PtrL 中的第 i 个节点// 参数：// - int i: 要删除的节点位置（索引），从 1 开始// - List PtrL: 指向链表头节点的指针// 返回值：返回指向链表头节点的指针List Delete(int i, List PtrL)&#123; List p, s; // 删除头节点 if (i == 1) &#123; s = PtrL; // 如果链表不为空，将头指针后移一位 if (PtrL != NULL) PtrL = PtrL-&gt;Next; else return NULL; // 链表为空，返回空指针 free(s); // 释放原头节点的内存 return PtrL; // 返回新的头指针 &#125; // 删除其他位置的节点 // 查找第 i-1 个节点，即要删除位置的前一个节点 p = Findkth(i - 1, PtrL); // 如果第 i-1 个节点不存在 if (p == NULL) &#123; printf(&quot;第%d个结点不存在&quot;, i - 1); return NULL; &#125; else if (p-&gt;Next == NULL) &#123; printf(&quot;第%d个结点不存在&quot;, i); return NULL; &#125; else &#123; s = p-&gt;Next; // s 指向第 i 个节点 p-&gt;Next = s-&gt;Next; // 删除操作，将第 i-1 个节点的指针域 Next 指向第 i+1 个节点 free(s); // 释放第 i 个节点的内存 return PtrL; // 返回原链表的头指针 PtrL &#125;&#125; 广义表和多重链表一元多项式可以用上述式子表示，二元多项式又该如何表示？ 广义表是线性表的推广 对于线性表来说，n个元素都是基本的单元素 广义表中，这些元素不仅是单元素也可以是另一个广义表 12345678910111213// 定义指向结构体 GNode 的指针类型 GListtypedef struct GNode *GList;// 定义结构体 GNode，表示广义表的节点struct GNode&#123; int Tag; // 标志域，0 表示结点是单元素，1 表示结点是广义表 union//union：这是一个联合体，它是一种特殊的数据结构，允许在相同的内存位置存储不同类型的数据。在这里，union 中包含了两个成员：ElementType Data 和 GList Sublist。Data 用于存储单元素的数据，Sublist 用于存储子广义表的指针。 &#123; ElementType Data; // 数据域 Data，用于存储单元素数据 GList Sublist; // 指针域 Sublist，用于存储子广义表的指针 &#125; URegion; // 联合体，数据域 Data 和指针域 Sublist 复用存储空间 GList Next; // 指向后继结点的指针&#125;; 多重链表多重链表中的结点属于多个链 多重链表中的结点指针域有很多， 但是包含两个指针域的链表并不一定是多重链表， 比如双向链表不是多重链表 多重链表可以用在树和图中实现存储 堆栈什么是堆栈? 堆栈是具有一定操作约束的线性表，只在一端做插入，删除Last In First Out（LIFO）后入先出 中缀表达式：运算符位于两个数字之间 后缀表达式：运算符位于两个数字之后 抽象数据类型 原理图 堆栈的顺序存储栈的顺序存储结构通常是由一个一维数组和一个记录栈顶元素位置的变量组成 12345678910// 定义存储数据元素的最大值#define Maxsize &lt;存储数据元素的最大值&gt;// 定义指向结构体 SNode 的指针类型 Stacktypedef struct SNode *Stack;// 定义结构体 SNode，表示栈struct SNode&#123; ElementType Data[Maxsize]; // 用于存储数据元素的数组，数组大小为 Maxsize int Top; // 栈顶指针，表示栈顶元素在数组中的索引&#125;; 入栈 1234567891011121314151617181920// 函数名：Push// 功能：将元素 item 入栈// 参数：// - Stack PtrL: 指向栈的指针// - ElementType item: 要入栈的元素// 返回值：无void Push(Stack PtrL, ElementType item)&#123; // 检查栈是否已满 if (PtrL-&gt;Top == Maxsize - 1) &#123; printf(&quot;堆栈满&quot;); // 输出错误信息，表示栈已满 return; &#125; else &#123; PtrL-&gt;Data[++(PtrL-&gt;Top)] = item; // 将元素 item 入栈，栈顶指针 Top 自增 return; &#125;&#125; 出栈 123456789101112131415161718// 函数名：Pop// 功能：将栈顶元素出栈，并返回该元素的值// 参数：// - Stack PtrL: 指向栈的指针// 返回值：返回栈顶元素的值，如果栈为空，返回 ERROR（出错值）ElementType Pop(Stack PtrL)&#123; // 检查栈是否为空 if (PtrL-&gt;Top == -1) &#123; printf(&quot;堆栈空&quot;); // 输出错误信息，表示栈为空 return ERROR; // 返回 ERROR（出错值） &#125; else &#123; return (PtrL-&gt;Data[(PtrL-&gt;Top)--]); // 将栈顶元素出栈，并返回该元素的值，栈顶指针 Top 自减 &#125;&#125; 用数组实现两个堆栈，最大利用数组空间，若有空间则可以实现入栈 两个栈分别从数组的两头开始向中间生长，当两个栈的栈顶指针相遇时，表示两个栈都已经满 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 定义存储数据元素的最大个数#define MaxSize &lt;存储数据元素的最大个数&gt;// 定义结构体 DoubleStack，表示双栈struct DoubleStack &#123; ElementType Data[MaxSize]; // 用于存储数据元素的数组，数组大小为 MaxSize int Top1; // 栈1的栈顶指针 int Top2; // 栈2的栈顶指针&#125;;// 创建一个双栈 S，同时初始化栈1的栈顶指针 Top1 为 -1，栈2的栈顶指针 Top2 为 MaxSizestruct DoubleStack S;S.Top1 = -1;S.Top2 = MaxSize;// 函数名：Push// 功能：将元素 item 入栈// 参数：// - struct DoubleStack *PtrS: 指向双栈的指针// - ElementType item: 要入栈的元素// - int Tag: 表示入栈到哪个栈，Tag=1 表示栈1，Tag=2 表示栈2// 返回值：无void Push(struct DoubleStack *PtrS, ElementType item, int Tag) &#123; // 检查栈是否已满 if (PtrS-&gt;Top2 - PtrS-&gt;Top1 == 1) &#123; printf(&quot;堆栈满&quot;); // 输出错误信息，表示双栈已满 return; &#125; // 判断入栈到哪个栈，Tag=1 表示栈1，Tag=2 表示栈2 if (Tag == 1) PtrS-&gt;Data[++(PtrS-&gt;Top1)] = item; // 将元素 item 入栈到栈1，栈1的栈顶指针 Top1 自增 else PtrS-&gt;Data[--(PtrS-&gt;Top2)] = item; // 将元素 item 入栈到栈2，栈2的栈顶指针 Top2 自减&#125;// 函数名：Pop// 功能：将栈顶元素出栈，并返回该元素的值// 参数：// - struct DoubleStack *PtrS: 指向双栈的指针// - int Tag: 表示出栈哪个栈，Tag=1 表示栈1，Tag=2 表示栈2// 返回值：返回栈顶元素的值，如果栈为空，返回 NULL（出错值）ElementType Pop(struct DoubleStack *PtrS, int Tag) &#123; // 判断出栈哪个栈，Tag=1 表示栈1，Tag=2 表示栈2 if (Tag == 1) &#123; // 检查栈1是否为空 if (PtrS-&gt;Top1 == -1) &#123; printf(&quot;堆栈1空&quot;); // 输出错误信息，表示栈1为空 return NULL; // 返回 NULL（出错值） &#125; else return PtrS-&gt;Data[(PtrS-&gt;Top1)--]; // 将栈1的栈顶元素出栈，并返回该元素的值，栈1的栈顶指针 Top1 自减 &#125; else &#123; // 检查栈2是否为空 if (PtrS-&gt;Top2 == MaxSize) &#123; printf(&quot;堆栈空&quot;); // 输出错误信息，表示栈2为空 return NULL; // 返回 NULL（出错值） &#125; else return PtrS-&gt;Data[(PtrS-&gt;Top2)++]; // 将栈2的栈顶元素出栈，并返回该元素的值，栈2的栈顶指针 Top2 自增 &#125;&#125; 堆栈的链式存储 链式存储结构实际上就是一个单链表，叫做链栈，插入和删除操作只能在链栈的栈顶进行 12345678// 定义指向结构体 SNode 的指针类型 Stacktypedef struct SNode *Stack;// 定义结构体 SNode，表示栈节点struct SNode &#123; ElementType Data; // 数据域，用于存储栈节点的数据元素 struct SNode *Next; // 指针域，指向下一个栈节点的指针&#125;; 初始化 12345678910111213// 函数名：CreatStack// 功能：创建一个空栈，并返回指向栈顶节点的指针// 参数：无// 返回值：返回指向栈顶节点的指针Stack CreatStack()&#123; Stack s; // 声明一个指向栈节点的指针 s // 分配内存，创建一个栈节点 s = (Stack)malloc(sizeof(struct SNode)); // 初始化栈节点的指针域 Next 为 NULL，表示栈为空 s-&gt;Next = NULL; return s; // 返回指向栈顶节点的指针&#125; 判断堆栈s是否为空 1234int Empty(Stack s)&#123; return (s-&gt;Next == NULL);&#125; 入栈 1234567891011121314151617// 函数名：Push// 功能：将元素 item 入栈// 参数：// - ElementType item: 要入栈的元素// - Stack s: 指向栈顶节点的指针// 返回值：无void Push(ElementType item, Stack s)&#123; // 创建一个新的栈节点 struct SNode *Tmpcell; Tmpcell = (struct SNode *)malloc(sizeof(struct SNode)); // 设置新栈节点的数据域 Element 为要入栈的元素 item Tmpcell-&gt;Element = item; // 将新栈节点插入到栈顶节点之后 Tmpcell-&gt;Next = s-&gt;Next; s-&gt;Next = Tmpcell;&#125; 出栈 12345678910111213141516171819202122232425// 函数名：Pop// 功能：将栈顶元素出栈，并返回该元素的值// 参数：// - Stack s: 指向栈顶节点的指针// 返回值：返回栈顶元素的值，如果栈为空，返回 NULL（出错值）ElementType Pop(Stack s)&#123; struct SNode *Firstcell; // 声明一个指向栈节点的指针 Firstcell，用于暂存要出栈的栈顶节点 ElementType TopElement; // 声明一个变量 TopElement，用于存储要出栈的栈顶元素 // 检查栈是否为空 if (Empty(s)) &#123; printf(&quot;堆栈空&quot;); // 输出错误信息，表示栈为空 return NULL; // 返回 NULL（出错值） &#125; else &#123; // 将栈顶节点出栈，注意保存要删除的元素和栈顶元素 Firstcell = s-&gt;Next; // Firstcell 指向要删除的栈顶节点 s-&gt;Next = Firstcell-&gt;Next; // 将栈顶指针 Next 指向删除节点的下一个节点，即出栈操作 TopElement = Firstcell-&gt;Element; // 将要出栈的栈顶元素存储到 TopElement 中 free(Firstcell); // 释放删除的节点的内存，即释放栈顶节点的内存 return TopElement; // 返回栈顶元素的值 &#125;&#125; 堆栈的应用 中缀表达式转换为后缀表达式 运算数：直接输出 左括号：入栈 右括号：栈顶元素出栈并输出，直到遇到左括号 运算符：优先级大于栈顶运算符，入栈；优先级小于等于栈顶运算符出栈输出，继续比较新的栈顶运算符 处理完毕后，将堆栈剩余元素一并输出 队列 队列及顺序存储具有一定操作约束的线性表 插入和删除操作：只能在一端插入，而在另一端删除 数据插入：入队列 数据删除：出队列 先进先出（FIFO）First In First Out 抽象数据描述 队列存储的实现 队列的顺序存储结构通常由一个一维数组和一个记录队列头元素位置的变量ront以及一个记录队列尾元素位置的变量rear组成 1234567891011// 定义存储数据元素的最大个数#define Maxsize &lt;数据元素的最大个数&gt;// 定义队列结构体 QNodestruct QNode &#123; ElementType Data[Maxsize]; // 用于存储数据元素的数组，数组大小为 Maxsize int rear; // 队尾指针，指向队列最后一个元素的下标 int front; // 队首指针，指向队列第一个元素之前的位置&#125;;// 定义指向队列结构体 QNode 的指针类型 Queuetypedef struct QNode *Queue;// front 指的是第一个元素之前的位置 在顺环队列判断是否满的问题上使用额外标记Tag域或者Size 入队 1234567891011121314151617// 函数名：AddQ// 功能：向队列尾部添加元素// 参数：// - Queue PtrL: 指向队列的指针// - ElementType item: 要添加的元素// 返回值：无void AddQ(Queue PtrQ, ElementType item)&#123; // 检查队列是否已满 if ((PtrQ-&gt;rear + 1) % Maxsize == PtrQ-&gt;front) &#123; printf(&quot;队列满&quot;); // 输出错误信息，表示队列已满 return; // 返回，不执行入队操作 &#125; // 将队尾指针后移一位，考虑循环队列的情况 PtrQ-&gt;rear = (PtrQ-&gt;rear + 1) % Maxsize; 出队 123456789101112131415161718192021// 函数名：DQ// 功能：从队列头部删除元素，并返回该元素的值// 参数：// - Queue PtrQ: 指向队列的指针// 返回值：返回队列头部元素的值，如果队列为空，返回 ERROR（出错值）ElementType DQ(Queue PtrQ)&#123; // 检查队列是否为空 if (PtrQ-&gt;rear == PtrQ-&gt;front) &#123; printf(&quot;队列空&quot;); // 输出错误信息，表示队列为空 return ERROR; // 返回 ERROR（出错值） &#125; else &#123; // 将队首指针后移一位，考虑循环队列的情况 PtrQ-&gt;front = (PtrQ-&gt;front + 1) % Maxsize; // 返回队列头部元素的值 return PtrQ-&gt;Data[PtrQ-&gt;front]; &#125;&#125; 队列的链式存储1234567891011121314// 定义链式队列节点结构体 Nodestruct Node &#123; ElementType Data; // 数据域，用于存储节点的数据元素 struct Node *Next; // 指针域，指向下一个节点的指针&#125;;// 定义链式队列结构体 QNodestruct QNode &#123; struct Node *rear; // 队尾指针，指向队列中最后一个元素的节点 struct Node *front; // 队首指针，指向队列中第一个元素的节点&#125;;// 定义指向链式队列结构体 QNode 的指针类型 Queuetypedef struct QNode *Queue;// 声明一个指向链式队列结构体 QNode 的指针 PtrQQueue PtrQ; 出队 12345678910111213141516171819202122232425262728// 函数名：DQ// 功能：从队列头部删除元素，并返回该元素的值// 参数：// - Queue PtrQ: 指向链式队列的指针// 返回值：返回队列头部元素的值，如果队列为空，返回 ERROR（出错值）ElementType DQ(Queue PtrQ)&#123; struct Node *Frontcell; // 声明一个指向链式队列节点的指针 Frontcell，用于暂存要出队的节点 ElementType Frontelement; // 声明一个变量 Frontelement，用于存储要出队的队列头部元素 // 检查队列是否为空 if (PtrQ-&gt;front == NULL) &#123; printf(&quot;空&quot;); // 输出错误信息，表示队列为空 return ERROR; // 返回 ERROR（出错值） &#125; // 将队首节点出队 Frontcell = PtrQ-&gt;front; // Frontcell 指向要出队的队列头部节点 // 分情况讨论，队列只有一个元素和多个元素 if (PtrQ-&gt;front == PtrQ-&gt;rear) PtrQ-&gt;front = PtrQ-&gt;rear = NULL; // 如果队列只有一个元素，出队后将队首指针和队尾指针都设置为 NULL，表示队列为空 else PtrQ-&gt;front = PtrQ-&gt;front-&gt;Next; // 如果队列有多个元素，将队首指针后移，即将第二个节点设置为队首节点 Frontelement = Frontcell-&gt;Data; // 将要出队的队列头部元素存储到 Frontelement 中 free(Frontcell); // 释放出队的节点的内存，即释放队列头部节点的内存 return Frontelement; // 返回队列头部元素的值，表示成功出队&#125; 多项式问题 加法运算的实现采用不带头结点的单项链表。按照指数递减的顺序排列各项 1234567struct PolyNode&#123; int coef;//系数 int expon;//指数 struct PolyNode *link;&#125;;typedef struct PolyNode *Polynomial;Polynomial P1,P2; 算法思路P1-&gt;expon&#x3D;&#x3D;P2-&gt;expon:系数相加，若结果不为0，则作为结果多项式对应系数。同时，P1和P2 都指向下一项P1-&gt;expon&gt;P2-&gt;expon将P1存入当前多项式，并使P1指向下一项P1-&gt;expon &lt; P2-&gt;expon将P2存入当前多项式，并使P2指向下一项 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 函数名：Polynomial Polyadd(Polynomial P1, Polynomial P2)// 功能：多项式相加// 参数：// - Polynomial P1: 第一个多项式的头结点指针// - Polynomial P2: 第二个多项式的头结点指针// 返回值：返回多项式相加后的结果多项式的头结点指针Polynomial Polyadd(Polynomial P1, Polynomial P2)&#123; Polynomial front, rear, temp; int sum; rear = (Polynomial)malloc(sizeof(struct PolyNode)); front = rear; // front 这里指的是多项式链表头结点 while (P1 &amp;&amp; P2) &#123; switch (Compare(P1-&gt;expon, P2-&gt;expon)) &#123; case 1: Attach(P1-&gt;coef, P1-&gt;expon, &amp;rear); P1 = P1-&gt;link; break; case -1: Attach(P2-&gt;coef, P2-&gt;expon, &amp;rear); P2 = P2-&gt;link; break; case 0: sum = P1-&gt;coef + P2-&gt;coef; if (sum) Attach(sum, P1-&gt;expon, &amp;rear); P1 = P1-&gt;link; P2 = P2-&gt;link; break; &#125; &#125; // 还有未处理完的另一个多项式的所有结点依此复制 for (; P1; P1 = P1-&gt;link) Attach(P1-&gt;coef, P1-&gt;expon, &amp;rear); for (; P2; P2 = P2-&gt;link) Attach(P2-&gt;coef, P2-&gt;expon, &amp;rear); rear-&gt;link = NULL; // 将链表最后一个节点的 next 指针置为 NULL，表示链表结束 temp = front; front = front-&gt;link; // 头结点的下一个节点即为结果多项式的头结点 free(temp); // 释放头结点的内存，防止内存泄漏 return front; // 返回结果多项式的头结点指针&#125;// 函数名：void Attach(int c, int e, Polynomial *pRear)// 功能：将系数为 c，指数为 e 的节点添加到链表中// 参数：// - int c: 系数值// - int e: 指数值// - Polynomial *pRear: 链表尾节点的指针的指针，用于更新链表尾节点// 返回值：无void Attach(int c, int e, Polynomial *pRear)&#123; Polynomial P; P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;coef = c; P-&gt;expon = e; P-&gt;link = NULL; (*pRear)-&gt;link = P; *pRear = P; // 修改 pRear 值，使其指向链表尾部节点，以便下次添加节点时可以直接在尾部插入&#125; 题意理解与多项式表示 数据结构设计 12345678910111213// 定义多项式结点指针类型 Polynomial，是指向 struct PolyNode 结构体的指针typedef struct PolyNode *Polynomial;// 定义多项式结点结构体 PolyNodestruct PolyNode&#123; int coef; // 系数，用于存储多项式项的系数值 int expon; // 指数，用于存储多项式项的指数值 Polynomial link; // 指向下一个多项式结点的指针，用于将多项式的各项连接在一起&#125;;// 这个代码片段定义了一个简单的链式存储结构用于表示多项式。// 多项式的每一项包含两个部分：系数 coef 和指数 expon。// 用链表将各项连接在一起，每个节点通过 link 指针指向下一个节点。// 多项式的头结点可以用 Polynomial 类型的指针来表示，即指向第一个多项式节点的指针。 程序框架及读入多项式 123456789101112131415161718192021// 函数名：main// 功能：主函数，用于调用多项式相关函数// 返回值：整数类型，表示程序的结束状态int main()&#123; // 声明多项式 P1, P2, PP, PS Polynomial P1, P2, PP, PS; // 读入第一个多项式 P1 P1 = ReadPoly(); // 读入第二个多项式 P2 P2 = ReadPoly(); // 将两个多项式 P1 和 P2 相乘，结果存储在 PP 中 PP = Mult(P1, P2); // 打印相乘结果多项式 PP PrintPoly(PP); // 将两个多项式 P1 和 P2 相加，结果存储在 PS 中 PS = Add(P1, P2); // 打印相加结果多项式 PS PrintPoly(PS); return 0; // 返回程序的结束状态，表示成功执行&#125; 读取多项式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 函数名：Polynomial ReadPoly()// 功能：读取一个多项式，并以链表形式返回该多项式的头结点指针// 返回值：多项式的头结点指针Polynomial ReadPoly()&#123; // 声明多项式头结点指针 P, Rear 和临时指针 t Polynomial P, Rear, t; int c, e, N; // 从标准输入读取多项式的项数 N scanf(&quot;%d&quot;, &amp;N); // 创建链表头空结点 P，Rear 指向头结点 P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;link = NULL; Rear = P; // 依次读入 N 个多项式项，并将其插入链表尾部 while (N--) &#123; scanf(&quot;%d %d&quot;, &amp;c, &amp;e); Attach(c, e, &amp;Rear); // 将当前项插入多项式尾部 &#125; // 删除临时生成的头结点，并将链表的真正头结点指针 P 返回 t = P; P = P-&gt;link; free(t); return P;&#125;// 函数名：void Attach(int c, int e, Polynomial *pRear)// 功能：将系数为 c，指数为 e 的节点添加到链表中// 参数：// - int c: 系数值// - int e: 指数值// - Polynomial *pRear: 链表尾节点的指针的指针，用于更新链表尾节点// 返回值：无void Attach(int c, int e, Polynomial *pRear)&#123; // 创建新的多项式节点 P，并分别赋值系数和指数 Polynomial P; P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;coef = c; P-&gt;expon = e; P-&gt;link = NULL; // 将新节点 P 插入链表尾部，更新链表尾节点指针 pRear (*pRear)-&gt;link = P; *pRear = P;&#125; 加法乘法及多项式的输出 上面已经写过此代码 两个多项式相乘 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// 函数名：Polynomial Mult(Polynomial P1, Polynomial P2)// 功能：计算两个多项式 P1 和 P2 的乘积，结果以链表形式返回// 参数：// - Polynomial P1: 第一个多项式的头结点指针// - Polynomial P2: 第二个多项式的头结点指针// 返回值：多项式的头结点指针，表示乘积多项式Polynomial Mult(Polynomial P1, Polynomial P2)&#123; // 声明多项式头结点指针 P, Rear 和临时指针 t1, t2, t Polynomial P, Rear, t1, t2, t; int c, e; // 如果 P1 或 P2 为空，则返回空指针 if (!P1 || !P2) return NULL; // 复制 P1 的头结点，用于计算结果多项式 P t1 = P1; // 复制 P2 的头结点，用于遍历 P2 t2 = P2; // 创建链表头空结点 P，Rear 指向头结点 P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;link = NULL; Rear = P; // 第一重循环，计算 P1 的第一项和 P2 的每一项的乘积，插入到结果多项式 P 中 while (t2) &#123; // 将 P1 的第一项与 P2 的当前项相乘，并将结果插入到结果多项式 P 中 Attach(t1-&gt;coef * t2-&gt;coef, t1-&gt;expon + t2-&gt;expon, &amp;Rear); // 将 P2 的指针 t2 后移，继续处理下一项 t2 = t2-&gt;link; &#125; // 将 P1 的指针 t1 后移，继续处理下一项 t1 = t1-&gt;link; // 第二重循环，计算 P1 的每一项和 P2 的每一项的乘积，插入到结果多项式 P 中 while (t1) &#123; // 重新将 P2 的指针 t2 移回 P2 的头结点，并将 Rear 指针指向结果多项式 P 的头结点 t2 = P2; Rear = P; // 遍历 P2，计算 P1 的当前项与 P2 的每一项的乘积，并插入到结果多项式 P 中 while (t2) &#123; // 计算当前项的指数和系数 e = t1-&gt;expon + t2-&gt;expon; c = t1-&gt;coef * t2-&gt;coef; // 找到合适的位置插入或处理相等指数的情况 while (Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon &gt; e) Rear = Rear-&gt;link; // 处理相等指数的情况，相同指数项的系数相加 if (Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon == e) &#123; if (Rear-&gt;link-&gt;coef == c) Rear-&gt;link-&gt;coef += c; else &#123; // 删除节点，系数为 0 的项 t = Rear-&gt;link; Rear-&gt;link = t-&gt;link; free(t); &#125; &#125; // 不相等则申请新的结点并插入 else &#123; t = (Polynomial)malloc(sizeof(struct PolyNode)); t-&gt;coef = c; t-&gt;expon = e; // 插入过程 t-&gt;link = Rear-&gt;link; Rear-&gt;link = t; Rear = Rear-&gt;link; &#125; t2 = t2-&gt;link; &#125; // 处理完 P1 的一项，将指针后移，继续处理下一项 t1 = t1-&gt;link; &#125; // 删除临时生成的头结点，并将链表的真正头结点指针 P 返回 t2 = P; P = P-&gt;link; free(t2); return P;&#125; 多项式输出 12345678910111213141516171819202122232425262728293031// 函数名：void PrintPoly(Polynomial P)// 功能：打印多项式 P 的系数和指数// 参数：// - Polynomial P: 多项式的头结点指针// 返回值：无void PrintPoly(Polynomial P)&#123; int flag = 0; // flag 用于调整输出格式，初始为 0 // 如果多项式为空，则打印 &quot;0 0&quot; 表示零多项式，并直接返回 if (!P) &#123; printf(&quot;0 0\\n&quot;); return; &#125; // 遍历多项式链表并输出系数和指数 while (P) &#123; // 当 flag 为 0 时，输出第一项，不加空格；否则输出空格 if (!flag) flag = 1; else printf(&quot; &quot;); // 输出当前多项式节点的系数和指数 printf(&quot;%d %d&quot;, P-&gt;coef, P-&gt;expon); // 指针后移，处理下一项 P = P-&gt;link; &#125; // 打印完所有项后换行 printf(&quot;\\n&quot;);&#125; 第三章（树.上）树与树的表示 顺序查找 查找：根据给定某个关键字K，从集合R中找出关键字与K相同的记录 静态查找：集合中记录是固定的，没有删除和插入操作只有查找操作 动态查找：集合中记录是动态的，除了查找操作，还可能有删除和插入操作&#96; 12345678910// 定义一个指向结构体 LNode 的指针类型 Listtypedef struct LNode* List;// 定义结构体 LNodestruct LNode &#123; // 数据域，用于存储元素的数组 ElementType Element[Maxsize]; // 当前线性表的长度 int length;&#125;; 有哨兵 1234567891011121314151617// 在顺序表 Tb1 中进行顺序查找元素 K 的位置// 参数：// - List Tb1: 顺序表的指针，表示要进行查找的顺序表// - ElementType K: 要查找的元素// 返回值：// - 如果找到元素 K，返回其在顺序表 Tb1 中的位置；如果未找到，返回 -1。int SequentialSearch(List Tb1, ElementType K)&#123; int i; // 将要查找的元素 K 放在顺序表 Tb1 的第一个位置，作为哨兵 Tb1-&gt;Element[0] = K; // 从顺序表的末尾开始逆序遍历，查找元素 K 的位置 for (i = Tb1-&gt;length; Tb1-&gt;Element[i] != K; i--); // 如果 i 等于 0，说明未找到元素 K，返回 -1 // 否则返回找到的元素 K 在顺序表 Tb1 中的位置 return i ;&#125; 无哨兵 123456789101112131415// 在顺序表 Tb1 中进行顺序查找元素 K 的位置// 参数：// - List Tb1: 顺序表的指针，表示要进行查找的顺序表// - ElementType K: 要查找的元素// 返回值：// - 如果找到元素 K，返回其在顺序表 Tb1 中的位置；如果未找到，返回 -1。int SequentialSearch(List Tb1, ElementType K)&#123; int i; // 从顺序表的末尾开始逆序遍历，查找元素 K 的位置 for (i = Tb1-&gt;length; i &gt; 0 &amp;&amp; Tb1-&gt;Element[i] != K; i--); // 如果 i 等于 0，说明未找到元素 K，返回 -1 // 否则返回找到的元素 K 在顺序表 Tb1 中的位置 return i == 0 ? -1 : i;&#125; 二分查找（Binary Search）要求：数组连续，有序思路：利用mid，right，left三者的比较缩小范围，查找值left&gt;right?查找失败：结束;复杂度：log（n） 1234567891011121314151617181920212223242526272829// 在有序顺序表 Tb1 中进行二分查找元素 K 的位置// 参数：// - List Tb1: 有序顺序表的指针，表示要进行查找的顺序表// - ElementType K: 要查找的元素// 返回值：// - 如果找到元素 K，返回其在顺序表 Tb1 中的位置（数组下标）；如果未找到，返回 -1。int BinarySearch(List Tb1, ElementType K)&#123; int mid, right, left, notFound = -1; left = 1; // 左边界，初始为第一个元素位置 right = Tb1-&gt;length; // 右边界，初始为最后一个元素位置 mid = (left + right) / 2; // 中间位置 while (left &lt;= right) &#123; // 如果中间元素大于要查找的元素 K，说明要查找的元素在左半部分 if (Tb1-&gt;Element[mid] &gt; K) right = mid - 1; // 如果中间元素小于要查找的元素 K，说明要查找的元素在右半部分 else if (Tb1-&gt;Element[mid] &lt; K) left = mid + 1; // 查找成功，返回元素 K 的位置（数组下标） else return mid; // 更新中间位置 mid = (left + right) / 2; &#125; // 循环结束仍未找到，返回未找到标志 -1 return notFound;&#125; 树的定义和表示 定义：树是由n（n&gt;&#x3D;0）个结点构成的有限集合 每一个树都有一个根结点（root），用r表示 其余结点可以分为数个互不相交的有限集合，每个集合又是一个树，称为原来树的子树 每颗树的子树互不相交，除了根结点外，每个结点只有一个父结点，每个有N个结点的树有N-1条边 树的一些基本术语： 结点的度：结点的子树个数。 树的度: 是所有结点中最大的度数。 节点的层次：规定根结点在一层，其他任一节点层次是其父结点的层次＋1 树的深度：树中所有结点的最大层次 二叉树及存储结构 二叉树的定义和性质定义：有穷的集合 集合可以为空 若不为空，则有左子树和右子树两个互不交叉的二叉树 性质： 一个二叉树第i层最大的结点数为2^i-1^ ,i&gt;&#x3D;1 深为k的二叉树最大的结点数为2^k-1^ ，k&gt;&#x3D;1 对于任意非空二叉树，n0代表叶结点个数，n2代表度数为2的非叶结点个数，那么满足n0&#x3D;n2+1 二叉树的存储结构 顺序存储结构完全二叉树：按照从上到下，从左到右的顺序存储n个节点完全二叉树的父子结点关系 非根结点序号为i&#x2F;2 序号结点为i的左孩子结点的序号为2i 序号结点为i的右孩子结点的序号为2i+1 一般二叉树采用此种存储方法会造成空间的浪费 链表存储结构 1234567891011// 定义二叉树结点的结构体，使用 typedef 别名 BinTree 表示指向该结构体的指针类型typedef struct TreeNode *BinTree;// 使用别名 Position 表示指向二叉树结点的指针类型typedef BinTree Position;// 定义二叉树结点的结构体struct TreeNode&#123; ElementType Data; // 存储结点的数据 BinTree Left; // 左子树的指针 BinTree Right; // 右子树的指针&#125;; 二叉树的遍历 先序 中序 后序 先序访问根结点遍历左子树遍历右子树 123456789101112131415161718// 前序遍历二叉树// 参数：// - BinTree BT: 二叉树的根结点指针// 返回值：// - 无，函数用于打印二叉树的前序遍历结果。void PreorderTraversal(BinTree BT)&#123; // 判断当前结点是否为空 if (BT) &#123; // 如果当前结点不为空，打印当前结点的数据 printf(&quot;%d &quot;, BT-&gt;Data); // 递归遍历左子树 PreorderTraversal(BT-&gt;Left); // 递归遍历右子树 PreorderTraversal(BT-&gt;Right); &#125;&#125; 中序遍历左子树访问根结点遍历右子树 123456789101112131415161718// 中序遍历二叉树// 参数：// - BinTree BT: 二叉树的根结点指针// 返回值：// - 无，函数用于打印二叉树的中序遍历结果。void InorderTraversal(BinTree BT)&#123; // 判断当前结点是否为空 if (BT) &#123; // 递归遍历左子树 InorderTraversal(BT-&gt;Left); // 如果当前结点不为空，打印当前结点的数据 printf(&quot;%d &quot;, BT-&gt;Data); // 递归遍历右子树 InorderTraversal(BT-&gt;Right); &#125;&#125; 后序遍历左子树遍历右子树访问根结点 123456789101112131415161718// 后序遍历二叉树// 参数：// - BinTree BT: 二叉树的根结点指针// 返回值：// - 无，函数用于打印二叉树的后序遍历结果。void PostorderTraversal(BinTree BT)&#123; // 判断当前结点是否为空 if (BT) &#123; // 递归遍历左子树 PostorderTraversal(BT-&gt;Left); // 递归遍历右子树 PostorderTraversal(BT-&gt;Right); // 如果当前结点不为空，打印当前结点的数据 printf(&quot;%d &quot;, BT-&gt;Data); &#125;&#125; 中序非递归思路：利用堆栈 遇到一个结点就把它堆栈，然后遍历其左子树 遍历完左子树后将该结点弹出并访问 利用有指针中序遍历该结点右子树 123456789101112131415161718192021222324// 中序遍历二叉树（非递归版本）// 参数：// - BinTree BT: 二叉树的根结点指针// 返回值：// - 无，函数用于打印二叉树的中序遍历结果。void InorderTraversal(BinTree BT)&#123; BinTree T = BT; // 定义辅助指针T，初始指向根结点 Stack S = CreatStack(MaxSize); // 创建一个栈S，用于辅助遍历 while (T || !isEmpty(S)) // 当T不为空或栈S不为空时继续遍历 &#123; while (T) // 将指针T沿左子树一直向下，直到叶子结点 &#123; Push(S, T); // 将结点指针T入栈 T = T-&gt;Left; // 移动指针T指向左孩子结点 &#125; if (!isEmpty(S)) // 当栈S不为空时，弹出栈顶元素 &#123; T = Pop(S); // 弹出并取出栈顶元素，赋值给指针T printf(&quot;%5d&quot;, T-&gt;Data); // 打印当前结点的数据 T = T-&gt;Right; // 将指针T指向当前结点的右孩子结点 &#125; &#125; 层序思路：利用队列层序基本过程：遍历从根结点开始，首先将根结点入队，然后执行循环：结点出队，访问该结点，其左右儿子入队 123456789101112131415161718192021222324// 层序遍历二叉树// 参数：// - BinTree BT: 二叉树的根结点指针// 返回值：// - 无，函数用于打印二叉树的层序遍历结果。void LevelOrderTraversal(BinTree BT)&#123; BinTree T; // 定义辅助指针T，用于遍历二叉树的结点 Queue Q; // 定义队列Q，用于存储待遍历的结点 if (!BT) return; // 若二叉树为空树，直接返回 // 初始化队列 Q = CreatQueue(MaxSize); AddQ(Q, BT); // 将根结点入队列 while (!isEmpty(Q)) &#123; // 取出队列的头结点，并访问该结点 T = DeletQ(Q); printf(&quot;%5d&quot;, T-&gt;Data); // 如果当前结点有左子节点，将左子节点入队列 if (T-&gt;Left) AddQ(Q, T-&gt;Left); // 如果当前结点有右子节点，将右子节点入队列 if (T-&gt;Right) AddQ(Q, T-&gt;Right); &#125;&#125; 例求二叉树高度123456789101112131415161718192021222324// 中序遍历二叉树并计算二叉树的高度// 参数：// - BinTree BT: 二叉树的根结点指针// 返回值：// - int: 二叉树的高度int InOrderTraversal(BinTree BT)&#123; int Hr, Hl, Maxh; if (BT) &#123; // 递归遍历左子树，并获取左子树的高度 Hl = InOrderTraversal(BT-&gt;Left); // 递归遍历右子树，并获取右子树的高度 Hr = InOrderTraversal(BT-&gt;Right); // 计算当前树的高度，即左右子树高度的最大值加1（加1是因为要算上当前结点） Maxh = (Hl &gt; Hr ? Hl : Hr) + 1; return Maxh; &#125; else &#123; // 代表该树为空树，高度为0 return 0; &#125;&#125; 第四章（树.中）二叉搜索树二叉搜索树又称为二叉排序树或二叉选择树 满足以下性质： 二叉树可以为空 非空左子树所有键值小于根结点键值 非空右子树所有键值大于根结点键值 左子树和右子树都是二叉搜索树 查找 从查找跟结点开始，若根结点为空，直接返回NULL 若根结点不为空，根结点关键字和X进行比较 若根节点键值大于X则从左子树继续搜索 若根节点键值小于X则从右子树继续搜索 若两者相等，搜索查找完成，结束 12345678910111213141516// 在二叉搜索树中查找元素 X// 参数：// - ElementType X: 待查找的元素// - BinTree BT: 二叉搜索树的根结点指针// 返回值：// - Position: 若找到元素 X，返回对应结点的指针，否则返回 NULL。Position Find(ElementType X, BinTree BT)&#123; if (!BT) return NULL; // 若当前结点为空树（NULL），说明未找到 X，返回 NULL if (BT-&gt;Data &gt; X) return Find(X, BT-&gt;Left); // 若当前结点值大于 X，说明 X 在左子树中，继续在左子树中查找 else if (BT-&gt;Data &lt; X) return Find(X, BT-&gt;Right); // 若当前结点值小于 X，说明 X 在右子树中，继续在右子树中查找 else return BT; // 若当前结点值等于 X，说明找到了 X，返回当前结点指针&#125; 但非递归函数执行效率更高，可将递归函数改为迭代函数 1234567891011121314151617181920// 在二叉搜索树中循环查找元素 X// 参数：// - ElementType X: 待查找的元素// - BinTree BT: 二叉搜索树的根结点指针// 返回值：// - Position: 若找到元素 X，返回对应结点的指针，否则返回 NULL。Position InterFind(ElementType X, BinTree BT)&#123; while (BT) &#123; if (BT-&gt;Data &gt; X) BT = BT-&gt;Left; // 如果当前结点值大于 X，说明 X 在当前结点的左子树中，移动到左子树继续查找 else if (BT-&gt;Data &lt; X) BT = BT-&gt;Right; // 如果当前结点值小于 X，说明 X 在当前结点的右子树中，移动到右子树继续查找 else return BT; // 如果当前结点值等于 X，说明找到了 X，返回当前结点指针 &#125; // 如果树为空，返回 NULL return NULL;&#125; 最大元素一定在最右分支端结点上 最小元素一定在最左分支端结点上 查找最小元素递归 12345678910111213// 递归查找二叉搜索树中的最小元素// 参数：// - BinTree BT: 二叉搜索树的根结点指针// 返回值：// - Position: 返回最小元素所在结点的指针，若树为空则返回 NULL。Position FindMin(BinTree BT)&#123; if (!BT) return NULL; // 若当前结点为空树（NULL），说明树为空，直接返回 NULL // 若当前结点的左子树为空，说明当前结点为最小元素所在结点，直接返回当前结点指针 else if (!BT-&gt;Left) return BT; // 否则递归调用 FindMin 函数，在当前结点的左子树中继续查找最小元素 else return FindMin(BT-&gt;Left);&#125; 查找最大元素迭代 123456789101112131415// 迭代查找二叉搜索树中的最大元素// 参数：// - BinTree BT: 二叉搜索树的根结点指针// 返回值：// - Position: 返回最大元素所在结点的指针，若树为空则返回 NULL。Position FindMax(BinTree BT)&#123; if (BT) &#123; // 沿右结点查找，直到最右叶结点 while (BT-&gt;Right) BT = BT-&gt;Right; &#125; return BT;&#125; 插入方法类似find 123456789101112131415161718192021222324// 向二叉搜索树中插入元素 X// 参数：// - ElementType X: 要插入的元素值// - BinTree BST: 二叉搜索树的根结点指针// 返回值：// - BinTree: 返回插入后的二叉搜索树的根结点指针BinTree Insert(ElementType X, BinTree BST)&#123; // 若该树为空，生成并返回一个只包含一个结点的二叉树 if (!BST) &#123; BST = malloc(sizeof(struct TreeNode)); BST-&gt;Data = X; BST-&gt;Right = BST-&gt;Left = NULL; //将新结点的左右子树指针初始化为空。 &#125; else &#123; if (BST-&gt;Data &gt; X) BST-&gt;Left = Insert(X, BST-&gt;Left); // 将 X 插入左子树 else if (BST-&gt;Data &lt; X) BST-&gt;Right = Insert(X, BST-&gt;Right); // 将 X 插入右子树 &#125; return BST;&#125; 3.删除分三种情况 若删除的为叶结点，则直接删除，并将父结点指针置为NULL 若删除的结点只有一个孩子结点，则将父结点指向要删除结点的孩子结点 若要删除的结点有左右两颗子树，则用其他结点替代要删除的结点，左子树的最大元素或者右子树的最小元素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 从二叉搜索树中删除元素 X// 参数：// - ElementType X: 要删除的元素值// - BinTree BST: 二叉搜索树的根结点指针// 返回值：// - BinTree: 返回删除元素后的二叉搜索树的根结点指针BinTree Delete(ElementType X, BinTree BST)&#123; Position Tmp; // 若树为空，表示未找到要删除的元素 X，打印提示信息并直接返回 if (!BST) &#123; printf(&quot;未查找到&quot;); return NULL; &#125; else if (BST-&gt;Data &gt; X) BST-&gt;Left = Delete(X, BST-&gt;Left); // 在左子树中继续查找并删除元素 X else if (BST-&gt;Data &lt; X) BST-&gt;Right = Delete(X, BST-&gt;Right); // 在右子树中继续查找并删除元素 X else &#123; // 找到要删除的结点 // 被删除的结点有左右两个子结点 if (BST-&gt;Left &amp;&amp; BST-&gt;Right) &#123; Tmp = FindMin(BST-&gt;Right); // 用右子树中最小值替代被删除结点的值 BST-&gt;Data = Tmp-&gt;Data; BST-&gt;Right = Delete(BST-&gt;Data, BST-&gt;Right); &#125; else &#123; // 被删除的结点有一个或无子结点 Tmp = BST; // 如果左边是空的，则把右边指针指向父亲结点 if (!BST-&gt;Left) BST = BST-&gt;Right; else if (!BST-&gt;Right) BST = BST-&gt;Left; free(Tmp); &#125; &#125; return BST;&#125; 平衡二叉树平衡因子BF(T)&#x3D; hL- hR,其中hL和hR分别为左右子树高度平衡二叉树：空树，或者任一结点左右子树高度差的绝对值不超过1即|BF(T)|&lt;&#x3D;1 给定结点树为n的avl树的最大高度为O(log2n) 平衡二叉树的调整： 判断被破坏点的位置确定旋转方向 RR旋转 LL旋转 LR旋转 RL旋转 小白专场（空）第五章（树.下）堆 优先队列：特殊的队列，取出元素的顺序时依照元素的优先权大小，而不是元素进入队列的先后顺序优先队列的完全二叉树 结构性：用数组表示的完全二叉树 有序性：任一结点的关键字是其子树所有结点的最大值或者最小值 抽象数据描述： 最大堆创建 1234567891011121314151617181920212223typedef struct HeapStruct *MaxHeap;struct HeapStruct &#123; // 存储堆元素的数组 ElementType *Elements; // 堆当前元素个数 int Size; // 堆的最大容量 int Capacity;&#125;// 创建最大堆MaxHeap CreateMaxHeap(int MaxSize)&#123; // 分配内存空间用于存储最大堆 MaxHeap H = malloc(sizeof(struct HeapStruct)); // 分配内存空间用于存储堆元素的数组 H-&gt;Elements = malloc((MaxSize + 1) * sizeof(ElementType)); // 初始化堆的相关属性 H-&gt;Size = 0; H-&gt;Capacity = MaxSize; // 设置哨兵，哨兵的值为最大可能的元素值 H-&gt;Elements[0] = MaxData; return H;&#125; 最大堆的插入将新增结点插入到从父结点到跟结点的有序序列中 123456789101112131415161718192021// 向最大堆中插入元素void insert(MaxHeap H, ElementType item)&#123; int i; // 判断最大堆是否已满 if (isFull(H)) &#123; printf(&quot;最大堆已满&quot;); return; &#125; // 将元素插入堆的末尾 i = ++H-&gt;Size; // 向上调整结点，找到插入位置 for (; H-&gt;Elements[i / 2] &lt; item; i /= 2) &#123; // 将父结点的值下滤到当前结点 H-&gt;Elements[i] = H-&gt;Elements[i / 2]; &#125; // 将元素插入到找到的位置 H-&gt;Elements[i] = item;&#125; 最大堆的删除取出根结点最大值元素，同时删除堆的一个结点 1234567891011121314151617181920212223242526272829303132// 从最大堆中删除最大元素ElementType DeletMax(MaxHeap H)&#123; int Parent, Child; ElementType MaxItem, temp; // 判断最大堆是否为空 if (IsEmpty(H)) &#123; printf(&quot;最大堆已空&quot;); return; &#125; // 取出根结点最大值，用最大堆中最后一个元素从根结点开始向下过滤下层结点 MaxItem = H-&gt;Elements[1]; temp = H-&gt;Elements[H-&gt;Size--]; for (Parent = 1; Parent * 2 &lt;= H-&gt;Size; Parent = Child) &#123; // 将Child指向左右儿子中较大的一个 Child = Parent * 2; // 如果有右儿子并且右儿子的值大于左儿子，则Child指向右儿子 if ((Child != H-&gt;Size) &amp;&amp; (H-&gt;Elements[Child] &lt; H-&gt;Elements[Child + 1])) Child++; // 如果temp的值大于等于Child结点的值，则找到了temp应该插入的位置，退出循环 if (temp &gt;= H-&gt;Elements[Child]) break; else // 将较大的Child结点上滤到Parent结点位置 H-&gt;Elements[Parent] = H-&gt;Elements[Child]; &#125; // 将temp插入到找到的位置 H-&gt;Elements[Parent] = temp; return MaxItem;&#125; 最大堆的建立：将已经存在的N个元素按照最大堆的要求存放在一个一维数组中 ​ 线性复杂度下建立最大堆 ​ N个元素按线性存入，完全满足二叉树结构特性 ​ 调整各个结点的位置，以满足最大堆的有序性 哈弗曼树例：将百分制成绩转换为五分制成绩结点不同的查找频率可构造更加有效的生成树 哈夫曼树的定义带权路径长度（WPL）：设二叉树有n个叶子结点，每个叶子结点带有权值wk，从根节点到每个叶子结点的长度为lk，则每个叶子结点的带权路径长度之和为 哈弗曼树在做一个问题，如何排序结点使得WPL值最小 哈夫曼树的构造 每次把权值最小的两棵树合并 12345678910111213141516171819202122232425typedef struct TreeNode *HuffmanTree;struct TreeNode &#123; int Weight; // 结点的权值 HuffmanTree Left, Right; // 左右子树的指针&#125;;// 哈夫曼树的构建HuffmanTree Huffman(MinHeap H) &#123; // 假设H-&gt;Size个权值已经存在H-&gt;Elements[]-&gt;Weight中 int i; HuffmanTree T; BuildMinHeap(H); // 将最小堆转换为最小优先队列 // 通过贪心算法构建哈夫曼树 for (i = 1; i &lt; H-&gt;Size; i++) &#123; // 建立新结点 T = malloc(sizeof(struct TreeNode)); T-&gt;Left = DeleteMin(H); // 从最小优先队列中删除最小权值的结点作为左子树 T-&gt;Right = DeleteMin(H); // 从最小优先队列中删除次小权值的结点作为右子树 T-&gt;Weight = T-&gt;Left-&gt;Weight + T-&gt;Right-&gt;Weight; // 计算新结点的权值 Insert(H, T); // 将新结点插入最小优先队列 &#125; T = DeleteMin(H); // 最小优先队列中最后剩下的结点即为哈夫曼树的根结点 return T;&#125;// 时间复杂度: NlogN 哈夫曼树的特点： 没有度为一的结点 n个叶子结点的哈夫曼树共有2n-1个结点 哈夫曼树任意非叶节点的左右子树交换后仍是哈夫曼树 哈夫曼树和哈夫曼编码 ​ 不等长编码：出现频率高的字符用的编码短些，出现频率低的字符用的编码高些 ​ 如何进行不等长编码？ 编码可能出现二义性，根据二义性引出前缀码的概念：任何字符的编码都不是另一字符编码的前缀 可以无义地解码 二叉树用于编码：左右分支0，1字符只在叶结点上 用哈夫曼树可以实现二叉树编码代价最小 集合及运算集合可以用数组存储 查找某个元素的集合int Find(SetType S[],ElementType X){&#x2F;&#x2F;在数组中查找值为X的元素所属集合&#x2F;&#x2F;MaxSize是全局变量，为数组S的最大长度int i;for(int i &#x3D; 0; i &lt; MaxSize &amp;&amp; S[i].Data !&#x3D; X; i ++)if(i&gt;&#x3D;MaxSize)return -1;for(;S[i]-&gt;Parent&gt;&#x3D;0;i &#x3D; S[i].Parent);return i;}12345678910 集合的并运算分别找到X1和X2两个元素所在集合的根结点如果他们不同根，则将一个根结点的父结点指针设置为另一个根结点的数组下标void Union(SetType S[],ElementType X1,ElementType X2){int Root1,Root2;Root1 &#x3D; Find(S,X1);Root2 &#x3D; Find(S,X2);if(Root1!&#x3D;Root2)S[Root2].Parent&#x3D;Root1;}12345678为了改善合并以后的查找性能，可以采取小的集合合并到大的集合中，可以修改union函数，即将第一个结点的Parent修改为负的元素个数，对应其绝对值即为元素个数，方便比较","categories":[{"name":"计算机四大件","slug":"计算机四大件","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%9B%E5%A4%A7%E4%BB%B6/"},{"name":"数据结构与算法","slug":"计算机四大件/数据结构与算法","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"前端页面设计-6-退款表单设计","slug":"前端页面设计-6-退款表单设计","date":"2023-07-12T16:00:00.000Z","updated":"2023-08-06T11:12:02.788Z","comments":true,"path":"2023/07/13/前端页面设计-6-退款表单设计/","link":"https://blog.csdn.net/artly1/article/details/131608781?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2023/07/13/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1-6-%E9%80%80%E6%AC%BE%E8%A1%A8%E5%8D%95%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}],"author":"artly1"},{"title":"前端页面设计-5-基本页面设计","slug":"前端页面设计-5-基本页面设计","date":"2023-07-11T16:00:00.000Z","updated":"2023-08-06T11:12:07.847Z","comments":true,"path":"2023/07/12/前端页面设计-5-基本页面设计/","link":"https://blog.csdn.net/artly1/article/details/131608651?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2023/07/12/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1-5-%E5%9F%BA%E6%9C%AC%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}],"author":"artly1"},{"title":"前端页面设计-4-携程旅行页面设计","slug":"前端页面设计-4-携程旅行页面设计","date":"2023-07-10T16:00:00.000Z","updated":"2023-08-06T11:12:11.936Z","comments":true,"path":"2023/07/11/前端页面设计-4-携程旅行页面设计/","link":"https://blog.csdn.net/artly1/article/details/131312727?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2023/07/11/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1-4-%E6%90%BA%E7%A8%8B%E6%97%85%E8%A1%8C%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}],"author":"artly1"},{"title":"前端页面设计-3-页面案例设计","slug":"前端页面设计-3-页面案例设计","date":"2023-07-09T16:00:00.000Z","updated":"2023-08-06T11:12:15.975Z","comments":true,"path":"2023/07/10/前端页面设计-3-页面案例设计/","link":"https://blog.csdn.net/artly1/article/details/131328670?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2023/07/10/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1-3-%E9%A1%B5%E9%9D%A2%E6%A1%88%E4%BE%8B%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}],"author":"artly1"},{"title":"matlab建模基础知识","slug":"matlab建模基础知识","date":"2023-07-08T16:00:00.000Z","updated":"2023-08-06T09:49:58.995Z","comments":true,"path":"2023/07/09/matlab建模基础知识/","link":"https://blog.csdn.net/artly1/article/details/131621211?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2023/07/09/matlab%E5%BB%BA%E6%A8%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"","categories":[{"name":"matlab","slug":"matlab","permalink":"http://yoursite.com/categories/matlab/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"http://yoursite.com/tags/matlab/"}],"author":"artly1"},{"title":"matlab数学建模——画图","slug":"matlab数学建模——画图","date":"2023-07-08T16:00:00.000Z","updated":"2023-08-06T09:52:11.047Z","comments":true,"path":"2023/07/09/matlab数学建模——画图/","link":"https://blog.csdn.net/artly1/article/details/131622585?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2023/07/09/matlab%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E2%80%94%E2%80%94%E7%94%BB%E5%9B%BE/","excerpt":"","text":"","categories":[{"name":"matlab","slug":"matlab","permalink":"http://yoursite.com/categories/matlab/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"http://yoursite.com/tags/matlab/"}],"author":"artly1"},{"title":"matlab数学建模——插值与拟合","slug":"matlab数学建模——插值与拟合","date":"2023-07-08T16:00:00.000Z","updated":"2023-08-06T09:51:54.526Z","comments":true,"path":"2023/07/09/matlab数学建模——插值与拟合/","link":"https://blog.csdn.net/artly1/article/details/131623122?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2023/07/09/matlab%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E4%B8%8E%E6%8B%9F%E5%90%88/","excerpt":"","text":"","categories":[{"name":"matlab","slug":"matlab","permalink":"http://yoursite.com/categories/matlab/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"http://yoursite.com/tags/matlab/"}],"author":"artly1"},{"title":"matlab数学建模——求极限、求导、求积分","slug":"matlab数学建模——求极限、求导、求积分","date":"2023-07-08T16:00:00.000Z","updated":"2023-08-06T09:54:01.335Z","comments":true,"path":"2023/07/09/matlab数学建模——求极限、求导、求积分/","link":"https://blog.csdn.net/artly1/article/details/131621842?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2023/07/09/matlab%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E2%80%94%E2%80%94%E6%B1%82%E6%9E%81%E9%99%90%E3%80%81%E6%B1%82%E5%AF%BC%E3%80%81%E6%B1%82%E7%A7%AF%E5%88%86/","excerpt":"","text":"","categories":[{"name":"matlab","slug":"matlab","permalink":"http://yoursite.com/categories/matlab/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"http://yoursite.com/tags/matlab/"}],"author":"artly1"},{"title":"matlab数学建模——线性规划、0-1整数规划","slug":"matlab数学建模——线性规划、0-1整数规划","date":"2023-07-08T16:00:00.000Z","updated":"2023-08-06T09:54:23.053Z","comments":true,"path":"2023/07/09/matlab数学建模——线性规划、0-1整数规划/","link":"https://blog.csdn.net/artly1/article/details/131627018?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2023/07/09/matlab%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E3%80%810-1%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/","excerpt":"","text":"","categories":[{"name":"matlab","slug":"matlab","permalink":"http://yoursite.com/categories/matlab/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"http://yoursite.com/tags/matlab/"}],"author":"artly1"},{"title":"前端页面设计-2-照片墙","slug":"前端页面设计-2-照片墙","date":"2023-07-08T16:00:00.000Z","updated":"2023-08-06T11:12:19.434Z","comments":true,"path":"2023/07/09/前端页面设计-2-照片墙/","link":"https://blog.csdn.net/artly1/article/details/131296262?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2023/07/09/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1-2-%E7%85%A7%E7%89%87%E5%A2%99/","excerpt":"","text":"","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}],"author":"artly1"},{"title":"51单片机实验1-流水灯的设计（流水灯，蜂鸣器，爆闪灯）","slug":"51单片机实验1-流水灯的设计（流水灯，蜂鸣器，爆闪灯）","date":"2023-07-07T16:00:00.000Z","updated":"2023-08-06T09:30:54.931Z","comments":true,"path":"2023/07/08/51单片机实验1-流水灯的设计（流水灯，蜂鸣器，爆闪灯）/","link":"https://blog.csdn.net/artly1/article/details/131611655?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2023/07/08/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AE%9E%E9%AA%8C1-%E6%B5%81%E6%B0%B4%E7%81%AF%E7%9A%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E6%B5%81%E6%B0%B4%E7%81%AF%EF%BC%8C%E8%9C%82%E9%B8%A3%E5%99%A8%EF%BC%8C%E7%88%86%E9%97%AA%E7%81%AF%EF%BC%89/","excerpt":"","text":"","categories":[{"name":"51单片机","slug":"51单片机","permalink":"http://yoursite.com/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"51单片机","slug":"51单片机","permalink":"http://yoursite.com/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"author":"artly1"},{"title":"51单片机实验2-花样流水灯的设计（花样流水灯，倒车警示灯）","slug":"51单片机实验2-花样流水灯的设计（花样流水灯，倒车警示灯）","date":"2023-07-07T16:00:00.000Z","updated":"2023-08-06T09:30:49.849Z","comments":true,"path":"2023/07/08/51单片机实验2-花样流水灯的设计（花样流水灯，倒车警示灯）/","link":"https://blog.csdn.net/artly1/article/details/131612497?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2023/07/08/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AE%9E%E9%AA%8C2-%E8%8A%B1%E6%A0%B7%E6%B5%81%E6%B0%B4%E7%81%AF%E7%9A%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E8%8A%B1%E6%A0%B7%E6%B5%81%E6%B0%B4%E7%81%AF%EF%BC%8C%E5%80%92%E8%BD%A6%E8%AD%A6%E7%A4%BA%E7%81%AF%EF%BC%89/","excerpt":"","text":"","categories":[{"name":"51单片机","slug":"51单片机","permalink":"http://yoursite.com/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"51单片机","slug":"51单片机","permalink":"http://yoursite.com/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"author":"artly1"},{"title":"51单片机实验3-中断控制的LED灯（单一外部中断控制LED灯，两个外部中断控制LED灯，交通管制路口）","slug":"51单片机实验3-中断控制的LED灯（单一外部中断控制LED灯，两个外部中断控制LED灯，交通管制路口）","date":"2023-07-07T16:00:00.000Z","updated":"2023-08-06T09:30:22.266Z","comments":true,"path":"2023/07/08/51单片机实验3-中断控制的LED灯（单一外部中断控制LED灯，两个外部中断控制LED灯，交通管制路口）/","link":"https://blog.csdn.net/artly1/article/details/131613006?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2023/07/08/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AE%9E%E9%AA%8C3-%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E7%9A%84LED%E7%81%AF%EF%BC%88%E5%8D%95%E4%B8%80%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6LED%E7%81%AF%EF%BC%8C%E4%B8%A4%E4%B8%AA%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6LED%E7%81%AF%EF%BC%8C%E4%BA%A4%E9%80%9A%E7%AE%A1%E5%88%B6%E8%B7%AF%E5%8F%A3%EF%BC%89/","excerpt":"","text":"","categories":[{"name":"51单片机","slug":"51单片机","permalink":"http://yoursite.com/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"51单片机","slug":"51单片机","permalink":"http://yoursite.com/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"author":"artly1"},{"title":"51单片机实验4-计时器设计（LED灯实现二进制计数,简易计数报警,呼吸灯）","slug":"51单片机实验4-计时器设计（LED灯实现二进制计数-简易计数报警-呼吸灯）","date":"2023-07-07T16:00:00.000Z","updated":"2023-08-06T09:30:18.755Z","comments":true,"path":"2023/07/08/51单片机实验4-计时器设计（LED灯实现二进制计数-简易计数报警-呼吸灯）/","link":"https://blog.csdn.net/artly1/article/details/131613533?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2023/07/08/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AE%9E%E9%AA%8C4-%E8%AE%A1%E6%97%B6%E5%99%A8%E8%AE%BE%E8%AE%A1%EF%BC%88LED%E7%81%AF%E5%AE%9E%E7%8E%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%AE%A1%E6%95%B0-%E7%AE%80%E6%98%93%E8%AE%A1%E6%95%B0%E6%8A%A5%E8%AD%A6-%E5%91%BC%E5%90%B8%E7%81%AF%EF%BC%89/","excerpt":"","text":"","categories":[{"name":"51单片机","slug":"51单片机","permalink":"http://yoursite.com/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"51单片机","slug":"51单片机","permalink":"http://yoursite.com/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"author":"artly1"},{"title":"51单片机实验5-矩阵按键的应用","slug":"51单片机实验5-矩阵按键的应用","date":"2023-07-07T16:00:00.000Z","updated":"2023-08-06T09:34:10.107Z","comments":true,"path":"2023/07/08/51单片机实验5-矩阵按键的应用/","link":"https://blog.csdn.net/artly1/article/details/131613860?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2023/07/08/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AE%9E%E9%AA%8C5-%E7%9F%A9%E9%98%B5%E6%8C%89%E9%94%AE%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"","text":"","categories":[{"name":"51单片机","slug":"51单片机","permalink":"http://yoursite.com/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"51单片机","slug":"51单片机","permalink":"http://yoursite.com/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"author":"artly1"},{"title":"51单片机实验6-LED点阵的应用","slug":"51单片机实验6-LED点阵的应用","date":"2023-07-07T16:00:00.000Z","updated":"2023-08-06T09:34:32.634Z","comments":true,"path":"2023/07/08/51单片机实验6-LED点阵的应用/","link":"https://blog.csdn.net/artly1/article/details/131613998?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2023/07/08/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AE%9E%E9%AA%8C6-LED%E7%82%B9%E9%98%B5%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"","text":"","categories":[{"name":"51单片机","slug":"51单片机","permalink":"http://yoursite.com/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"51单片机","slug":"51单片机","permalink":"http://yoursite.com/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"author":"artly1"},{"title":"前端页面设计-1-基础知识","slug":"前端页面设计-1-基础知识","date":"2023-07-07T16:00:00.000Z","updated":"2023-08-06T11:12:22.712Z","comments":true,"path":"2023/07/08/前端页面设计-1-基础知识/","link":"https://blog.csdn.net/artly1/article/details/131286567?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2023/07/08/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1-1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}],"author":"artly1"},{"title":"计算机网络复习","slug":"计算机网络复习-1","date":"2022-12-20T16:00:00.000Z","updated":"2023-08-06T10:05:20.689Z","comments":true,"path":"2022/12/21/计算机网络复习-1/","link":"https://blog.csdn.net/artly1/article/details/128161905?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2022/12/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0-1/","excerpt":"","text":"","categories":[{"name":"计算机四大件","slug":"计算机四大件","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%9B%E5%A4%A7%E4%BB%B6/"},{"name":"计算机网络","slug":"计算机四大件/计算机网络","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"author":"artly1"},{"title":"mysql常用命令","slug":"mysql常用命令","date":"2022-12-17T16:00:00.000Z","updated":"2023-07-22T12:22:58.450Z","comments":true,"path":"2022/12/18/mysql常用命令/","link":"https://blog.csdn.net/artly1/article/details/128360916","permalink":"http://yoursite.com/2022/12/18/mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"","categories":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}],"author":"artly1"},{"title":"NVIDIA Sky Hackathon 训练模型安装","slug":"NVIDIA-Sky-Hackathon-训练模型安装","date":"2022-11-29T16:00:00.000Z","updated":"2023-08-06T10:14:35.819Z","comments":true,"path":"2022/11/30/NVIDIA-Sky-Hackathon-训练模型安装/","link":"https://blog.csdn.net/artly1/article/details/128095964?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2022/11/30/NVIDIA-Sky-Hackathon-%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E5%AE%89%E8%A3%85/","excerpt":"","text":"","categories":[{"name":"Hackathon","slug":"Hackathon","permalink":"http://yoursite.com/categories/Hackathon/"}],"tags":[{"name":"Hackathon","slug":"Hackathon","permalink":"http://yoursite.com/tags/Hackathon/"}],"author":"artly1"}],"categories":[{"name":"项目实战","slug":"项目实战","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"},{"name":"学生管理系统","slug":"项目实战/学生管理系统","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"计算机四大件","slug":"计算机四大件","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%9B%E5%A4%A7%E4%BB%B6/"},{"name":"数据结构与算法","slug":"计算机四大件/数据结构与算法","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"matlab","slug":"matlab","permalink":"http://yoursite.com/categories/matlab/"},{"name":"51单片机","slug":"51单片机","permalink":"http://yoursite.com/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"计算机网络","slug":"计算机四大件/计算机网络","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/categories/mysql/"},{"name":"Hackathon","slug":"Hackathon","permalink":"http://yoursite.com/categories/Hackathon/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"},{"name":"matlab","slug":"matlab","permalink":"http://yoursite.com/tags/matlab/"},{"name":"51单片机","slug":"51单片机","permalink":"http://yoursite.com/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Hackathon","slug":"Hackathon","permalink":"http://yoursite.com/tags/Hackathon/"}]}