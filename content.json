{"meta":{"title":"artly的小窝","subtitle":"","description":"test description","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2023-07-18T01:36:16.268Z","updated":"2023-07-18T01:36:16.268Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"哈喽😄，进来的朋友~首先感谢您来到我博客，再是您访问了这个页面来了解。 鄙人杨世豪，现就读于天津中德应用技术大学21级物联网工程专业。 中文常用昵称“夏漱石”，因为高中期间喜欢比较喜欢夏目漱石老师，再加上喜欢动漫，爱看fate，对历史人物人很有感触，就给自己取了这么一个名字，但后来这个名字容易撞车，就用自己另一个喜欢的动漫角色取了“artly1”这个名字。本人并不优秀，就是普普通通的一名学生，对于自己的未来依旧很迷茫，但怎么说呢，一步一步走走看吧。 目前这个博客主要用来总结自己系统学习的相关内容，内容也没有多深奥，主要是总结方便自己之后回忆。所以有巨佬请勿喷😵——以上。 Ps：如果想要交换友链的话，那就在下边留下你的信息。"},{"title":"所有分类","date":"2023-06-27T02:52:53.596Z","updated":"2023-06-27T02:52:53.596Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2023-06-27T02:42:54.000Z","updated":"2023-06-27T02:42:54.377Z","comments":true,"path":"archives/index.html","permalink":"http://yoursite.com/archives/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2023-06-27T02:57:53.373Z","updated":"2023-06-27T02:57:53.373Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":""},{"title":"Page","date":"2013-12-26T14:52:56.000Z","updated":"2023-03-31T12:13:05.237Z","comments":true,"path":"page/index.html","permalink":"http://yoursite.com/page/index.html","excerpt":"","text":"This is a page test."},{"title":"所有标签","date":"2023-06-27T02:52:01.217Z","updated":"2023-06-27T02:52:01.217Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"java基本语法框架指南","slug":"java基本语法框架指南","date":"2023-08-25T14:49:48.000Z","updated":"2023-08-25T15:41:22.062Z","comments":true,"path":"2023/08/25/java基本语法框架指南/","link":"","permalink":"http://yoursite.com/2023/08/25/java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E6%A1%86%E6%9E%B6%E6%8C%87%E5%8D%97/","excerpt":"","text":"声明变量和赋值123456789// 声明变量int age;// 初始化变量age = 25;// 声明并初始化变量double price = 19.99; 类的定义和创建对象123456789101112131415// 定义类class car &#123; String name; int age; void introduce() &#123; System.out.println(&quot;我是&quot; + name + &quot;车，今年车龄：&quot; + age + &quot;岁。&quot;); &#125;&#125;// 创建对象car c = new car();c.name = &quot;Bumblebee&quot;;c.age = 20;c.introduce(); 循环for已知道迭代次数，或者知道迭代条件时，for更加直观 123for (初始化; 条件; 更新) &#123; // 循环体代码&#125; while循环次数不确定，需要根据条件是否成立的，使用while 12345678910while (条件) &#123; // while循环体代码&#125;do &#123; // do while循环体代码&#125; while (条件); 选择if从简单条件到复杂条件，if都可以 12345678910111213141516171819202122232425if (条件) &#123; // 如果条件为真，执行这里的代码&#125;if (条件) &#123; // 如果条件为真，执行这里的代码&#125; else &#123; // 如果条件为假，执行这里的代码&#125;if (条件1) &#123; // 如果条件1为真，执行这里的代码&#125; else if (条件2) &#123; // 如果条件2为真，执行这里的代码&#125; else &#123; // 如果前面条件都为假，执行这里的代码&#125; switch需要特定的值成立时，switch语句更加简洁易读 12345678910switch (表达式) &#123; case 值1: // 如果表达式的值与值1匹配，执行这里的代码 break; case 值2: // 如果表达式的值与值2匹配，执行这里的代码 break; default: // 如果没有匹配的值，执行这里的代码&#125; 方法的定义和调用12345678// 定义方法public int add(int a, int b) &#123; return a + b;&#125;// 调用方法int sum = add(5, 3); 数据结构数组1int[] numbers = &#123;1, 2, 3, 4, 5&#125;; 集合1234Set&lt;String&gt; names = new HashSet&lt;&gt;();names.add(&quot;Alice&quot;);names.add(&quot;Bob&quot;);System.out.println(names); 列表1234List&lt;Integer&gt; scores = new ArrayList&lt;&gt;();scores.add(85);scores.add(90);System.out.println(scores); 映射1234Map&lt;String, Integer&gt; ages = new HashMap&lt;&gt;();ages.put(&quot;Alice&quot;, 25);ages.put(&quot;Bob&quot;, 30);System.out.println(ages); 栈1234Stack&lt;String&gt; stack = new Stack&lt;&gt;();stack.push(&quot;First&quot;);stack.push(&quot;Second&quot;);System.out.println(stack); 对列1234Queue&lt;Double&gt; queue = new LinkedList&lt;&gt;();queue.offer(3.14);queue.offer(2.71);System.out.println(queue); 树12345678910111213class TreeNode &#123; int value; TreeNode left; TreeNode right; TreeNode(int value) &#123; this.value = value; &#125;&#125;TreeNode root = new TreeNode(10);root.left = new TreeNode(5);root.right = new TreeNode(15);System.out.println(root.value); 链表1234567891011121314class ListNode &#123; int value; ListNode next; ListNode(int value) &#123; this.value = value; &#125;&#125;ListNode head = new ListNode(1);head.next = new ListNode(2);head.next.next = new ListNode(3);System.out.println(head.value); 异常处理异常处理是在编程中用于处理可能发生的错误情况的一种机制。 1234567891011121314try &#123; int result = 10 / 0;&#125; catch (ArithmeticException e) &#123; System.out.println(&quot;发生除以零的异常：&quot; + e.getMessage()); catch (ArithmeticException e) &#123; // 处理算术异常&#125; catch (NullPointerException e) &#123; // 处理空指针异常&#125; catch (Exception e) &#123; // 处理其他异常&#125; finally &#123; System.out.println(&quot;无论是否发生异常，这里都会执行。&quot;);&#125; 继承和多态多态：多态性的实际效果是，你可以使用父类的引用变量来引用子类的对象，然后根据实际对象的类型调用相应的方法。 @Override :是Java中的一个注解（Annotation），用于标识一个方法是在子类中对父类中的方法进行重写（覆盖）。当你在子类中重写父类的方法时，为了确保你的重写是正确的，你可以使用 @Override 注解。 123456789101112131415161718192021// 父类定义class Animal &#123; void makeSound() &#123; System.out.println(&quot;Animal makes a sound&quot;); &#125;&#125;// 子类定义，继承父类class Dog extends Animal &#123; @Override void makeSound() &#123; System.out.println(&quot;Dog barks&quot;); &#125;&#125;// 多态示例Animal animal1 = new Animal();Animal animal2 = new Dog();animal1.makeSound(); // 输出：Animal makes a soundanimal2.makeSound(); // 输出：Dog barks 接口与实现1234567891011121314151617181920212223// 接口定义interface Shape &#123; double getArea();//得面积&#125;// 类实现接口class Circle implements Shape &#123; double radius;//得半径 Circle(double r) &#123; radius = r; &#125; @Override public double getArea() &#123; return Math.PI * radius * radius; &#125;&#125;// 实例化并调用接口方法Shape shape = new Circle(5);double area = shape.getArea();System.out.println(&quot;Circle area: &quot; + area); // 输出：Circle area: 78.53981633974483 在这个示例中，我们首先定义了一个名为 Shape 的接口，其中有一个 getArea 方法，用于获取图形的面积。然后，我们创建了一个实现了 Shape 接口的类 Circle，该类表示一个圆，它有一个属性 radius 表示半径。 在 Circle 类中，我们实现了 getArea 方法，根据圆的半径计算并返回面积。这是我们遵循接口要求的方式来为每种形状提供计算面积的方法。 在主程序中，我们使用多态性的概念。我们声明了一个 Shape 类型的引用变量 shape，并将其初始化为一个 Circle 对象。由于 Circle 实现了 Shape 接口，我们可以使用 Shape 引用变量来引用 Circle 对象。 然后，我们调用 shape.getArea() 方法，实际上是调用了 Circle 类中的 getArea 方法。这是因为 shape 引用的对象是 Circle 类的一个实例。最后，我们将计算得到的面积输出。 通过这个示例，你可以看到多态性的好处：无论是 Circle、Square 还是其他实现了 Shape 接口的类，只要它们实现了相同的方法，我们就可以使用相同的接口引用来调用这些方法，使得代码更加灵活和可扩展。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"信息管理系统项目","slug":"信息管理系统项目","date":"2023-08-25T03:11:26.000Z","updated":"2023-08-25T03:32:57.034Z","comments":true,"path":"2023/08/25/信息管理系统项目/","link":"","permalink":"http://yoursite.com/2023/08/25/%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"项目概述本项目是在前者（学生管理系统）的基础上，进一步的学习，有些原理一样，当然肯定有升级的。帮助我更加深刻理解前后端分离项目的思想，具备独立搭建前后端分离项目的能力及功能扩展能力等等。 项目展示开发模式 项目展示 开发展示 技术栈 前端技术 说明 Vue 前端框架 Vuex 全局状态管理框架 ElementUI 前端UI框架 Axios 前端HTTP框架 vue-element-admin 项目脚手架 后端技术 说明 SpringBoot 容器+MVC框架 MyBatis ORM框架 MyBatis-plus MyBatis增强工具 Redis 非关系型数据库","categories":[{"name":"项目实战","slug":"项目实战","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"},{"name":"信息管理系统","slug":"项目实战/信息管理系统","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"数学建模-算法总结","slug":"数学建模-算法总结","date":"2023-08-15T10:47:41.000Z","updated":"2023-08-25T13:43:02.768Z","comments":true,"path":"2023/08/15/数学建模-算法总结/","link":"","permalink":"http://yoursite.com/2023/08/15/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1-%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/","excerpt":"","text":"线性规划在数学建模算法中，线性规划（Linear Programming，简称LP） 是一种用于求解优化问题的数学方法。它通过寻找一个线性目标函数在一组线性约束条件下的最优解来解决问题。 定义：线性规划是一种优化问题，其数学定义如下： 最大化（或最小化）目标函数：$$c^T x$$在约束条件下：$$Ax \\leq b$$，$$x \\geq 0$$其中，$$c$$和$$x$$是列向量，$$A$$为矩阵，$$b$$为列向量，$$x$$是待求解的变量向量。 条件： 线性目标函数： 目标函数和约束条件都是线性的，即变量$$x$$的各个分量与系数矩阵$$A$$、$$b$$、$$c$$之间是线性的关系。 非负约束： 变量$$x$$的各个分量必须大于等于零，即$$x \\geq 0$$。 线性约束条件： 约束条件$$Ax \\leq b$$表示一组线性不等式约束。 优缺点： 优点： 数学理论成熟： 线性规划有严格的数学基础和理论支持，其解法相对较成熟，可以应用于实际问题。 高效性： 对于一般规模的问题，线性规划可以在合理的时间内求解。 确定性： 线性规划问题具有确定性，可以提供精确的最优解。 广泛应用： 线性规划在供应链优化、生产计划、资源分配、投资组合等领域有广泛应用。 缺点： 线性约束限制： 由于约束条件必须是线性的，某些问题可能无法准确地用线性规划模型表示。 局限性： 线性规划只适用于解决线性问题，无法处理非线性问题。 局部最优解： 在一些情况下，线性规划可能找到的是局部最优解，而不是全局最优解。 大规模问题困难： 对于大规模问题，线性规划的计算复杂度可能会变得很高，求解速度较慢。 适用范围：线性规划适用于需要在一组线性约束条件下寻找最优解的问题，例如： 生产计划问题： 在资源有限的情况下，如何安排生产以最大化产出。 投资组合问题： 如何在多个投资选项中分配资金，以最大化投资组合的预期收益。 运输问题： 如何在不同供应地和需求地之间进行货物运输，以最小化运输成本。 线性回归： 通过拟合线性模型来预测或分析数据。 需要注意的是，如果问题具有非线性约束或目标函数，或者需要考虑整数变量，那么可能需要使用其他优化方法，如非线性规划或整数规划。 整数规划整数规划（Integer Programming，简称IP）是数学规划的一种形式，它在优化问题中寻求一个使特定目标函数最优化的变量组合，同时要求这些变量取整数值。整数规划在实际问题中有广泛的应用，涉及诸如资源分配、排程、网络设计等领域。 定义：整数规划是一种优化问题，其数学定义如下： 最大化（或最小化）目标函数：$$c^T x$$在约束条件下：$$Ax \\leq b$$，$$x$$为整数向量，其中$$c$$、$$x$$为列向量，$$A$$为矩阵，$$b$$为列向量。 条件： 整数变量要求： 整数规划与线性规划的主要区别在于变量$$x$$的取值必须是整数。 线性约束条件： 约束条件$$Ax \\leq b$$是线性的，即变量$$x$$的系数与常数矩阵$$A$$和$$b$$之间是线性的关系。 优缺点： 优点： 适用性广泛： 整数规划适用于很多实际问题，尤其是那些需要整数解的问题，如排班、货物运输等。 精确性： 整数规划能够提供精确的整数解，对于需要确切整数值的问题非常有用。 缺点： NP难度： 整数规划问题通常是NP难问题，意味着随着问题规模增大，求解所需的时间呈指数级增长，不适用于大规模问题。 求解复杂度： 通常比线性规划更难求解，特别是当问题规模变大或约束条件复杂时，求解速度可能会显著下降。 可行性难以确定： 判断是否存在可行整数解本身就是一个困难问题。 适用范围：整数规划适用于需要找到整数解的优化问题，例如： 排班问题： 考虑员工排班，需要确定每个员工的工作时间。 生产调度问题： 在生产中，需要安排机器的使用时间，以最大程度地提高生产效率。 网络设计问题： 在网络设计中，需要确定通信节点的位置以及连接方式。 旅行商问题： 给定多个城市和城市之间的距离，找到最短的路径，使得旅行商能够访问每个城市并回到起始城市。 需要注意的是，当问题的整数约束不是严格必要时，有时候可以使用整数线性规划（Mixed Integer Linear Programming，简称MILP）来解决，其中一部分变量需要取整数值，而其他变量可以取实数值。 分支定界算法 P9 14:00在数学建模算法中，分支定界算法（Branch and Bound Algorithm） 是一种用于求解离散优化问题的方法。它通过将问题分解成子问题，并利用上界和下界的性质来搜索可能的解空间，从而逐步缩小搜索范围，最终找到最优解。 定义：分支定界算法是一种求解优化问题的分治方法，通过逐步将问题分解成更小的子问题，并通过界限的计算来排除无效的解，从而找到问题的最优解。 条件：分支定界算法通常适用于离散优化问题，特别是在以下情况下使用： 问题的解空间较大且难以直接求解。 问题的目标函数满足某种单调性或有界性质。 优点： 全局最优解： 分支定界算法能够保证找到问题的全局最优解，而不是局部最优解。 适用广泛： 适用于各种离散优化问题，如整数规划、组合优化等。 灵活性： 可以根据问题的特点和性质进行定制化的实现。 缺点： 计算复杂度： 对于某些问题，分支定界算法的计算复杂度可能较高，尤其在解空间较大时。 搜索空间膨胀： 在某些情况下，搜索空间可能会膨胀得很快，导致算法效率下降。 依赖问题性质： 算法的效果可能会受到问题的性质和界限计算的影响。 适用范围：分支定界算法适用于需要在离散优化问题中寻找最优解的情况，例如： 整数规划问题： 在线性规划的基础上，考虑变量取整数值的情况。 旅行商问题： 在给定城市之间寻找最短路径的问题。 背包问题： 在限定背包容量的情况下选择物品以最大化价值。 图着色问题： 给定图的节点，寻找最小的节点着色数目。 分支定界算法通过逐步划分解空间，结合界限计算，能够在一定程度上克服搜索空间膨胀的问题，从而有效地求解离散优化问题。 割平面算法 P10在数学建模算法中，割平面算法（Cutting Plane Algorithm） 是一种用于求解优化问题的方法，主要用于解决整数规划等离散优化问题。它通过逐步添加一系列线性不等式（割平面）来逼近最优解，从而逐渐缩小解空间，最终找到最优解。 定义：割平面算法是一种求解优化问题的方法，它通过在每一次迭代中添加一些线性不等式，以逐步缩小解空间并接近最优解。这些线性不等式通常是根据当前解的信息来生成的，可以将问题的解空间分割成更小的子集。 条件：割平面算法通常适用于离散优化问题，特别是在以下情况下使用： 问题的目标函数是线性的，且需要在整数解空间中寻找最优解。 可以通过求解线性规划松弛问题来获得初步解。 优点： 适用广泛： 割平面算法适用于各种离散优化问题，特别是整数规划问题。 精确性提升： 通过逐步添加割平面，可以逐渐逼近最优整数解，从而提高解的精确性。 缺点： 计算复杂度： 割平面算法的计算复杂度可能随着迭代次数的增加而增加，特别是在问题的解空间复杂或约束较多时。 割平面生成： 生成有效的割平面可能需要一定的技巧和领域知识，不同问题可能需要不同的割平面生成策略。 适用范围：割平面算法适用于需要在整数解空间中寻找最优解的离散优化问题，例如： 整数规划问题： 在线性规划的基础上，要求解取整数值的情况。 组合优化问题： 如图论中的最大割问题、旅行商问题等。 如何使用：使用割平面算法通常需要以下步骤： 初始化： 初始解可以通过线性规划松弛问题获得。 迭代： 在每次迭代中，生成一个新的割平面并添加到问题中。 求解： 在添加了新的割平面后，求解更新后的整数规划问题。 判断终止： 根据问题的终止条件判断是否继续迭代。 输出结果： 得到满足约束条件的最优整数解。 以上是一个简要的割平面算法的介绍，实际使用中需要根据具体问题进行调整和实现。 匈牙利算法 P11 27：00 38：22在数学建模算法中，匈牙利算法（Hungarian Algorithm） 是一种用于解决分配问题的优化算法，特别适用于二分图最优匹配问题。它通过逐步分配任务并找到最优匹配，从而求解优化问题。 定义：匈牙利算法是一种用于解决分配问题的方法，它可以找到一个最优匹配，使得给定一组任务和一组资源的情况下，任务与资源之间的匹配达到最优。 条件：匈牙利算法主要适用于以下情况： 问题可以建模为二分图，即任务和资源可以被分为两组，每一组内部的元素之间没有关联。 每个任务可以分配给一个资源，每个资源也只能分配给一个任务。 问题的目标是使分配的权重总和最小或最大化某种指标。 优点： 高效性： 匈牙利算法在解决二分图匹配问题时具有较高的效率，时间复杂度为O(n^3)，其中n是任务或资源的数量。 确定性： 算法能够得出确定性的结果，找到一个最优的任务-资源匹配方案。 缺点： 适用范围受限： 匈牙利算法主要用于解决分配问题，不适用于所有优化问题。 局限性： 在某些情况下，可能需要进行问题转换或预处理，以便满足匈牙利算法的条件。 不适用于连续问题： 匈牙利算法适用于离散问题，不适用于连续问题。 适用范围：匈牙利算法适用于需要将一组任务与一组资源进行最优匹配的问题，例如： 任务分配问题： 在人员分配、作业调度等场景中，将任务分配给不同的执行者，以最小化总体成本或最大化效率。0-1整数规划 工作调度问题： 将一组作业分配给一组处理机，以最小化总体时间或最大化系统利用率。 如何使用：使用匈牙利算法通常需要以下步骤： 构建二分图： 将问题建模为二分图，将任务和资源分别表示为两组节点，并添加连接它们的边，边上的权重表示分配的成本或效益。 初始化： 初始化算法的数据结构，如匹配状态数组等。 执行增广路径搜索： 通过搜索增广路径来尝试找到可行匹配或改进现有匹配。 更新匹配状态： 根据找到的增广路径，更新任务和资源的匹配状态。 迭代： 重复执行步骤 3 和步骤 4，直到无法找到更多增广路径为止。 输出结果： 根据匹配状态，得出最优匹配结果。 以上是匈牙利算法的简要介绍，实际使用时需要根据具体问题进行调整和实现。 层次分析算法 P15 在数学建模算法中，层次分析算法（Analytic Hierarchy Process，AHP） 是一种用于多准则决策的方法，通过建立层次结构和权重比较来辅助决策者做出合理的决策。 定义：层次分析算法是一种用于多准则决策的方法，它将复杂的决策问题分解为多个层次的子问题，并通过对不同层次元素之间的权重比较，得出最终的决策结果。 条件：层次分析算法适用于以下情况： 问题涉及多个准则或因素，需要综合考虑不同准则的重要性。 决策问题可以分解为多个层次，从总体目标到具体细节。 优点： 结构化分析： 层次分析算法能够将复杂的决策问题结构化为层次关系，便于分析和理解。 权重比较： 算法允许决策者对不同准则的相对重要性进行比较，从而更好地反映实际需求。 系统化决策： 通过定量化权重和分析不同层次元素之间的关系，能够帮助决策者做出更系统化的决策。 缺点： 主观性： 权重比较的结果可能受到决策者主观意见的影响，导致结果的偏差。 复杂性： 当层次结构较复杂时，进行权重比较和计算可能变得繁琐。 敏感性： 较小的权重变化可能会导致最终结果的显著改变，使结果对权重比较的敏感性较高。 适用范围：层次分析算法适用于需要在多个准则之间做出决策的问题，例如： 项目选择问题： 在多个项目中选择最佳项目，需要考虑多个准则，如成本、收益、风险等。 供应商评估问题： 选择最合适的供应商，需要考虑价格、质量、交货时间等准则。 投资决策问题： 在不同投资选项之间做出决策，需要综合考虑收益、风险、时间等因素。 如何使用：使用层次分析算法通常需要以下步骤： 建立层次结构： 将问题分解为多个层次的元素，从总体目标到具体准则或因素。 制定比较矩阵： 对不同层次元素之间的重要性进行两两比较，得出权重比较矩阵。 计算权重： 根据比较矩阵，计算每个层次元素的权重。 一致性检验： 检查比较矩阵的一致性，确保决策者的比较一致性。 计算最终得分： 将各层次元素的权重与对应的得分相乘，得出最终的综合得分。 做出决策： 根据最终得分，进行决策。 TOPSIS算法 P18 在数学建模算法中，TOPSIS算法（Technique for Order Preference by Similarity to Ideal Solution） 是一种用于多属性决策分析的方法，用于评估备选方案相对于理想方案的优劣程度。它基于将备选方案与理想解和负理想解进行比较，以确定最优方案。 定义：TOPSIS算法是一种用于多属性决策的方法，它通过计算备选方案与理想解和负理想解之间的距离来评估备选方案的综合性能，从而确定最优方案。 条件：TOPSIS算法适用于以下情况： 需要从多个备选方案中选择一个最优方案。 各备选方案在多个属性上有不同的性能指标。 属性是数值型数据。 优点： 综合性能评估： TOPSIS能够将多个属性的信息综合起来评估备选方案的优劣。 易于理解： 算法结果易于理解和解释，通过计算得出的综合得分有明确的含义。 灵活性： 可根据问题的需要调整权重以反映属性的重要性。 缺点： 属性权重确定： 权重的确定可能影响最终结果，但常常需要主观判断或专家意见。 不适用于非数值数据： TOPSIS算法仅适用于数值型数据，对于含有非数值属性的问题需要进行预处理。 敏感性： 对于极端值和噪声数据敏感，可能导致不稳定的结果。 适用范围：TOPSIS算法适用于需要从多个备选方案中选择最优方案的决策问题，例如： 投资决策： 评估不同投资项目的综合表现以选择最具有潜力的项目。 供应商选择： 从多个供应商中选择合适的供应商，考虑多个评价指标。 学校评估： 对不同学校在教育质量、设施等方面进行评估，选出最优学校。 如何使用：使用TOPSIS算法通常需要以下步骤： 确定属性和权重： 确定评价备选方案的属性以及每个属性的权重。 标准化数据： 将各属性的数据标准化，确保它们在相同的尺度上进行比较。 构建决策矩阵： 将标准化后的数据构建成决策矩阵。 确定理想解和负理想解： 根据目标是最大化还是最小化，分别确定理想解和负理想解。 计算距离： 计算各备选方案与理想解、负理想解之间的距离。 计算综合得分： 根据距离计算综合得分，选择得分最高的方案为最优方案。 聚类分析灰色系统理论定义：灰色系统理论是一种用于处理缺乏完整信息的方法，通过分析和建模不完全数据来预测和分析系统的行为。它基于灰色关联度和灰色预测等概念，旨在解决信息不足问题下的决策和预测。 条件：灰色系统理论适用于以下情况： 数据有限：当数据量有限，难以建立准确的数学模型时。 信息不充分：当无法获取足够的完整信息，但需要进行预测和分析时。 优点： 数据不足： 灰色系统理论可以在数据有限的情况下进行分析和预测，不要求大量数据。 简单有效： 方法相对简单，不依赖于严格的数学模型，适用于一些实际问题的处理。 解释性： 灰色系统模型可以对问题的演化趋势进行解释，有助于决策者理解问题。 缺点： 数据质量： 方法对数据质量要求较高，低质量数据可能导致预测不准确。 适用范围： 灰色系统理论不适用于所有类型的问题，仅适用于特定情况。 误差累积： 随着预测步数的增加，预测误差可能会逐渐累积。 适用范围：灰色系统理论适用于处理信息不完整、数据有限的问题，例如： 市场预测： 对市场变化趋势进行预测，分析未来趋势。 经济预测： 预测经济指标的变化，如GDP增长、通货膨胀率等。 环境分析： 分析环境变化趋势，如气象、水质等。 使用方法： 数据准备： 收集相关数据，并进行预处理，包括去噪、处理缺失值等。 模型选择： 根据问题特点选择适合的灰色预测模型，如GM(1,1)模型。 参数估计： 根据已有数据，估计模型的参数，如初始值、灰色关联度等。 模型训练： 使用已有数据训练模型，得到模型的参数。 预测分析： 利用训练好的模型进行未来数据的预测，分析预测结果。 模型评估： 使用部分数据进行模型验证，评估模型的预测准确性。 需要注意的是，虽然灰色系统理论具有一定的优点，但在应用中需要根据问题的性质和数据的特点进行判断，选择是否适用于问题的解决。 灰色关联度 p20 43：00在数学建模算法中，灰色关联度 是灰色系统理论中的一个重要概念，用于比较不同数据序列之间的相似性和相关性。它是一种处理缺乏完整信息的方法，旨在解决在数据不充分的情况下进行数据分析和预测的问题。 定义：灰色关联度是衡量不同数据序列之间相似性和关联程度的指标。它通过比较数据序列的变化趋势，计算出不同序列之间的关联度，从而判断它们之间的相似程度。灰色关联度分析可以帮助找到不同序列之间的相对重要性，为数据分析和决策提供依据。 条件：灰色关联度适用于以下情况： 数据不充分：当数据量有限，难以建立精确数学模型时。 多序列比较：需要对多个数据序列进行相似性和相关性的比较。 优点： 不受量纲影响： 灰色关联度比较不受数据序列的量纲影响，适用于不同尺度的数据。 简单有效： 方法相对简单，不要求严格的数学模型，适用于多序列比较分析。 缺点： 数据质量： 方法对数据质量要求较高，低质量数据可能导致关联度计算不准确。 主观性： 灰色关联度的计算可能涉及参数选择，可能带有一定主观性。 适用范围：灰色关联度适用于多个数据序列之间的比较和分析，例如： 多指标比较： 对多个指标序列的变化趋势进行分析，找出变化趋势相似的指标。 序列排序： 对不同序列进行排序，找出最相关的序列。 多维数据分析： 对多维数据序列进行相似性分析，发现相关性较高的维度。 使用方法： 数据准备： 收集需要比较的数据序列，并进行预处理，去除异常值等。 计算关联度： 使用灰色关联度计算方法，比较不同数据序列之间的关联度。 关联度排序： 根据计算结果，对数据序列进行排序，找出相关性较高的序列。 分析应用： 根据关联度分析结果，进行相应的数据分析和决策。 插值算法需要注意的是，灰色关联度分析在实际应用中需要根据问题的性质和数据的特点进行合理的参数选择和解释，以确保分析结果的准确性和可靠性。 在数学建模算法中，插值算法 是一种用于估计在有限数据点之间未知位置上的数值的方法。它通过已知数据点之间的信息来估计未知位置上的数值，从而实现数据的平滑和补全。 一维插值算法：定义：一维插值算法用于估计在一维数据点之间未知位置上的数值。常见的一维插值方法包括线性插值、多项式插值（如拉格朗日插值、牛顿插值）、样条插值等。 条件： 已知数据点：必须已知一些数据点的数值，以及它们对应的位置。 连续性：插值数据点通常要求在一定范围内连续分布。 优缺点：优点： 简单有效：一维插值方法通常计算简单，能够在有限数据点之间实现平滑和补全。 适用范围：适用于对一维数据进行平滑、估计和预测。 缺点： 振荡问题：多项式插值在高次插值时可能出现振荡现象，导致不稳定的估计结果。 数据限制：插值算法要求已知数据点，如果数据点稀疏或不准确，插值结果可能不准确。 适用范围：一维插值算法适用于需要在一维数据点之间进行平滑、估计和预测的问题，如曲线拟合、数据补全等。 使用方法： 数据准备： 收集已知数据点及其数值，确保数据的连续性。 选择插值方法： 根据问题的性质和数据分布，选择适合的一维插值方法。 计算插值： 使用选定的插值方法，对未知位置上的数值进行估计。 分析结果： 分析插值结果的准确性和稳定性，根据需要进行后续处理。 二维插值算法：定义：二维插值算法用于估计在二维数据点之间未知位置上的数值。常见的二维插值方法包括双线性插值、双三次插值、径向基函数插值等。 条件： 已知数据点：必须已知一些二维数据点的数值，以及它们对应的位置。 连续性：插值数据点通常要求在二维平面内连续分布。 优缺点：优点： 精度较高：二维插值方法能够实现较高精度的估计，尤其是在数据稀疏区域。 变化平滑：一些方法能够平滑地插值数据，减少估计值之间的跳跃。 缺点： 计算复杂度：部分二维插值方法计算较复杂，可能需要较多计算资源。 数据限制：插值算法要求已知数据点，如果数据点稀疏或不准确，插值结果可能不准确。 适用范围：二维插值算法适用于需要在二维数据点之间进行平滑、估计和预测的问题，如图像处理、地理信息 回归分析算法：定义：回归分析是一种用于建立变量之间关系的统计方法。它通过已知的自变量（独立变量）和因变量（依赖变量）的数据，建立一个数学模型，用于描述自变量如何影响因变量的变化趋势。回归分析可用于预测因变量的值、探索变量间的关联性以及解释影响因素。 条件： 数据收集：必须收集一组包含自变量和因变量数据的样本数据。 变量关系：假设自变量和因变量之间存在一定的函数关系。 优缺点：优点： 预测能力：回归模型能够用于预测因变量的未知值，从而支持决策和规划。 变量关联性：回归分析可以揭示变量之间的关联性，帮助理解影响因素。 解释性：回归模型可以解释自变量对因变量变化的影响程度。 缺点： 过拟合：复杂的模型可能会在训练数据上过度拟合，导致泛化性能下降。 数据偏差：如果样本数据不具有代表性，回归模型的准确性可能受到影响。 高维问题：在高维情况下，回归模型的构建和解释可能变得复杂。 适用范围：回归分析适用于许多领域，例如： 经济学： 预测经济指标、探索经济因素之间的关系。 医学： 预测疾病发展趋势、探索影响健康的因素。 市场营销： 预测销售趋势、分析市场因素的影响。 社会科学： 分析社会因素对人类行为的影响。 使用方法： 数据准备： 收集自变量和因变量的样本数据，确保数据质量。 模型选择： 根据问题特点选择合适的回归模型，如线性回归、多项式回归、岭回归等。 模型训练： 使用样本数据训练回归模型，估计模型的参数。 预测分析： 利用训练好的模型进行因变量的预测，分析预测结果的准确性。 变量影响： 分析模型的系数和显著性，了解自变量对因变量的影响。 需要注意的是，回归分析的选择和应用需要根据问题的性质和数据的特点进行调整，以确保模型的准确性和可靠性。 拟合算法在数学建模算法中，拟合算法 是一种用于找到最适合一组数据的数学函数或模型的方法。拟合算法通过分析已知数据点，寻找与数据最匹配的函数或模型，以便预测未知数据点的值或进行数据分析。 定义：拟合算法是一种通过在已知数据点之间寻找最佳适应函数或模型的方法，以便对未知数据点进行估计或分析。 条件： 已知数据点： 必须已知一组数据点的数值，包括自变量和因变量。 拟合函数&#x2F;模型： 需要选择适合问题的函数形式或模型类型。 优缺点：优点： 数据分析： 拟合算法可以帮助分析数据的趋势、关系和规律。 预测能力： 拟合的函数&#x2F;模型可以用于预测未知数据点的值。 可视化： 通过拟合曲线，可以将数据可视化并呈现。 缺点： 过拟合： 复杂模型可能在已知数据上过度拟合，导致在新数据上表现不好。 数据偏差： 如果样本数据不具有代表性，拟合结果可能不准确。 模型选择： 选择适合的拟合函数&#x2F;模型可能需要一定的专业知识。 适用范围：拟合算法广泛应用于各个领域，例如： 曲线拟合： 在数学、物理等领域中，拟合曲线用于描述实验数据的变化趋势。 数据分析： 在统计学和数据科学中，拟合算法用于分析数据集的分布和关系。 趋势预测： 在经济学和市场研究中，拟合模型用于预测未来趋势。 图像处理： 在图像处理中，拟合算法可以用于图像边缘检测和特征提取。 使用方法： 数据准备： 收集已知的数据点，包括自变量和因变量。 选择模型： 根据数据的性质选择适合的拟合函数或模型类型。 参数估计： 使用数据点拟合函数&#x2F;模型，估计函数的参数。 模型评估： 评估拟合的函数&#x2F;模型在数据上的拟合程度，考虑是否满足需求。 预测分析： 利用拟合的函数&#x2F;模型进行未知数据点的预测和分析。 拟合算法的使用需要根据问题的特点和数据的性质进行适当的调整，以获得准确和有用的结果。 模糊综合法定义：综合模糊评价是一种利用模糊逻辑理论进行多个指标或因素综合评估的方法。在这种方法中，考虑到因素之间的不确定性和模糊性，将各个因素的权重和评价值用模糊数来表示，然后利用模糊逻辑的运算规则进行综合评价。 条件： 多个因素： 综合模糊评价适用于需要考虑多个因素对一个问题进行评估的情况。 模糊性或不确定性： 当因素的评价不是精确的数值，而是模糊的、不确定的情况下，综合模糊评价尤为适用。 优点： 适应不确定性： 综合模糊评价能够处理因素之间的模糊性和不确定性，更贴近实际情况。 多因素考虑： 它可以将多个因素的影响纳入考虑，生成综合的评价结果。 灵活性： 可根据不同问题的特点进行灵活调整，适用于各种决策问题。 缺点： 复杂性： 模糊逻辑的运算和推理相对复杂，需要一定的数学基础和理解。 模型建立： 建立模糊评价模型需要确定模糊集合、隶属度函数等参数，可能需要专业知识。 适用范围：综合模糊评价广泛应用于各个领域，例如： 决策分析： 在复杂的决策问题中，考虑多个因素的影响，以支持决策制定。 产品评价： 对产品质量、性能等进行评价时，考虑多个指标的影响。 项目评估： 对项目的可行性、风险等进行评估，综合各个方面的因素。 使用方法： 确定指标和权重： 确定需要评估的指标或因素，为它们分配权重。 模糊化： 将指标的评价值转化为模糊数，确定隶属度函数。 模糊逻辑运算： 使用模糊逻辑的运算规则，进行模糊数的运算和综合。 解模糊： 对综合的模糊评价结果进行解模糊，得到最终的评价结果。 综合模糊评价方法在解决复杂决策问题时具有一定的优势，但需要注意合理选择模型和参数，以确保评价结果的可靠性。 主要成分分析法 P29定义：主成分分析是一种数学技术，用于将高维数据集映射到低维空间，以捕捉数据的主要变化模式。通过寻找数据中最重要的主成分，PCA可以用更少的维度来表示数据，同时尽量保留数据的方差。 条件： 高维数据： 主成分分析适用于高维数据集，其中特征维度较多。 线性变换： 主成分分析基于线性变换，寻找数据中的主要方向。 优点： 降维： 主成分分析可以将高维数据降低到较低的维度，减少数据的冗余和复杂性。 信息保留： 尽管降维，但主成分通常能够保留数据中的主要变化模式，保留重要信息。 去噪： 主成分分析可以从数据中去除一部分噪声和不重要的变化。 缺点： 解释性： 降维后的主成分不一定与原始特征有直接的物理或实际解释关系。 数据分布： 主成分分析假设数据在低维空间中呈线性分布，对于非线性数据可能效果较差。 适用范围：主成分分析广泛应用于各个领域，例如： 数据压缩： 在图像和音频处理中，将大量数据压缩到较小的空间，以便存储和传输。 特征提取： 在模式识别和机器学习中，使用主成分分析提取最重要的特征。 数据可视化： 将高维数据可视化成二维或三维，以便更好地理解数据分布。 使用方法： 数据准备： 收集和准备需要分析的数据集。 数据标准化： 对数据进行标准化，使得各个特征维度具有相同的尺度。 计算协方差矩阵： 计算数据特征之间的协方差矩阵。 计算特征向量和特征值： 对协方差矩阵进行特征值分解，得到主成分的特征向量和特征值。 选择主成分： 根据特征值的大小，选择前几个主成分作为新的数据维度。 映射数据： 将原始数据映射到主成分上，得到降维后的数据集。 主成分分析能够帮助处理高维数据问题，但在应用时需要根据问题的性质和数据分布进行调整和解释结果。 相关性分析定义：相关性分析是一种用于确定两个或多个变量之间关系强度和方向的方法。通过计算变量之间的相关系数，可以判断它们是否呈现正相关、负相关或无关。相关性分析帮助我们理解变量之间的关系，以及一个变量的变化如何影响另一个变量。 条件： 变量间关系： 相关性分析适用于需要了解变量之间关系的问题。 线性关系： 相关性分析假设变量之间的关系是线性的，不适用于非线性关系分析。 优点： 发现关联： 相关性分析能够帮助发现变量之间的关联，揭示数据背后的模式。 可视化： 通过绘制相关性图表，可以直观地展示变量之间的关系。 预测： 了解变量之间的关系有助于进行预测和建立模型。 缺点： 线性假设： 相关性分析假设变量之间是线性关系，对于非线性关系不适用。 不代表因果关系： 相关性不意味着因果关系，即使两个变量相关，也不能确定其中一个是另一个的原因。 适用范围：相关性分析广泛应用于各个领域，例如： 金融分析： 分析不同金融指标之间的关系，预测市场变化。 医学研究： 研究不同变量对健康指标的影响，了解疾病风险因素。 社会科学： 分析社会经济指标之间的关联，揭示社会趋势。 使用方法： 数据准备： 收集和准备需要分析的数据集。 计算相关系数： 计算变量之间的相关系数，如Pearson相关系数、Spearman等。 绘制图表： 绘制相关性矩阵图或散点图，直观展示变量之间的关系。 解释结果： 根据相关系数的大小和方向，解释变量之间的关系。 相关性分析能够帮助我们理解变量之间的关系，但需要注意相关性并不代表因果关系，需要谨慎解释结果。 神经网络算法","categories":[{"name":"数学建模","slug":"数学建模","permalink":"http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"算法","slug":"数学建模/算法","permalink":"http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"学生管理系统-前端-前端界面的设计","slug":"学生管理系统-前端-前端界面的设计","date":"2023-08-08T06:00:48.000Z","updated":"2023-08-08T07:37:51.345Z","comments":true,"path":"2023/08/08/学生管理系统-前端-前端界面的设计/","link":"","permalink":"http://yoursite.com/2023/08/08/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E5%89%8D%E7%AB%AF-%E5%89%8D%E7%AB%AF%E7%95%8C%E9%9D%A2%E7%9A%84%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"vue包括一个模板（template）、一个脚本（script）和一个样式（style）部分。 基础知识 模板（template）部分：该部分定义了界面的布局和交互元素。其中包括： 标题和按钮：展示标题 “学生管理系统” 和若干按钮，用于获取学生信息、添加学生信息、登录和注册。 弹窗（Dialog）：使用 Element UI 的 el-dialog 组件实现了添加学生信息、登录和注册的弹窗界面。每个弹窗包含一些表单项，用户可以输入信息并进行相应操作。 学生列表：展示学生信息的表格，通过 v-for 循环渲染 Student 组件，显示学生的各个字段。 分页按钮：使用 Element UI 的 el-button 组件实现了上一页和下一页的分页功能。 脚本（script）部分：在这里，组件的逻辑部分被定义。它包括以下内容： data：定义了一些数据属性，包括用户登录和注册的相关信息、当前页码、每页显示的学生数、学生列表数据、添加学生弹窗的状态等。 computed：定义了 displayedStudents 计算属性，用于根据当前页码和每页显示数来计算显示的学生列表。 methods：包含了各种方法，例如获取学生信息、添加学生、翻页、登录、注册等。 样式（style）部分：该部分定义了组件的样式。其中使用了一些 CSS 类来设置标题、按钮、表单等的样式。 关于外部工具的引入我们用npm引入 安装element-ui包,在终端执行以下命令1npm i element-ui 使用 Element UI 提供的样式类和自定义样式来美化界面。 安装bootstrap1npm install bootstrap@5.2.0-beta1 安装axios1npm i axios 基本使用12345678910import axios from &#x27;axios&#x27;axios.get(&#x27;http://localhost:8000/students&#x27;).then( response =&gt; &#123; console.log(response.data); &#125;, error =&gt;&#123; console.log(error.massage); &#125;) 项目基本结构 app.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245&lt;template&gt; &lt;div class=&quot;App&quot;&gt; &lt;h1 class=&quot;title&quot;&gt;学生管理系统&lt;/h1&gt; &lt;div class=&quot;button-container&quot;&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;getStudents&quot;&gt;获取学生信息&lt;/el-button&gt; &lt;el-button type=&quot;warning&quot; @click=&quot;dialogVisible = true&quot;&gt;添加学生信息&lt;/el-button&gt; &lt;el-button type=&quot;info&quot; @click=&quot;dialogVisiblelogin = true&quot;&gt;登 录&lt;/el-button&gt; &lt;el-button type=&quot;danger&quot; @click=&quot;dialogVisibleregister = true&quot;&gt;注 册&lt;/el-button&gt; &lt;/div&gt; &lt;el-dialog title=&quot;提示&quot; :visible.sync=&quot;dialogVisible&quot; width=&quot;30%&quot; :before-close=&quot;handleClose&quot;&gt; &lt;div&gt;添加学生信息&lt;/div&gt; &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogVisible = false&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;addStudent&quot;&gt;添加&lt;/el-button&gt; &lt;/span&gt; &lt;div&gt; &lt;div&gt;&lt;span&gt;学号：&lt;/span&gt;&lt;input v-model=&quot;newStudent.number&quot; /&gt;&lt;/div&gt; &lt;div&gt;&lt;span&gt;姓名：&lt;/span&gt;&lt;input v-model=&quot;newStudent.name&quot; /&gt;&lt;/div&gt; &lt;div&gt;&lt;span&gt;年龄：&lt;/span&gt;&lt;input v-model=&quot;newStudent.age&quot; /&gt;&lt;/div&gt; &lt;div&gt;&lt;span&gt;语文：&lt;/span&gt;&lt;input v-model=&quot;newStudent.chi&quot; /&gt;&lt;/div&gt; &lt;div&gt;&lt;span&gt;数学：&lt;/span&gt;&lt;input v-model=&quot;newStudent.math&quot; /&gt;&lt;/div&gt; &lt;div&gt;&lt;span&gt;英语：&lt;/span&gt;&lt;input v-model=&quot;newStudent.eng&quot; /&gt;&lt;/div&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;el-dialog title=&quot;登录&quot; :visible.sync=&quot;dialogVisiblelogin&quot; width=&quot;30%&quot; :before-close=&quot;handleClose&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;form-item&quot;&gt; &lt;span&gt;用户名：&lt;/span&gt;&lt;input type=&quot;text&quot; v-model=&quot;user_for_login.username&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-item&quot;&gt; &lt;span&gt;密 码：&lt;/span&gt;&lt;input type=&quot;password&quot; v-model=&quot;user_for_login.password&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogVisiblelogin = false&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;login&quot;&gt;登 录&lt;/el-button&gt; &lt;/span&gt;&lt;/el-dialog&gt;&lt;el-dialog title=&quot;注册&quot; :visible.sync=&quot;dialogVisibleregister&quot; width=&quot;30%&quot; :before-close=&quot;handleClose&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;form-item&quot;&gt; &lt;span&gt;用户名：&lt;/span&gt;&lt;input type=&quot;text&quot; v-model=&quot;user_for_register.username&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-item&quot;&gt; &lt;span&gt;密 码：&lt;/span&gt;&lt;input type=&quot;password&quot; v-model=&quot;user_for_register.password&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-item&quot;&gt; &lt;span&gt;确认密码：&lt;/span&gt;&lt;input type=&quot;password&quot; v-model=&quot;user_for_register.confirmPassword&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogVisibleregister = false&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;register&quot;&gt;注 册&lt;/el-button&gt; &lt;/span&gt;&lt;/el-dialog&gt; &lt;div class=&quot;col-8 offset-2&quot;&gt; &lt;table class=&quot;table table-hover&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th scope=&quot;col&quot;&gt;学号&lt;/th&gt; &lt;th scope=&quot;col&quot;&gt;姓名&lt;/th&gt; &lt;th scope=&quot;col&quot;&gt;年龄&lt;/th&gt; &lt;th scope=&quot;col&quot;&gt;语文&lt;/th&gt; &lt;th scope=&quot;col&quot;&gt;数学&lt;/th&gt; &lt;th scope=&quot;col&quot;&gt;英语&lt;/th&gt; &lt;th scope=&quot;col&quot;&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;Student v-for=&quot;stu in displayedStudents&quot; :key=&quot;stu.id&quot; :student=&quot;stu&quot; /&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class=&quot;text-center&quot;&gt; &lt;el-button-group&gt; &lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-arrow-left&quot; @click=&quot;prevPage&quot;&gt;上一页&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;nextPage&quot;&gt;下一页&lt;i class=&quot;el-icon-arrow-right el-icon--right&quot;&gt;&lt;/i&gt;&lt;/el-button&gt; &lt;/el-button-group&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from &#x27;axios&#x27;import Student from &quot;./components/Student.vue&quot;export default &#123; name: &#x27;App&#x27;, components: &#123; Student &#125;, data() &#123; return &#123; user_for_login:&#123; username:&quot;&quot;, password:&quot;&quot;, &#125;, user_for_register:&#123; username:&quot;&quot;, password:&quot;&quot;, confirmPassword:&quot;&quot;, &#125;, page: 1, pageSize: 10, students: [], dialogVisible: false, dialogVisiblelogin:false, dialogVisibleregister:false, newStudent: &#123; number: &quot;&quot;, name: &quot;&quot;, age: &quot;&quot;, chi: &quot;&quot;, math: &quot;&quot;, eng: &quot;&quot; &#125; &#125; &#125;, computed: &#123; displayedStudents() &#123; const startIdx = (this.page - 1) * this.pageSize; return this.students.slice(startIdx, startIdx + this.pageSize); &#125; &#125;, methods: &#123; getStudents() &#123; if (sessionStorage.getItem(&quot;isLogined&quot;) == &quot;true&quot;) &#123; axios(&#123; url: &quot;http://localhost:8080/students&quot;, method: &#x27;GET&#x27;, &#125;).then(res =&gt; &#123; console.log(res.data); this.students = res.data; // 更新 students 数据 &#125;) &#125; else &#123; this.$alert(&quot;请先登录&quot;); &#125;&#125;, handleClose(done) &#123; this.$confirm(&#x27;确认关闭？&#x27;) .then(_ =&gt; &#123; done(); &#125;) .catch(_ =&gt; &#123;&#125;); &#125;, addStudent() &#123; axios(&#123; url: &quot;http://localhost:8080/insert&quot;, method: &#x27;POST&#x27;, data: this.newStudent &#125;); this.dialogVisible = false; &#125;, prevPage() &#123; if (this.page &gt; 1) &#123; this.page--; &#125; &#125;, nextPage() &#123; const maxPage = Math.ceil(this.students.length / this.pageSize); if (this.page &lt; maxPage) &#123; this.page++; &#125; &#125;, login()&#123; axios(&#123; url : &quot;http://localhost:8080/login&quot;, data:this.user_for_login, method:&quot;POST&quot; &#125;).then(res =&gt;&#123; console.log(res.data); localStorage.setItem(&quot;login&quot;,res.data) if(res.data == &quot;1&quot;)&#123; sessionStorage.setItem(&quot;isLogined&quot;,&quot;true&quot;); &#125; else &#123; alert(&quot;用户名密码错误&quot;) &#125; &#125;) this.dialogVisiblelogin = false &#125;, register()&#123; axios(&#123; url : &quot;http://localhost:8080/register&quot;, data:this.user_for_register, method:&quot;POST&quot; &#125;) this.$alert(&quot;注册成功&quot;) &#125; &#125;&#125;;&lt;/script&gt;&lt;style&gt;.title &#123; text-align: center;&#125;.col-8.offset-2 &#123; margin-top: 20px;&#125;.button-container &#123; display: flex; justify-content: center; margin-bottom: 20px;&#125;.form-group &#123; display: flex; flex-direction: column;&#125;.form-item &#123; display: flex; align-items: center; margin-bottom: 10px;&#125;.form-item span &#123; min-width: 100px; /* Adjust the width as needed */ display: inline-block;&#125;&lt;/style&gt; student.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245&lt;template&gt; &lt;div class=&quot;App&quot;&gt; &lt;h1 class=&quot;title&quot;&gt;学生管理系统&lt;/h1&gt; &lt;div class=&quot;button-container&quot;&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;getStudents&quot;&gt;获取学生信息&lt;/el-button&gt; &lt;el-button type=&quot;warning&quot; @click=&quot;dialogVisible = true&quot;&gt;添加学生信息&lt;/el-button&gt; &lt;el-button type=&quot;info&quot; @click=&quot;dialogVisiblelogin = true&quot;&gt;登 录&lt;/el-button&gt; &lt;el-button type=&quot;danger&quot; @click=&quot;dialogVisibleregister = true&quot;&gt;注 册&lt;/el-button&gt; &lt;/div&gt; &lt;el-dialog title=&quot;提示&quot; :visible.sync=&quot;dialogVisible&quot; width=&quot;30%&quot; :before-close=&quot;handleClose&quot;&gt; &lt;div&gt;添加学生信息&lt;/div&gt; &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogVisible = false&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;addStudent&quot;&gt;添加&lt;/el-button&gt; &lt;/span&gt; &lt;div&gt; &lt;div&gt;&lt;span&gt;学号：&lt;/span&gt;&lt;input v-model=&quot;newStudent.number&quot; /&gt;&lt;/div&gt; &lt;div&gt;&lt;span&gt;姓名：&lt;/span&gt;&lt;input v-model=&quot;newStudent.name&quot; /&gt;&lt;/div&gt; &lt;div&gt;&lt;span&gt;年龄：&lt;/span&gt;&lt;input v-model=&quot;newStudent.age&quot; /&gt;&lt;/div&gt; &lt;div&gt;&lt;span&gt;语文：&lt;/span&gt;&lt;input v-model=&quot;newStudent.chi&quot; /&gt;&lt;/div&gt; &lt;div&gt;&lt;span&gt;数学：&lt;/span&gt;&lt;input v-model=&quot;newStudent.math&quot; /&gt;&lt;/div&gt; &lt;div&gt;&lt;span&gt;英语：&lt;/span&gt;&lt;input v-model=&quot;newStudent.eng&quot; /&gt;&lt;/div&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;el-dialog title=&quot;登录&quot; :visible.sync=&quot;dialogVisiblelogin&quot; width=&quot;30%&quot; :before-close=&quot;handleClose&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;form-item&quot;&gt; &lt;span&gt;用户名：&lt;/span&gt;&lt;input type=&quot;text&quot; v-model=&quot;user_for_login.username&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-item&quot;&gt; &lt;span&gt;密 码：&lt;/span&gt;&lt;input type=&quot;password&quot; v-model=&quot;user_for_login.password&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogVisiblelogin = false&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;login&quot;&gt;登 录&lt;/el-button&gt; &lt;/span&gt;&lt;/el-dialog&gt;&lt;el-dialog title=&quot;注册&quot; :visible.sync=&quot;dialogVisibleregister&quot; width=&quot;30%&quot; :before-close=&quot;handleClose&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;form-item&quot;&gt; &lt;span&gt;用户名：&lt;/span&gt;&lt;input type=&quot;text&quot; v-model=&quot;user_for_register.username&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-item&quot;&gt; &lt;span&gt;密 码：&lt;/span&gt;&lt;input type=&quot;password&quot; v-model=&quot;user_for_register.password&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-item&quot;&gt; &lt;span&gt;确认密码：&lt;/span&gt;&lt;input type=&quot;password&quot; v-model=&quot;user_for_register.confirmPassword&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogVisibleregister = false&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;register&quot;&gt;注 册&lt;/el-button&gt; &lt;/span&gt;&lt;/el-dialog&gt; &lt;div class=&quot;col-8 offset-2&quot;&gt; &lt;table class=&quot;table table-hover&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th scope=&quot;col&quot;&gt;学号&lt;/th&gt; &lt;th scope=&quot;col&quot;&gt;姓名&lt;/th&gt; &lt;th scope=&quot;col&quot;&gt;年龄&lt;/th&gt; &lt;th scope=&quot;col&quot;&gt;语文&lt;/th&gt; &lt;th scope=&quot;col&quot;&gt;数学&lt;/th&gt; &lt;th scope=&quot;col&quot;&gt;英语&lt;/th&gt; &lt;th scope=&quot;col&quot;&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;Student v-for=&quot;stu in displayedStudents&quot; :key=&quot;stu.id&quot; :student=&quot;stu&quot; /&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class=&quot;text-center&quot;&gt; &lt;el-button-group&gt; &lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-arrow-left&quot; @click=&quot;prevPage&quot;&gt;上一页&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;nextPage&quot;&gt;下一页&lt;i class=&quot;el-icon-arrow-right el-icon--right&quot;&gt;&lt;/i&gt;&lt;/el-button&gt; &lt;/el-button-group&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from &#x27;axios&#x27;import Student from &quot;./components/Student.vue&quot;export default &#123; name: &#x27;App&#x27;, components: &#123; Student &#125;, data() &#123; return &#123; user_for_login:&#123; username:&quot;&quot;, password:&quot;&quot;, &#125;, user_for_register:&#123; username:&quot;&quot;, password:&quot;&quot;, confirmPassword:&quot;&quot;, &#125;, page: 1, pageSize: 10, students: [], dialogVisible: false, dialogVisiblelogin:false, dialogVisibleregister:false, newStudent: &#123; number: &quot;&quot;, name: &quot;&quot;, age: &quot;&quot;, chi: &quot;&quot;, math: &quot;&quot;, eng: &quot;&quot; &#125; &#125; &#125;, computed: &#123; displayedStudents() &#123; const startIdx = (this.page - 1) * this.pageSize; return this.students.slice(startIdx, startIdx + this.pageSize); &#125; &#125;, methods: &#123; getStudents() &#123; if (sessionStorage.getItem(&quot;isLogined&quot;) == &quot;true&quot;) &#123; axios(&#123; url: &quot;http://localhost:8080/students&quot;, method: &#x27;GET&#x27;, &#125;).then(res =&gt; &#123; console.log(res.data); this.students = res.data; // 更新 students 数据 &#125;) &#125; else &#123; this.$alert(&quot;请先登录&quot;); &#125;&#125;, handleClose(done) &#123; this.$confirm(&#x27;确认关闭？&#x27;) .then(_ =&gt; &#123; done(); &#125;) .catch(_ =&gt; &#123;&#125;); &#125;, addStudent() &#123; axios(&#123; url: &quot;http://localhost:8080/insert&quot;, method: &#x27;POST&#x27;, data: this.newStudent &#125;); this.dialogVisible = false; &#125;, prevPage() &#123; if (this.page &gt; 1) &#123; this.page--; &#125; &#125;, nextPage() &#123; const maxPage = Math.ceil(this.students.length / this.pageSize); if (this.page &lt; maxPage) &#123; this.page++; &#125; &#125;, login()&#123; axios(&#123; url : &quot;http://localhost:8080/login&quot;, data:this.user_for_login, method:&quot;POST&quot; &#125;).then(res =&gt;&#123; console.log(res.data); localStorage.setItem(&quot;login&quot;,res.data) if(res.data == &quot;1&quot;)&#123; sessionStorage.setItem(&quot;isLogined&quot;,&quot;true&quot;); &#125; else &#123; alert(&quot;用户名密码错误&quot;) &#125; &#125;) this.dialogVisiblelogin = false &#125;, register()&#123; axios(&#123; url : &quot;http://localhost:8080/register&quot;, data:this.user_for_register, method:&quot;POST&quot; &#125;) this.$alert(&quot;注册成功&quot;) &#125; &#125;&#125;;&lt;/script&gt;&lt;style&gt;.title &#123; text-align: center;&#125;.col-8.offset-2 &#123; margin-top: 20px;&#125;.button-container &#123; display: flex; justify-content: center; margin-bottom: 20px;&#125;.form-group &#123; display: flex; flex-direction: column;&#125;.form-item &#123; display: flex; align-items: center; margin-bottom: 10px;&#125;.form-item span &#123; min-width: 100px; /* Adjust the width as needed */ display: inline-block;&#125;&lt;/style&gt; ** 样式设计**使用 Element UI 提供的样式类和自定义样式来美化界面。 9 部署和测试部署前端应用到服务器，访问页面并测试各项功能。 优化和扩展 使用 Vue Router 实现页面路由切换。 使用 Vuex 进行状态管理。 实现分页功能。 增加表单验证等。 ** 注意事项** 遇到跨域问题，可以配置代理或后端设置 CORS。 错误处理和状态提示。 参考资料 Vue.js 文档：https://vuejs.org/ Element UI 文档：https://element-plus.org/ Axios 文档：https://axios-http.com/docs/intro","categories":[{"name":"项目实战","slug":"项目实战","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"},{"name":"学生管理系统","slug":"项目实战/学生管理系统","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"学生管理系统-vue脚手架以及组件的下载","slug":"学生管理系统-vue脚手架以及组件的下载","date":"2023-08-08T01:35:43.000Z","updated":"2023-08-08T05:35:00.146Z","comments":true,"path":"2023/08/08/学生管理系统-vue脚手架以及组件的下载/","link":"","permalink":"http://yoursite.com/2023/08/08/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-vue%E8%84%9A%E6%89%8B%E6%9E%B6%E4%BB%A5%E5%8F%8A%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%8B%E8%BD%BD/","excerpt":"","text":"下载和安装Vue脚手架（Vue CLI）要使用Vue脚手架（Vue CLI）来快速搭建Vue.js项目，需要遵循以下步骤： 确保自己已经安装了Node.js和npm： 首先，确保你已经在计算机上安装了Node.js和npm。你还可以可以从 Node.js官网 下载并安装最新版本的Node.js，npm会随之安装。 安装Vue CLI： 打开终端（命令行界面）并运行以下命令来全局安装Vue CLI： 1npm install -g @vue/cli 这会在全局范围内安装Vue CLI。根据你的系统和网络速度，可能需要一些时间来完成安装。 验证安装： 安装完成后，你可以运行以下命令来验证Vue CLI是否成功安装： 1vue --version 如果一切正常，你将看到安装的Vue CLI版本号。 创建Vue项目： 安装完成后，你可以使用Vue CLI来创建新的Vue项目。在命令行中运行以下命令： 12cd 目标文件夹的路径vue create your-project-name 将 your-project-name 替换为你想要的项目名称。然后按照提示进行配置选择，Vue CLI将会创建一个新的Vue项目文件夹。 进入项目目录并启动开发服务器： 进入新创建的项目文件夹,再用vscode打开（我建议Vscode打开，我们之后还有用vscode）： 12cd your-project-namecode . 然后新建终端运行以下命令启动开发服务器： 1npm run serve 这将启动一个本地开发服务器。","categories":[],"tags":[]},{"title":"学生管理系统-node.js下载安装与npm简单使用","slug":"学生管理系统-node-js下载安装与npm简单使用","date":"2023-08-08T01:26:15.000Z","updated":"2023-08-08T01:44:55.203Z","comments":true,"path":"2023/08/08/学生管理系统-node-js下载安装与npm简单使用/","link":"","permalink":"http://yoursite.com/2023/08/08/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-node-js%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E4%B8%8Enpm%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Node.js和npm（Node Package Manager）是与Java前后端开发有些不同，但在某些方面有重要作用的工具。 Node.js Node.js是一个基于Chrome V8引擎的JavaScript运行时环境，它允许你使用JavaScript来编写服务器端代码。在Java前后端开发中，通常会使用Java来编写后端代码，而Node.js可以提供一种替代方案。Node.js的特点是非阻塞I&#x2F;O和事件驱动的架构，这使得它在处理大量并发请求时表现得非常出色。它适用于构建高性能、实时性要求较高的应用，比如聊天应用、实时协作工具等。Node.js还有丰富的第三方模块和库，可以大大加速开发过程。 npm npm是Node.js的包管理工具，用于安装、管理和分享JavaScript模块。在Java前后端开发中，你可能会用到npm来管理前端项目的依赖项，这些依赖项可以是JavaScript库、框架、工具等。通过npm，你可以轻松地安装、更新和卸载这些依赖项，使得前端开发变得更加高效和便捷。 需要注意的是，Java和Node.js虽然在某些方面可以互补，但它们也有自己的特点和适用场景。Java通常用于构建更复杂、企业级的应用，拥有强大的生态系统和成熟的开发工具。Node.js则更适用于构建轻量级、实时性要求高的应用，特别是那些需要处理大量并发请求的场景。 综上所述，Node.js和npm在Java前后端开发中分别扮演着提供服务器端JavaScript运行环境和管理前端依赖项的重要角色。根据项目需求和特点，你可以选择适合的技术栈来进行开发。 接下来说一下node.js的安装，这个前人已经总结的很清晰明了了。我在这里留几个连接 node.js安装及环境配置超详细教程【Windows系统安装包方式】 nodejs安装和环境配置-Windows 照着这两个基本就可以实现了，至于其他的入npm使用，也可以csdn搜索去找帖子。","categories":[],"tags":[]},{"title":"学生管理系统-后端5-创建数据库与配置数据库","slug":"学生管理系统-后端5-创建数据库与配置数据库","date":"2023-08-06T02:27:35.000Z","updated":"2023-08-06T09:10:22.113Z","comments":true,"path":"2023/08/06/学生管理系统-后端5-创建数据库与配置数据库/","link":"","permalink":"http://yoursite.com/2023/08/06/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E5%90%8E%E7%AB%AF5-%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"创建数据库对于数据库的知识如果有遗漏，可以查看这篇博客mysql常用命令_artly1的博客-CSDN博客 sql代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647-- 创建demo数据库CREATE DATABASE demo;-- 使用demo数据库USE demo;-- 创建student表（使用你之前提供的结构）CREATE TABLE student ( id bigint(20) NOT NULL AUTO_INCREMENT, number varchar(255) NOT NULL, name varchar(255) NOT NULL, age int(11) NOT NULL, chi int(11) NOT NULL, math int(11) NOT NULL, eng int(11) NOT NULL, PRIMARY KEY (id)) ENGINE=InnoDB AUTO_INCREMENT=138 DEFAULT CHARSET=utf8;-- 创建user表CREATE TABLE user ( id bigint(20) NOT NULL AUTO_INCREMENT, username varchar(255) NOT NULL, password varchar(255) NOT NULL, PRIMARY KEY (id)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;-- 插入学生数据INSERT INTO student (number, name, age, chi, math, eng) VALUES(1,&#x27;101&#x27;,&#x27;张三&#x27;,18,99,99,99),(2,&#x27;102&#x27;,&#x27;李四&#x27;,19,92,80,55),(3,&#x27;103&#x27;,&#x27;王五&#x27;,20,88,79,88),(4,&#x27;104&#x27;,&#x27;马六&#x27;,21,75,88,99),(5,&#x27;105&#x27;,&#x27;赵七&#x27;,17,88,54,67),(6,&#x27;106&#x27;,&#x27;陈八&#x27;,24,87,77,33),(7,&#x27;107&#x27;,&#x27;朱九&#x27;,23,91,44,56),(8,&#x27;108&#x27;,&#x27;小红&#x27;,8,82,77,90),(9,&#x27;109&#x27;,&#x27;小强&#x27;,8,78,67,88),(10,&#x27;110&#x27;,&#x27;大白&#x27;,17,73,72,71),(11,&#x27;111&#x27;,&#x27;小花&#x27;,20,73,73,88),(12,&#x27;112&#x27;,&#x27;小新&#x27;,7,59,59,59),(13,&#x27;113&#x27;,&#x27;小黄&#x27;,14,78,99,93);-- 插入用户数据INSERT INTO user (username, password) VALUES(&#x27;abc&#x27;, &#x27;123&#x27;),(&#x27;111&#x27;, &#x27;123&#x27;); 连接数据库 代码12345datasource: username: root password: &#x27;123456&#x27; url: jdbc:mysql://127.0.0.1:3306/demo?characterEncoding=UTF-8&amp;serverTimezone=UTC driver-class-name: com.mysql.cj.jdbc.Driver username: 数据库用户名 password: ‘数据库密码’ url: jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;数据库名?characterEncoding&#x3D;UTF-8&amp;serverTimezone&#x3D;UTC","categories":[{"name":"项目实战","slug":"项目实战","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"},{"name":"学生管理系统","slug":"项目实战/学生管理系统","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"学生管理系统-后端4-创建mapper与实体类","slug":"学生管理系统-后端4-创建mapper与实体类","date":"2023-08-06T02:26:56.000Z","updated":"2023-08-06T05:06:55.050Z","comments":true,"path":"2023/08/06/学生管理系统-后端4-创建mapper与实体类/","link":"","permalink":"http://yoursite.com/2023/08/06/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E5%90%8E%E7%AB%AF4-%E5%88%9B%E5%BB%BAmapper%E4%B8%8E%E5%AE%9E%E4%BD%93%E7%B1%BB/","excerpt":"","text":"我们按照这种格式去创建我们的实体类和mapper 创建实体类实体类是与数据库表对应的 Java 类。它们通常具有与表中列相对应的属性，用于在应用程序和数据库之间传递数据。由于我们还没有创建数据库，可以先到5中去看数据库表 定义实体类： 创建一个 Java 类，用于表示数据库表中的一行数据。该类的属性应与表中的列相匹配。 1234public class User &#123; private String username; private String password;&#125; 添加注解：使用适当的注解来映射实体类与数据库表。 1@Data 使用 @Data 注解会自动生成 User 类的 getter、setter、equals、hashCode 和 toString 方法。这样你就无需手动编写这些方法了。大大简化了代码 代码Student 123456789101112package org.example.pojo;import lombok.Data;@Datapublic class Student &#123; private long id; private String number; private String name; private int age; private int chi; private int math; private int eng;&#125; User 1234567package org.example.pojo;import lombok.Data;@Datapublic class User &#123; private String username; private String password;&#125; 一定要写@Data注解，这样会省很多代码。 创建 MapperMapper 是用于执行数据库操作的接口或类，它们与实体类紧密相关，用于增删改查等操作。因为我们已经引入了MyBatis Plus，在 MyBatis Plus 中，你只需要继承 BaseMapper 接口，并指定泛型类型（即对应的实体类），框架会自动为你生成常见的增删改查方法，无需手动编写。。 注意：创建时选择接口，不是java类 使用 Mapper： 在应用程序中使用依赖注入或其他方式，将 Mapper 注入到需要的地方，执行数据库操作。 代码​ StudentMapper 12345678package org.example.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import org.example.pojo.Student;//mapper接口需要继承base所以extendspublic interface StudentMapper extends BaseMapper&lt;Student&gt; &#123;//&lt;&gt;中写入要传的实体类&#125; ​ UserMapper 123456package org.example.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import org.example.pojo.User;public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125;","categories":[{"name":"项目实战","slug":"项目实战","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"},{"name":"学生管理系统","slug":"项目实战/学生管理系统","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"学生管理系统-后端3-创建application和controller类","slug":"学生管理系统-后端3-创建application和controller类","date":"2023-08-06T02:26:06.000Z","updated":"2023-08-06T04:45:29.535Z","comments":true,"path":"2023/08/06/学生管理系统-后端3-创建application和controller类/","link":"","permalink":"http://yoursite.com/2023/08/06/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E5%90%8E%E7%AB%AF3-%E5%88%9B%E5%BB%BAapplication%E5%92%8Ccontroller%E7%B1%BB/","excerpt":"","text":"Application类1. 概述Application 类是一个Spring Boot应用的入口类，通过 @SpringBootApplication 注解标记，用于启动和初始化整个应用程序。同时，该类使用 @MapperScan 注解扫描指定的包路径，以自动发现和注册MyBatis的Mapper接口。 2. 主要功能Application 类主要完成以下功能： 初始化和启动Spring Boot应用程序。 自动扫描并注册MyBatis的Mapper接口。 提供 main 方法，用于执行应用程序的入口逻辑。 3. 使用方法3.1. 导入项目在项目的源代码中，导入 Application.java 文件。 1234567891011121314package org.example;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication//通过这个类，就可以把这个类标志成启动类@MapperScan(&quot;org.example.mapper&quot;)//扫描mapper包public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args);//这个类的class对象 &#125;&#125; 3.2. 注解说明 @SpringBootApplication: 该注解标识了一个Spring Boot应用的启动类。它会自动启用Spring Boot的自动配置，并扫描同级包及其子包下的组件。 @MapperScan(&quot;org.example.mapper&quot;): 该注解用于扫描指定的包路径，自动发现和注册MyBatis的Mapper接口。 3.3. 启动应用程序运行 main 方法，即可启动Spring Boot应用程序。 Controller类1. 概述Controller 类是一个Spring Boot中的REST控制器，用于处理来自前端的HTTP请求并与数据库交互。通过各种不同的请求映射方法，它实现了学生信息的增、删、改、查操作，以及用户登录和注册功能。 2. 主要功能Controller 类主要完成以下功能： 获取学生信息列表并返回给前端。 插入新的学生信息到数据库。 根据学生ID删除数据库中的学生信息。 根据学生ID更新数据库中的学生信息。 用户登录验证，返回结果表示登录成功或失败。 用户注册，将用户信息插入数据库。 3. 使用方法3.1. 导入项目在项目的源代码中，导入 Controller.java 文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package org.example;import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;import com.google.gson.Gson;import org.example.mapper.StudentMapper;import org.example.mapper.UserMapper;import org.example.pojo.Student;import org.example.pojo.User;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import java.util.List;@SuppressWarnings(&quot;all&quot;) // 去除所有警告@CrossOrigin(origins = &#123;&quot;*&quot;, &quot;null&quot;&#125;) // * 表示任何地方发过来的请求都能响应，解决跨域问题@RestController // 标志这个文件是一个 controller 类public class Controller &#123; @Autowired // 自动连接，通过实体类去连接数据库 private StudentMapper studentMapper; // 创建一个 StudentMapper 去定义 studentMapper 属性 @Autowired private UserMapper userMapper; private Gson gson = new Gson(); // 将查出来的数据转为字符串 // 获取所有学生信息列表并返回给前端 @GetMapping(&quot;/students&quot;) // 在 8080/students 页面下会执行下边的函数 public String getStudents() &#123; List&lt;Student&gt; students = studentMapper.selectList(null); return gson.toJson(students); // 把数据转成字符串后的列表返回给前端 &#125; // 插入新的学生信息到数据库 @PostMapping(&quot;/insert&quot;) public void insertStudent(@RequestBody Student student) &#123; studentMapper.insert(student); &#125; // 根据学生ID删除数据库中的学生信息 @PostMapping(&quot;/delete&quot;) public void deleteStudent(@RequestBody Student student) &#123; studentMapper.deleteById(student.getId()); &#125; // 根据学生ID更新数据库中的学生信息 @PostMapping(&quot;/update&quot;) public void updateStudent(@RequestBody Student student) &#123; studentMapper.updateById(student); &#125; // 用户登录验证，返回结果表示登录成功或失败 @PostMapping(&quot;/login&quot;) public String loginStudent(@RequestBody User user) &#123; QueryWrapper&lt;User&gt; userQueryWrapper = new QueryWrapper&lt;&gt;(); userQueryWrapper.setEntity(user); User userSelected = userMapper.selectOne(userQueryWrapper); if (userSelected == null) &#123; return &quot;0&quot;; // 登录失败，返回 &quot;0&quot; &#125; return &quot;1&quot;; // 登录成功，返回 &quot;1&quot; &#125; // 用户注册，将用户信息插入数据库 @PostMapping(&quot;/register&quot;) public void register(@RequestBody User user) &#123; userMapper.insert(user); &#125;&#125;//写的方法看着没错如果实现不了还没有报错，有可能是没有用autowird，没有注入他的mapper。所以在实际使用中，确保 StudentMapper 和 UserMapper 被正确注入，否则会导致无法正常连接数据库。 3.2. 注解说明 @CrossOrigin(origins = &#123;&quot;*&quot;, &quot;null&quot;&#125;): 该注解解决跨域问题，允许任何来源的请求访问。 @RestController: 标识该类为一个控制器类，处理HTTP请求并返回REST响应。 @Autowired: 自动连接到其他Spring管理的Bean。 3.3. API说明以下是 Controller 类中定义的API方法及其功能： GET /students: 获取所有学生信息列表。 POST /insert: 插入新的学生信息到数据库。 POST /delete: 根据学生ID删除数据库中的学生信息。 POST /update: 根据学生ID更新数据库中的学生信息。 POST /login: 用户登录验证，返回结果表示登录成功或失败。 POST /register: 用户注册，将用户信息插入数据库。","categories":[{"name":"项目实战","slug":"项目实战","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"},{"name":"学生管理系统","slug":"项目实战/学生管理系统","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"学生管理系统-后端2-引入pom依赖","slug":"学生管理系统-后端2-引入pom依赖","date":"2023-08-06T02:23:16.000Z","updated":"2023-08-15T07:58:56.762Z","comments":true,"path":"2023/08/06/学生管理系统-后端2-引入pom依赖/","link":"","permalink":"http://yoursite.com/2023/08/06/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E5%90%8E%E7%AB%AF2-%E5%BC%95%E5%85%A5pom%E4%BE%9D%E8%B5%96/","excerpt":"","text":"在后端开发中，Maven是一个常用的构建工具和依赖管理工具。在Maven项目中，POM（Project Object Model）文件是一个重要的配置文件，用于定义项目的基本信息、依赖关系以及构建配置。本文将解释我们将会在POM文件中所引入的各项依赖内容。 引入maven后要更新一下，然后会自动下载拟引入的maven，时间可能会比较长，耐心等待 1. 基本信息在POM文件中，&lt;groupId&gt;、&lt;artifactId&gt;和&lt;version&gt;元素定义了项目的基本信息： &lt;groupId&gt;：项目的组织或团队标识，通常使用反转的域名（类似Java包名）。 &lt;artifactId&gt;：项目的唯一标识符，通常是项目的名称。 &lt;version&gt;：项目的版本号。 123&lt;groupId&gt;com.example&lt;/groupId&gt;&lt;artifactId&gt;demo&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; 2. 依赖项12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- Maven项目描述文件，定义了项目的基本信息和依赖 --&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;!-- 指定模型版本 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 父依赖，基于Spring Boot的父项目 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- 从仓库查找父项目 --&gt; &lt;/parent&gt; &lt;!-- 项目的基本信息 --&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;!-- 定义属性 --&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;tomcat.version&gt;9.0.60&lt;/tomcat.version&gt; &lt;/properties&gt; &lt;!-- 项目构建配置 --&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- Spring Boot Maven插件，用于打包和运行Spring Boot应用 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; Spring Boot Starter Parent 依赖：这是 Spring Boot 的父依赖，它提供了一系列默认的依赖版本，使您的项目能够快速集成 Spring Boot 框架。 org.springframework.boot:spring-boot-starter-parent:2.7.0 项目基本信息：在这部分中，定义了项目的基本信息，如项目的组织、唯一标识、版本、名称和描述等。 groupId：项目的组织或团队标识。 artifactId：项目的唯一标识符，通常是项目的名称。 version：项目的版本号。 name：项目的名称。 description：项目的描述。 属性定义：在这部分中，定义了项目中所使用的一些属性，如 Java 版本和 Tomcat 版本。 java.version：Java 版本。 tomcat.version：Tomcat 版本。 &lt;dependencies&gt;元素在&lt;dependencies&gt;元素下，列出了项目所依赖的库和框架。每个&lt;dependency&gt;元素表示一个依赖项，其中包括&lt;groupId&gt;、&lt;artifactId&gt;和&lt;version&gt;元素来指定依赖的组织、库和版本号。 Spring Boot Web 依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 这个依赖用于启用 Spring Boot 的 Web 支持。它包含了许多在 Web 开发中常用的库和组件，包括 HTTP 请求处理、控制器、视图解析器等。您可以使用这个依赖来构建和处理 Web 请求以及创建 RESTful API。 Gson 依赖12345&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.5&lt;/version&gt;&lt;/dependency&gt; Gson 是 Google 提供的一个 Java 库，用于将 Java 对象和 JSON 数据进行相互转换。它使您能够在后端应用程序中轻松处理 JSON 格式的数据，例如解析 JSON 数据、将 Java 对象序列化为 JSON 等。 Lombok 依赖123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; Lombok 是一个 Java 库，它通过注解自动为您生成 Java 类的代码，从而减少了冗余的样板代码。使用 Lombok，您可以轻松地为实体类生成 getter、setter、构造方法等。&lt;scope&gt;provided&lt;/scope&gt; 表示这个依赖在编译时提供，但在运行时不会被包含在项目中。 MySQL 连接驱动依赖12345&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 这个依赖包含了 MySQL 数据库的 Java 连接驱动，使得您可以在后端应用程序中连接、查询和操作 MySQL 数据库。 MyBatis-Plus 依赖12345&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt;&lt;/dependency&gt; MyBatis-Plus 是一个在 MyBatis 框架基础上的增强工具库。它提供了更多的便捷方法和功能，用于简化数据库操作，包括 CRUD 操作、分页查询等。 Spring Boot 内嵌 Tomcat 依赖123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;version&gt;2.6.6&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 这个依赖包含了 Spring Boot 内嵌的 Tomcat 服务器。它允许您在开发和测试环境中直接运行 Web 应用程序，而无需单独安装和配置外部的 Web 服务器。 3. 总的pom文件配置这是总的pom依赖，可以直接用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- Maven项目描述文件，定义了项目的基本信息和依赖 --&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;!-- 指定模型版本 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 父依赖，基于Spring Boot的父项目 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- 从仓库查找父项目 --&gt; &lt;/parent&gt; &lt;!-- 项目的基本信息 --&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;!-- 定义属性 --&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;tomcat.version&gt;9.0.60&lt;/tomcat.version&gt; &lt;/properties&gt; &lt;!-- 项目的依赖 --&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Web依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Gson依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Lombok依赖，用于简化Java类的开发 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- MySQL连接驱动依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot整合MyBatis-Plus的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring Boot Web依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Boot内嵌Tomcat依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;version&gt;2.6.6&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 项目构建配置 --&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- Spring Boot Maven插件，用于打包和运行Spring Boot应用 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 4. 注意由于各种依赖版本问题，可能最新的会有bug，所以最好选择稳定的去使用 可以在Maven Repository: Search&#x2F;Browse&#x2F;Explore (mvnrepository.com)网站中搜索你需要的依赖，选择版本后复制maven代码过来即可。 如还有其他问题建议csdn去搜索。","categories":[{"name":"项目实战","slug":"项目实战","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"},{"name":"学生管理系统","slug":"项目实战/学生管理系统","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"学生管理系统-后端1-创建文件","slug":"学生管理系统-后端","date":"2023-08-06T01:15:04.000Z","updated":"2023-08-06T02:22:52.197Z","comments":true,"path":"2023/08/06/学生管理系统-后端/","link":"","permalink":"http://yoursite.com/2023/08/06/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E5%90%8E%E7%AB%AF/","excerpt":"","text":"概述学生管理系统的后端部分负责处理与学生信息相关的业务逻辑，包括学生信息的增加、修改、查询和删除，以及与数据库的交互。该后端使用Spring Boot框架、MyBatis-Plus作为持久层框架，以及Gson库来处理数据的序列化和反序列化。 技术栈 Spring Boot 2：用于构建后端应用程序的框架。 MyBatis-Plus：简化数据库操作的持久层框架。 Gson：处理Java对象和JSON数据之间的转换。 MySQL：用于存储学生信息的关系型数据库。 创建项目创建maven文件 创建路径，我这里用back 项目目录，照着这个来建 在一个典型的Maven项目中，各个文件夹和目录有不同的作用，用于组织和管理项目的不同部分。以下是一个后端Maven项目中各个文件夹的一般作用说明： src&#x2F;main&#x2F;java: 这是项目的主要Java源代码目录，包含了项目的所有Java源代码文件。您的应用程序的主要逻辑和功能将在这个目录下的包和类中实现。 src&#x2F;main&#x2F;resources: 这个目录包含项目的资源文件，例如配置文件、静态文件、模板文件等。这些文件通常在运行时被读取和使用。 src&#x2F;test&#x2F;java: 这是项目的测试代码目录，包含了用于单元测试和集成测试的Java源代码文件。测试可以帮助您验证代码的正确性和稳定性。 src&#x2F;test&#x2F;resources: 这个目录包含了测试所需的资源文件，例如测试配置文件、测试数据等。 target: 这是Maven构建过程的输出目录，包含了编译后的Java类文件、打包后的可执行文件等。在构建过程中，Maven会将生成的文件放在这个目录下。 pom.xml: 这是项目的核心配置文件，用于指定项目的元数据、依赖项、构建配置等信息。Maven根据这个文件来管理项目的构建和依赖关系。","categories":[{"name":"项目实战","slug":"项目实战","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"},{"name":"学生管理系统","slug":"项目实战/学生管理系统","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"学生管理系统-简介","slug":"学生管理系统-简介","date":"2023-08-06T00:38:48.000Z","updated":"2023-08-06T01:13:28.139Z","comments":true,"path":"2023/08/06/学生管理系统-简介/","link":"","permalink":"http://yoursite.com/2023/08/06/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E7%AE%80%E4%BB%8B/","excerpt":"","text":"学生管理系统 项目预览 项目概述本学生管理系统是一个基于java和vue实现的，通过连接数据库实现对数据的增删改查。是一个比较简单的Java项目。 项目简介 前端 Vue2: Vue.js是一个流行的JavaScript前端框架，用于构建用户界面和单页应用程序。它具有响应式数据绑定和组件化架构，使得开发复杂的Web应用变得更加简单和高效。 Vue.js - 渐进式 JavaScript 框架 | Vue.js (vuejs.org) element-ui: Element UI是一个基于Vue.js的UI组件库，提供了一套美观、易于使用的UI组件，可以帮助开发人员快速构建各种Web界面。 Element - 网站快速成型工具 bootstrap5: Bootstrap是一个流行的HTML、CSS和JavaScript框架，用于构建响应式和现代化的Web界面。Bootstrap 5是最新版本，提供了丰富的样式和组件。 Get started with Bootstrap · Bootstrap v5.3 (getbootstrap.com) axios: Axios是一个用于在浏览器和Node.js中发送HTTP请求的JavaScript库，它可以帮助前端应用与后端服务器进行数据通信。 起步 | Axios 中文文档 | Axios 中文网 (axios-http.cn) 后端 springboot2: Spring Boot是一个用于简化Spring应用程序开发的框架，它提供了自动配置和快速开发的特性，使得构建后端服务变得更加简单和高效。 mybatis-plus: MyBatis-Plus是MyBatis框架的增强工具，它简化了数据库访问层的开发，提供了更多的便利和功能，如自动生成SQL、分页查询等。 Gson: Gson是Google提供的一个用于在Java对象和JSON数据之间进行序列化和反序列化的库，它可以帮助将Java对象转换为JSON格式，或者将JSON数据解析为Java对象 数据库 mysql: MySQL是一个开源的关系型数据库管理系统，广泛用于存储和管理结构化数据。它支持多用户、多线程，并且具有高性能和可靠性。 开发工具 社区版idea: 这可能是指JetBrains开发的IntelliJ IDEA，它是一个强大的集成开发环境（IDE），主要用于Java开发，但也支持其他编程语言和技术。 vs: 这可能指的是Microsoft的Visual Studio系列，其中包括Visual Studio Code（VS Code）和Visual Studio IDE。VS Code是一个轻量级的开源代码编辑器，适用于多种编程语言和框架。Visual Studio IDE则是一个更全功能的集成开发环境，主要用于Windows应用程序开发。 想要实现项目默认你具有H5，C3、JS、java、面向对象基础、mysql相关基础，其实也不难。","categories":[{"name":"项目实战","slug":"项目实战","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"},{"name":"学生管理系统","slug":"项目实战/学生管理系统","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"数据结构与算法","slug":"数据结构与算法","date":"2023-07-17T07:24:40.000Z","updated":"2023-08-18T12:58:32.094Z","comments":true,"path":"2023/07/17/数据结构与算法/","link":"","permalink":"http://yoursite.com/2023/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","excerpt":"","text":"第一章（数据结构和算法）数据结构 官方定义-没有统一 解决问题的方法效率，跟数据的组织方式有关 空间的使用 解决问题的方法效率，跟空间的利用率有关 算法的效率 解决问题的方法效率，跟算法的巧妙程度有关 抽象数据类型 算法 定义 1.一个有限指令集 2.接收一些输入 3.产生输出 4.在一定有限步骤后结束 5.每一条指令必须有充分明确的目标，不可以有歧义，在计算机处理范围内，描述不依赖于任何一种计算机语言以及具体的实现手段 算法的好坏 时间复杂度S（n）和空间复杂度T（n) 最坏情况复杂度T worst (n) 平均复杂度T avg (n) Tworst(n)&gt;&#x3D;Tavg(n 复杂度分析 复杂度分析的一些小窍门 T(n)是表示算法的时间复杂度。 O(n)是一种表示算法复杂度的符号,例如，T(n) &#x3D; O(n^2)表示算法的时间复杂度为n的平方。 f(n)”在算法复杂度分析中通常用来表示函数关于输入规模n的增长率,f(n)”可以是一个具体的函数,也可以是一个泛指的函数。 第二章(线性表 堆栈 队列)线性表 多项式表示 顺序储存结构直接表示 顺序储存结构表示非零项 每个多项式可以看成系数和指数二元组的集合 链式结构储存非零项 链表中每个节点储存一个非零项，每个节点包括两个数据域和一个指针域 coef expon link 系数 指数 next，指向下一个结构 123456789// 多项式结点的指针类型，用于表示一个多项式typedef struct PolyNode *Polynomial;// 多项式结点的定义struct PolyNode&#123; int cofe; // 系数（coefficient）：表示项的常数系数 int expon; // 指数（exponent）：表示项的幂次 Polynomial link; // 指向下一个项的指针（用于构建链表结构）&#125;; 链表的储存形式为： 线性表顺序储存 线性表是由同类型数据元素构成有序序列的线性集合 表中元素个数成为线性表的长度 表中若无元素，称之为空表 表中的起始位置称为表头，结束位置称为表尾 ​ 线性表的抽象数据类型描述 线性表利用数组连续存储空间的顺序存放线性表的各元素 123456789101112// 定义一个名为 List 的指向结构体 LNode 的指针类型typedef struct LNode* List;// 定义结构体 LNode，表示线性表struct LNode&#123; ElementType Data[Maxsize]; // ElementType 可以是任何你想存储的数据类型 int Last; // Last 表示线性表的最后一个元素的索引&#125;;// 声明一个结构体 LNode 类型的变量 L，用于创建线性表struct LNode L;// 声明一个 List 类型的指针变量 Ptrl，用于指向线性表的头节点List Ptrl; 访问下表为i的元素方法为：L.Data[i]或者PtrL-&gt;Data[i]线性表的长度为L.last+1或者PtrL-&gt;Last+1 初始化 12345678910111213// 函数名：MakeEmpty// 功能：创建一个空的线性表，并返回指向线性表头节点的指针// 返回值：返回指向线性表头节点的指针 ListList MakeEmpty()&#123; List PtrL; // 声明一个 List 类型的指针变量 PtrL，用于指向线性表的头节点 // 使用 malloc 分配内存来创建一个新的线性表头节点，并将其地址赋值给 PtrL PtrL = (List)malloc(sizeof(struct LNode)); // 初始化线性表，将 Last 设置为 -1，表示当前线性表为空 PtrL-&gt;Last = -1; // 返回指向新创建线性表头节点的指针 return PtrL;&#125; 查找 1234567891011121314151617181920// 函数名：Find// 功能：在线性表 PtrL 中查找元素 X 的位置// 参数：// - ElementType X: 要查找的元素// - List PtrL: 指向线性表头节点的指针// 返回值：// - 成功找到元素 X 返回其在线性表中的位置（索引），从 0 开始// - 没有找到元素 X 返回 -1int Find(ElementType X, List PtrL)&#123; int i = 0; // 初始化计数器 i，用于遍历线性表中的元素 // 循环遍历线性表，查找元素 X while (i &lt;= PtrL-&gt;Last &amp;&amp; PtrL-&gt;Data[i] != X) i++; // 若找到元素 X，则返回其在线性表中的位置（索引） if (i &gt; PtrL-&gt;Last) return -1; // 没有找到元素 X，返回 -1 else return i; // 成功找到元素 X，返回其位置（索引）&#125; 顺序储存的插入和删除 插入（在i的位置上插入一个值为X的元素（1&lt;&#x3D;i&lt;&#x3D;n+1) 先移动再插入 123456789101112131415161718192021222324252627282930313233// 函数名：Insert// 功能：向线性表 PtrL 中的第 i 个位置插入元素 X// 参数：// - ElementType X: 要插入的元素// - int i: 要插入的位置（索引），从 1 开始// - List PtrL: 指向线性表头节点的指针// 返回值：无void Insert(ElementType X, int i, List PtrL)&#123; int j; // 定义临时变量 j，用于循环中的计数 // 判断线性表是否已满，如果已满则无法插入元素 if (PtrL-&gt;Last == MAXSIZE - 1)//通过比较线性表的最后一个元素索引 Last 和线性表的最大容量 MAXSIZE-1 来判断线性表是否已满。 &#123; printf(&quot;该表已满&quot;); return; &#125; // 判断插入位置 i 是否合法 if (i &gt;= PtrL-&gt;Last + 2 || i &lt; 1)//检查插入位置 i 是否合法，不能超过当前线性表长度加 1，且不能小于 1。 &#123; printf(&quot;位置不合法&quot;); return; &#125; // 从后往前遍历线性表，将第 i 个位置及其后的元素都往后移动一个位置 for (j = PtrL-&gt;Last; j &gt;= i - 1; j--) &#123; PtrL-&gt;Data[j + 1] = PtrL-&gt;Data[j]; &#125; // 将元素 X 插入到第 i 个位置 // 注意：由于数组下标从 0 开始，而 i 从 1 开始计数，所以插入位置应为 i-1 PtrL-&gt;Data[i - 1] = X; // 更新线性表的最后一个元素的索引，将 Last 加 1，使其指向最后一个元素 PtrL-&gt;Last++;&#125; 删除操作(删除第i个元素）后面元素依次向前移动 123456789101112131415161718192021222324// 函数名：Delete// 功能：删除线性表 PtrL 中的第 i 个位置上的元素// 参数：// - int i: 要删除的位置（索引），从 1 开始// - List PtrL: 指向线性表头节点的指针// 返回值：无void Delete(int i, List PtrL)&#123; int j; // 定义临时变量 j，用于循环中的计数 // 检查插入位置 i 是否合法 if (i &gt;= PtrL-&gt;Last + 2 || i &lt; 1) &#123; printf(&quot;不存在第%d个元素&quot;, i); return; &#125; // 从第 i 个位置开始，将后面的元素依次往前移动一个位置 for (j = i; j &lt;= PtrL-&gt;Last; j++) &#123; PtrL-&gt;Data[j - 1] = PtrL-&gt;Data[j]; &#125; // 更新线性表的最后一个元素的索引，将 Last 减 1，表示删除了一个元素 PtrL-&gt;Last--; return;&#125; 链式储存和查找 链式储存解决了线性整体移动的问题，不要求逻辑上相邻的两个元素物理上也相邻，通过链建立数据元素之间的逻辑关系 插入删除不需要移动数据元素，只需要修改“链” 123456789101112// 定义指向结构体 LNode 的指针类型 Listtypedef struct LNode *List;// 定义结构体 LNode，表示链表节点struct LNode&#123; ElementType Data; // 存储节点的数据，ElementType 可以是任何你希望存储的数据类型 List Next; // 指向下一个节点的指针&#125;;// 声明一个结构体 LNode 类型的变量 L，用于创建链表的头节点struct LNode L;// 声明一个 List 类型的指针变量 PtrL，用于指向链表的头节点List PtrL; 求表长 12345678910111213141516171819// 函数名：Length// 功能：计算链表 PtrL 的长度（节点个数）// 参数：// - List PtrL: 指向链表头节点的指针// 返回值：链表的长度（节点个数）int Length(List PtrL)&#123; // 令 p 指向表的第一个节点，即头节点之后的第一个实际节点 List p = PtrL-&gt;Next; int j = 0; // 初始化计数器 j，用于记录节点个数 // 循环遍历链表，直到到达链表的结尾 while (p) &#123; p = p-&gt;Next; // 移动到下一个节点 j++; // 计数器 j 自增，记录节点个数 &#125; return j; // 返回计数器 j，即为链表的长度&#125; 查找 按序号查找 123456789101112131415161718192021222324// 函数名：Findkth// 功能：在链表 PtrL 中查找第 k 个节点// 参数：// - int k: 要查找的节点位置（索引），从 1 开始计数// - List PtrL: 指向链表头节点的指针// 返回值：// - 如果找到第 k 个节点，返回指向该节点的指针// - 如果没有找到第 k 个节点或链表为空，返回 NULLList Findkth(int k, List PtrL)&#123; List p = PtrL; // 令 p 指向链表的头节点 int i = 1; // 初始化计数器 i，用于记录当前节点的位置（索引） // 循环遍历链表，查找第 k 个节点或链表的结尾 while (p != NULL &amp;&amp; i &lt; k) &#123; p = p-&gt;Next; // 移动到下一个节点 i++; // 计数器 i 自增，记录当前节点的位置（索引） &#125; // 如果找到第 k 个节点，则返回指向该节点的指针 p if (i == k) return p; else return NULL; // 没有找到第 k 个节点或链表为空，返回 NULL&#125; 按值查找 // 函数名：Find // 功能：在链表 PtrL 中查找元素 X 的节点 // 参数： // - ElementType X: 要查找的元素 // - List PtrL: 指向链表头节点的指针 // 返回值： // - 如果找到元素 X 的节点，返回指向该节点的指针 // - 如果没有找到元素 X 或链表为空，返回 NULL List Find(ElementType X, List PtrL) &#123; List p = PtrL; // 令 p 指向链表的头节点 // 循环遍历链表，查找元素 X 的节点或链表的结尾 while (p != NULL &amp;&amp; p-&gt;Data != X) p = p-&gt;Next; // 移动到下一个节点 // 如果找到元素 X 的节点，则返回指向该节点的指针 p // 如果没有找到元素 X 或链表为空，则返回 NULL return p; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525. #### 链式储存的插入和删除- 插入操作（在第i个结点位置上插入一个值为X的新结点，换句话说就是在第i-1个结点后插入一个值为X的新节点） - 构造一个新结点用s指 - 找到链表的第i-1个结点，用p指 - 修改指针 ```c // 函数名：Insert // 功能：向链表 PtrL 的第 i 个位置插入元素 X // 参数： // - ElementType X: 要插入的元素 // - int i: 要插入的位置（索引），从 1 开始 // - List PtrL: 指向链表头节点的指针 // 返回值：返回指向链表头节点的指针 List Insert(ElementType X, int i, List PtrL) &#123; List p, s; // 在链表头插入元素 if (i == 1) &#123; // 申请一个新的节点 s s = (List)malloc(sizeof(struct LNode)); s-&gt;Data = X; s-&gt;Next = PtrL; // 返回指向新头节点 s 的指针，即链表的新头指针 return s; &#125; // 在其他位置插入元素 // 此处查找的节点为第 i-1 个节点 p = Findkth(i - 1, PtrL); // 如果第 i-1 个节点不存在 if (p == NULL) &#123; printf(&quot;参数出错&quot;); return NULL; &#125; else &#123; // 申请一个新的节点 s s = (List)malloc(sizeof(struct LNode)); s-&gt;Data = X; // 将新节点 s 插入到第 i-1 个节点后面 s-&gt;Next = p-&gt;Next; p-&gt;Next = s; // 返回原链表的头指针 PtrL，表示链表没有改变头节点 return PtrL; &#125; &#125; ![](https://cdn.jsdelivr.net/gh/artly1/Image/202307171636241.png) ​ 删除操作（删除第i个结点）（1&lt;&#x3D;i&lt;&#x3D;n) 先找到第i-1个结点，用p指向 然后用s指针指向第i个结点，即为p结点的下一个结点 修改指针，删除s所指向的结点 最后释放s所指向结点的空间free 12345678910111213141516171819202122232425262728293031323334353637383940414243// 函数名：Delete// 功能：删除链表 PtrL 中的第 i 个节点// 参数：// - int i: 要删除的节点位置（索引），从 1 开始// - List PtrL: 指向链表头节点的指针// 返回值：返回指向链表头节点的指针List Delete(int i, List PtrL)&#123; List p, s; // 删除头节点 if (i == 1) &#123; s = PtrL; // 如果链表不为空，将头指针后移一位 if (PtrL != NULL) PtrL = PtrL-&gt;Next; else return NULL; // 链表为空，返回空指针 free(s); // 释放原头节点的内存 return PtrL; // 返回新的头指针 &#125; // 删除其他位置的节点 // 查找第 i-1 个节点，即要删除位置的前一个节点 p = Findkth(i - 1, PtrL); // 如果第 i-1 个节点不存在 if (p == NULL) &#123; printf(&quot;第%d个结点不存在&quot;, i - 1); return NULL; &#125; else if (p-&gt;Next == NULL) &#123; printf(&quot;第%d个结点不存在&quot;, i); return NULL; &#125; else &#123; s = p-&gt;Next; // s 指向第 i 个节点 p-&gt;Next = s-&gt;Next; // 删除操作，将第 i-1 个节点的指针域 Next 指向第 i+1 个节点 free(s); // 释放第 i 个节点的内存 return PtrL; // 返回原链表的头指针 PtrL &#125;&#125; 广义表和多重链表一元多项式可以用上述式子表示，二元多项式又该如何表示？ 广义表是线性表的推广 对于线性表来说，n个元素都是基本的单元素 广义表中，这些元素不仅是单元素也可以是另一个广义表 12345678910111213// 定义指向结构体 GNode 的指针类型 GListtypedef struct GNode *GList;// 定义结构体 GNode，表示广义表的节点struct GNode&#123; int Tag; // 标志域，0 表示结点是单元素，1 表示结点是广义表 union//union：这是一个联合体，它是一种特殊的数据结构，允许在相同的内存位置存储不同类型的数据。在这里，union 中包含了两个成员：ElementType Data 和 GList Sublist。Data 用于存储单元素的数据，Sublist 用于存储子广义表的指针。 &#123; ElementType Data; // 数据域 Data，用于存储单元素数据 GList Sublist; // 指针域 Sublist，用于存储子广义表的指针 &#125; URegion; // 联合体，数据域 Data 和指针域 Sublist 复用存储空间 GList Next; // 指向后继结点的指针&#125;; 多重链表多重链表中的结点属于多个链 多重链表中的结点指针域有很多， 但是包含两个指针域的链表并不一定是多重链表， 比如双向链表不是多重链表 多重链表可以用在树和图中实现存储 堆栈什么是堆栈? 堆栈是具有一定操作约束的线性表，只在一端做插入，删除Last In First Out（LIFO）后入先出 中缀表达式：运算符位于两个数字之间 后缀表达式：运算符位于两个数字之后 抽象数据类型 原理图 堆栈的顺序存储栈的顺序存储结构通常是由一个一维数组和一个记录栈顶元素位置的变量组成 12345678910// 定义存储数据元素的最大值#define Maxsize &lt;存储数据元素的最大值&gt;// 定义指向结构体 SNode 的指针类型 Stacktypedef struct SNode *Stack;// 定义结构体 SNode，表示栈struct SNode&#123; ElementType Data[Maxsize]; // 用于存储数据元素的数组，数组大小为 Maxsize int Top; // 栈顶指针，表示栈顶元素在数组中的索引&#125;; 入栈 1234567891011121314151617181920// 函数名：Push// 功能：将元素 item 入栈// 参数：// - Stack PtrL: 指向栈的指针// - ElementType item: 要入栈的元素// 返回值：无void Push(Stack PtrL, ElementType item)&#123; // 检查栈是否已满 if (PtrL-&gt;Top == Maxsize - 1) &#123; printf(&quot;堆栈满&quot;); // 输出错误信息，表示栈已满 return; &#125; else &#123; PtrL-&gt;Data[++(PtrL-&gt;Top)] = item; // 将元素 item 入栈，栈顶指针 Top 自增 return; &#125;&#125; 出栈 123456789101112131415161718// 函数名：Pop// 功能：将栈顶元素出栈，并返回该元素的值// 参数：// - Stack PtrL: 指向栈的指针// 返回值：返回栈顶元素的值，如果栈为空，返回 ERROR（出错值）ElementType Pop(Stack PtrL)&#123; // 检查栈是否为空 if (PtrL-&gt;Top == -1) &#123; printf(&quot;堆栈空&quot;); // 输出错误信息，表示栈为空 return ERROR; // 返回 ERROR（出错值） &#125; else &#123; return (PtrL-&gt;Data[(PtrL-&gt;Top)--]); // 将栈顶元素出栈，并返回该元素的值，栈顶指针 Top 自减 &#125;&#125; 用数组实现两个堆栈，最大利用数组空间，若有空间则可以实现入栈 两个栈分别从数组的两头开始向中间生长，当两个栈的栈顶指针相遇时，表示两个栈都已经满 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 定义存储数据元素的最大个数#define MaxSize &lt;存储数据元素的最大个数&gt;// 定义结构体 DoubleStack，表示双栈struct DoubleStack &#123; ElementType Data[MaxSize]; // 用于存储数据元素的数组，数组大小为 MaxSize int Top1; // 栈1的栈顶指针 int Top2; // 栈2的栈顶指针&#125;;// 创建一个双栈 S，同时初始化栈1的栈顶指针 Top1 为 -1，栈2的栈顶指针 Top2 为 MaxSizestruct DoubleStack S;S.Top1 = -1;S.Top2 = MaxSize;// 函数名：Push// 功能：将元素 item 入栈// 参数：// - struct DoubleStack *PtrS: 指向双栈的指针// - ElementType item: 要入栈的元素// - int Tag: 表示入栈到哪个栈，Tag=1 表示栈1，Tag=2 表示栈2// 返回值：无void Push(struct DoubleStack *PtrS, ElementType item, int Tag) &#123; // 检查栈是否已满 if (PtrS-&gt;Top2 - PtrS-&gt;Top1 == 1) &#123; printf(&quot;堆栈满&quot;); // 输出错误信息，表示双栈已满 return; &#125; // 判断入栈到哪个栈，Tag=1 表示栈1，Tag=2 表示栈2 if (Tag == 1) PtrS-&gt;Data[++(PtrS-&gt;Top1)] = item; // 将元素 item 入栈到栈1，栈1的栈顶指针 Top1 自增 else PtrS-&gt;Data[--(PtrS-&gt;Top2)] = item; // 将元素 item 入栈到栈2，栈2的栈顶指针 Top2 自减&#125;// 函数名：Pop// 功能：将栈顶元素出栈，并返回该元素的值// 参数：// - struct DoubleStack *PtrS: 指向双栈的指针// - int Tag: 表示出栈哪个栈，Tag=1 表示栈1，Tag=2 表示栈2// 返回值：返回栈顶元素的值，如果栈为空，返回 NULL（出错值）ElementType Pop(struct DoubleStack *PtrS, int Tag) &#123; // 判断出栈哪个栈，Tag=1 表示栈1，Tag=2 表示栈2 if (Tag == 1) &#123; // 检查栈1是否为空 if (PtrS-&gt;Top1 == -1) &#123; printf(&quot;堆栈1空&quot;); // 输出错误信息，表示栈1为空 return NULL; // 返回 NULL（出错值） &#125; else return PtrS-&gt;Data[(PtrS-&gt;Top1)--]; // 将栈1的栈顶元素出栈，并返回该元素的值，栈1的栈顶指针 Top1 自减 &#125; else &#123; // 检查栈2是否为空 if (PtrS-&gt;Top2 == MaxSize) &#123; printf(&quot;堆栈空&quot;); // 输出错误信息，表示栈2为空 return NULL; // 返回 NULL（出错值） &#125; else return PtrS-&gt;Data[(PtrS-&gt;Top2)++]; // 将栈2的栈顶元素出栈，并返回该元素的值，栈2的栈顶指针 Top2 自增 &#125;&#125; 堆栈的链式存储 链式存储结构实际上就是一个单链表，叫做链栈，插入和删除操作只能在链栈的栈顶进行 12345678// 定义指向结构体 SNode 的指针类型 Stacktypedef struct SNode *Stack;// 定义结构体 SNode，表示栈节点struct SNode &#123; ElementType Data; // 数据域，用于存储栈节点的数据元素 struct SNode *Next; // 指针域，指向下一个栈节点的指针&#125;; 初始化 12345678910111213// 函数名：CreatStack// 功能：创建一个空栈，并返回指向栈顶节点的指针// 参数：无// 返回值：返回指向栈顶节点的指针Stack CreatStack()&#123; Stack s; // 声明一个指向栈节点的指针 s // 分配内存，创建一个栈节点 s = (Stack)malloc(sizeof(struct SNode)); // 初始化栈节点的指针域 Next 为 NULL，表示栈为空 s-&gt;Next = NULL; return s; // 返回指向栈顶节点的指针&#125; 判断堆栈s是否为空 1234int Empty(Stack s)&#123; return (s-&gt;Next == NULL);&#125; 入栈 1234567891011121314151617// 函数名：Push// 功能：将元素 item 入栈// 参数：// - ElementType item: 要入栈的元素// - Stack s: 指向栈顶节点的指针// 返回值：无void Push(ElementType item, Stack s)&#123; // 创建一个新的栈节点 struct SNode *Tmpcell; Tmpcell = (struct SNode *)malloc(sizeof(struct SNode)); // 设置新栈节点的数据域 Element 为要入栈的元素 item Tmpcell-&gt;Element = item; // 将新栈节点插入到栈顶节点之后 Tmpcell-&gt;Next = s-&gt;Next; s-&gt;Next = Tmpcell;&#125; 出栈 12345678910111213141516171819202122232425// 函数名：Pop// 功能：将栈顶元素出栈，并返回该元素的值// 参数：// - Stack s: 指向栈顶节点的指针// 返回值：返回栈顶元素的值，如果栈为空，返回 NULL（出错值）ElementType Pop(Stack s)&#123; struct SNode *Firstcell; // 声明一个指向栈节点的指针 Firstcell，用于暂存要出栈的栈顶节点 ElementType TopElement; // 声明一个变量 TopElement，用于存储要出栈的栈顶元素 // 检查栈是否为空 if (Empty(s)) &#123; printf(&quot;堆栈空&quot;); // 输出错误信息，表示栈为空 return NULL; // 返回 NULL（出错值） &#125; else &#123; // 将栈顶节点出栈，注意保存要删除的元素和栈顶元素 Firstcell = s-&gt;Next; // Firstcell 指向要删除的栈顶节点 s-&gt;Next = Firstcell-&gt;Next; // 将栈顶指针 Next 指向删除节点的下一个节点，即出栈操作 TopElement = Firstcell-&gt;Element; // 将要出栈的栈顶元素存储到 TopElement 中 free(Firstcell); // 释放删除的节点的内存，即释放栈顶节点的内存 return TopElement; // 返回栈顶元素的值 &#125;&#125; 堆栈的应用 中缀表达式转换为后缀表达式 运算数：直接输出 左括号：入栈 右括号：栈顶元素出栈并输出，直到遇到左括号 运算符：优先级大于栈顶运算符，入栈；优先级小于等于栈顶运算符出栈输出，继续比较新的栈顶运算符 处理完毕后，将堆栈剩余元素一并输出 队列 队列及顺序存储具有一定操作约束的线性表 插入和删除操作：只能在一端插入，而在另一端删除 数据插入：入队列 数据删除：出队列 先进先出（FIFO）First In First Out 抽象数据描述 队列存储的实现 队列的顺序存储结构通常由一个一维数组和一个记录队列头元素位置的变量ront以及一个记录队列尾元素位置的变量rear组成 1234567891011// 定义存储数据元素的最大个数#define Maxsize &lt;数据元素的最大个数&gt;// 定义队列结构体 QNodestruct QNode &#123; ElementType Data[Maxsize]; // 用于存储数据元素的数组，数组大小为 Maxsize int rear; // 队尾指针，指向队列最后一个元素的下标 int front; // 队首指针，指向队列第一个元素之前的位置&#125;;// 定义指向队列结构体 QNode 的指针类型 Queuetypedef struct QNode *Queue;// front 指的是第一个元素之前的位置 在顺环队列判断是否满的问题上使用额外标记Tag域或者Size 入队 1234567891011121314151617// 函数名：AddQ// 功能：向队列尾部添加元素// 参数：// - Queue PtrL: 指向队列的指针// - ElementType item: 要添加的元素// 返回值：无void AddQ(Queue PtrQ, ElementType item)&#123; // 检查队列是否已满 if ((PtrQ-&gt;rear + 1) % Maxsize == PtrQ-&gt;front) &#123; printf(&quot;队列满&quot;); // 输出错误信息，表示队列已满 return; // 返回，不执行入队操作 &#125; // 将队尾指针后移一位，考虑循环队列的情况 PtrQ-&gt;rear = (PtrQ-&gt;rear + 1) % Maxsize; 出队 123456789101112131415161718192021// 函数名：DQ// 功能：从队列头部删除元素，并返回该元素的值// 参数：// - Queue PtrQ: 指向队列的指针// 返回值：返回队列头部元素的值，如果队列为空，返回 ERROR（出错值）ElementType DQ(Queue PtrQ)&#123; // 检查队列是否为空 if (PtrQ-&gt;rear == PtrQ-&gt;front) &#123; printf(&quot;队列空&quot;); // 输出错误信息，表示队列为空 return ERROR; // 返回 ERROR（出错值） &#125; else &#123; // 将队首指针后移一位，考虑循环队列的情况 PtrQ-&gt;front = (PtrQ-&gt;front + 1) % Maxsize; // 返回队列头部元素的值 return PtrQ-&gt;Data[PtrQ-&gt;front]; &#125;&#125; 队列的链式存储1234567891011121314// 定义链式队列节点结构体 Nodestruct Node &#123; ElementType Data; // 数据域，用于存储节点的数据元素 struct Node *Next; // 指针域，指向下一个节点的指针&#125;;// 定义链式队列结构体 QNodestruct QNode &#123; struct Node *rear; // 队尾指针，指向队列中最后一个元素的节点 struct Node *front; // 队首指针，指向队列中第一个元素的节点&#125;;// 定义指向链式队列结构体 QNode 的指针类型 Queuetypedef struct QNode *Queue;// 声明一个指向链式队列结构体 QNode 的指针 PtrQQueue PtrQ; 出队 12345678910111213141516171819202122232425262728// 函数名：DQ// 功能：从队列头部删除元素，并返回该元素的值// 参数：// - Queue PtrQ: 指向链式队列的指针// 返回值：返回队列头部元素的值，如果队列为空，返回 ERROR（出错值）ElementType DQ(Queue PtrQ)&#123; struct Node *Frontcell; // 声明一个指向链式队列节点的指针 Frontcell，用于暂存要出队的节点 ElementType Frontelement; // 声明一个变量 Frontelement，用于存储要出队的队列头部元素 // 检查队列是否为空 if (PtrQ-&gt;front == NULL) &#123; printf(&quot;空&quot;); // 输出错误信息，表示队列为空 return ERROR; // 返回 ERROR（出错值） &#125; // 将队首节点出队 Frontcell = PtrQ-&gt;front; // Frontcell 指向要出队的队列头部节点 // 分情况讨论，队列只有一个元素和多个元素 if (PtrQ-&gt;front == PtrQ-&gt;rear) PtrQ-&gt;front = PtrQ-&gt;rear = NULL; // 如果队列只有一个元素，出队后将队首指针和队尾指针都设置为 NULL，表示队列为空 else PtrQ-&gt;front = PtrQ-&gt;front-&gt;Next; // 如果队列有多个元素，将队首指针后移，即将第二个节点设置为队首节点 Frontelement = Frontcell-&gt;Data; // 将要出队的队列头部元素存储到 Frontelement 中 free(Frontcell); // 释放出队的节点的内存，即释放队列头部节点的内存 return Frontelement; // 返回队列头部元素的值，表示成功出队&#125; 多项式问题 加法运算的实现采用不带头结点的单项链表。按照指数递减的顺序排列各项 1234567struct PolyNode&#123; int coef;//系数 int expon;//指数 struct PolyNode *link;&#125;;typedef struct PolyNode *Polynomial;Polynomial P1,P2; 算法思路P1-&gt;expon&#x3D;&#x3D;P2-&gt;expon:系数相加，若结果不为0，则作为结果多项式对应系数。同时，P1和P2 都指向下一项P1-&gt;expon&gt;P2-&gt;expon将P1存入当前多项式，并使P1指向下一项P1-&gt;expon &lt; P2-&gt;expon将P2存入当前多项式，并使P2指向下一项 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 函数名：Polynomial Polyadd(Polynomial P1, Polynomial P2)// 功能：多项式相加// 参数：// - Polynomial P1: 第一个多项式的头结点指针// - Polynomial P2: 第二个多项式的头结点指针// 返回值：返回多项式相加后的结果多项式的头结点指针Polynomial Polyadd(Polynomial P1, Polynomial P2)&#123; Polynomial front, rear, temp; int sum; rear = (Polynomial)malloc(sizeof(struct PolyNode)); front = rear; // front 这里指的是多项式链表头结点 while (P1 &amp;&amp; P2) &#123; switch (Compare(P1-&gt;expon, P2-&gt;expon)) &#123; case 1: Attach(P1-&gt;coef, P1-&gt;expon, &amp;rear); P1 = P1-&gt;link; break; case -1: Attach(P2-&gt;coef, P2-&gt;expon, &amp;rear); P2 = P2-&gt;link; break; case 0: sum = P1-&gt;coef + P2-&gt;coef; if (sum) Attach(sum, P1-&gt;expon, &amp;rear); P1 = P1-&gt;link; P2 = P2-&gt;link; break; &#125; &#125; // 还有未处理完的另一个多项式的所有结点依此复制 for (; P1; P1 = P1-&gt;link) Attach(P1-&gt;coef, P1-&gt;expon, &amp;rear); for (; P2; P2 = P2-&gt;link) Attach(P2-&gt;coef, P2-&gt;expon, &amp;rear); rear-&gt;link = NULL; // 将链表最后一个节点的 next 指针置为 NULL，表示链表结束 temp = front; front = front-&gt;link; // 头结点的下一个节点即为结果多项式的头结点 free(temp); // 释放头结点的内存，防止内存泄漏 return front; // 返回结果多项式的头结点指针&#125;// 函数名：void Attach(int c, int e, Polynomial *pRear)// 功能：将系数为 c，指数为 e 的节点添加到链表中// 参数：// - int c: 系数值// - int e: 指数值// - Polynomial *pRear: 链表尾节点的指针的指针，用于更新链表尾节点// 返回值：无void Attach(int c, int e, Polynomial *pRear)&#123; Polynomial P; P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;coef = c; P-&gt;expon = e; P-&gt;link = NULL; (*pRear)-&gt;link = P; *pRear = P; // 修改 pRear 值，使其指向链表尾部节点，以便下次添加节点时可以直接在尾部插入&#125; 题意理解与多项式表示 数据结构设计 12345678910111213// 定义多项式结点指针类型 Polynomial，是指向 struct PolyNode 结构体的指针typedef struct PolyNode *Polynomial;// 定义多项式结点结构体 PolyNodestruct PolyNode&#123; int coef; // 系数，用于存储多项式项的系数值 int expon; // 指数，用于存储多项式项的指数值 Polynomial link; // 指向下一个多项式结点的指针，用于将多项式的各项连接在一起&#125;;// 这个代码片段定义了一个简单的链式存储结构用于表示多项式。// 多项式的每一项包含两个部分：系数 coef 和指数 expon。// 用链表将各项连接在一起，每个节点通过 link 指针指向下一个节点。// 多项式的头结点可以用 Polynomial 类型的指针来表示，即指向第一个多项式节点的指针。 程序框架及读入多项式 123456789101112131415161718192021// 函数名：main// 功能：主函数，用于调用多项式相关函数// 返回值：整数类型，表示程序的结束状态int main()&#123; // 声明多项式 P1, P2, PP, PS Polynomial P1, P2, PP, PS; // 读入第一个多项式 P1 P1 = ReadPoly(); // 读入第二个多项式 P2 P2 = ReadPoly(); // 将两个多项式 P1 和 P2 相乘，结果存储在 PP 中 PP = Mult(P1, P2); // 打印相乘结果多项式 PP PrintPoly(PP); // 将两个多项式 P1 和 P2 相加，结果存储在 PS 中 PS = Add(P1, P2); // 打印相加结果多项式 PS PrintPoly(PS); return 0; // 返回程序的结束状态，表示成功执行&#125; 读取多项式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 函数名：Polynomial ReadPoly()// 功能：读取一个多项式，并以链表形式返回该多项式的头结点指针// 返回值：多项式的头结点指针Polynomial ReadPoly()&#123; // 声明多项式头结点指针 P, Rear 和临时指针 t Polynomial P, Rear, t; int c, e, N; // 从标准输入读取多项式的项数 N scanf(&quot;%d&quot;, &amp;N); // 创建链表头空结点 P，Rear 指向头结点 P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;link = NULL; Rear = P; // 依次读入 N 个多项式项，并将其插入链表尾部 while (N--) &#123; scanf(&quot;%d %d&quot;, &amp;c, &amp;e); Attach(c, e, &amp;Rear); // 将当前项插入多项式尾部 &#125; // 删除临时生成的头结点，并将链表的真正头结点指针 P 返回 t = P; P = P-&gt;link; free(t); return P;&#125;// 函数名：void Attach(int c, int e, Polynomial *pRear)// 功能：将系数为 c，指数为 e 的节点添加到链表中// 参数：// - int c: 系数值// - int e: 指数值// - Polynomial *pRear: 链表尾节点的指针的指针，用于更新链表尾节点// 返回值：无void Attach(int c, int e, Polynomial *pRear)&#123; // 创建新的多项式节点 P，并分别赋值系数和指数 Polynomial P; P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;coef = c; P-&gt;expon = e; P-&gt;link = NULL; // 将新节点 P 插入链表尾部，更新链表尾节点指针 pRear (*pRear)-&gt;link = P; *pRear = P;&#125; 加法乘法及多项式的输出 上面已经写过此代码 两个多项式相乘 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// 函数名：Polynomial Mult(Polynomial P1, Polynomial P2)// 功能：计算两个多项式 P1 和 P2 的乘积，结果以链表形式返回// 参数：// - Polynomial P1: 第一个多项式的头结点指针// - Polynomial P2: 第二个多项式的头结点指针// 返回值：多项式的头结点指针，表示乘积多项式Polynomial Mult(Polynomial P1, Polynomial P2)&#123; // 声明多项式头结点指针 P, Rear 和临时指针 t1, t2, t Polynomial P, Rear, t1, t2, t; int c, e; // 如果 P1 或 P2 为空，则返回空指针 if (!P1 || !P2) return NULL; // 复制 P1 的头结点，用于计算结果多项式 P t1 = P1; // 复制 P2 的头结点，用于遍历 P2 t2 = P2; // 创建链表头空结点 P，Rear 指向头结点 P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;link = NULL; Rear = P; // 第一重循环，计算 P1 的第一项和 P2 的每一项的乘积，插入到结果多项式 P 中 while (t2) &#123; // 将 P1 的第一项与 P2 的当前项相乘，并将结果插入到结果多项式 P 中 Attach(t1-&gt;coef * t2-&gt;coef, t1-&gt;expon + t2-&gt;expon, &amp;Rear); // 将 P2 的指针 t2 后移，继续处理下一项 t2 = t2-&gt;link; &#125; // 将 P1 的指针 t1 后移，继续处理下一项 t1 = t1-&gt;link; // 第二重循环，计算 P1 的每一项和 P2 的每一项的乘积，插入到结果多项式 P 中 while (t1) &#123; // 重新将 P2 的指针 t2 移回 P2 的头结点，并将 Rear 指针指向结果多项式 P 的头结点 t2 = P2; Rear = P; // 遍历 P2，计算 P1 的当前项与 P2 的每一项的乘积，并插入到结果多项式 P 中 while (t2) &#123; // 计算当前项的指数和系数 e = t1-&gt;expon + t2-&gt;expon; c = t1-&gt;coef * t2-&gt;coef; // 找到合适的位置插入或处理相等指数的情况 while (Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon &gt; e) Rear = Rear-&gt;link; // 处理相等指数的情况，相同指数项的系数相加 if (Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon == e) &#123; if (Rear-&gt;link-&gt;coef == c) Rear-&gt;link-&gt;coef += c; else &#123; // 删除节点，系数为 0 的项 t = Rear-&gt;link; Rear-&gt;link = t-&gt;link; free(t); &#125; &#125; // 不相等则申请新的结点并插入 else &#123; t = (Polynomial)malloc(sizeof(struct PolyNode)); t-&gt;coef = c; t-&gt;expon = e; // 插入过程 t-&gt;link = Rear-&gt;link; Rear-&gt;link = t; Rear = Rear-&gt;link; &#125; t2 = t2-&gt;link; &#125; // 处理完 P1 的一项，将指针后移，继续处理下一项 t1 = t1-&gt;link; &#125; // 删除临时生成的头结点，并将链表的真正头结点指针 P 返回 t2 = P; P = P-&gt;link; free(t2); return P;&#125; 多项式输出 12345678910111213141516171819202122232425262728293031// 函数名：void PrintPoly(Polynomial P)// 功能：打印多项式 P 的系数和指数// 参数：// - Polynomial P: 多项式的头结点指针// 返回值：无void PrintPoly(Polynomial P)&#123; int flag = 0; // flag 用于调整输出格式，初始为 0 // 如果多项式为空，则打印 &quot;0 0&quot; 表示零多项式，并直接返回 if (!P) &#123; printf(&quot;0 0\\n&quot;); return; &#125; // 遍历多项式链表并输出系数和指数 while (P) &#123; // 当 flag 为 0 时，输出第一项，不加空格；否则输出空格 if (!flag) flag = 1; else printf(&quot; &quot;); // 输出当前多项式节点的系数和指数 printf(&quot;%d %d&quot;, P-&gt;coef, P-&gt;expon); // 指针后移，处理下一项 P = P-&gt;link; &#125; // 打印完所有项后换行 printf(&quot;\\n&quot;);&#125; 第三章（树.上）树与树的表示 顺序查找 查找：根据给定某个关键字K，从集合R中找出关键字与K相同的记录 静态查找：集合中记录是固定的，没有删除和插入操作只有查找操作 动态查找：集合中记录是动态的，除了查找操作，还可能有删除和插入操作&#96; 12345678910// 定义一个指向结构体 LNode 的指针类型 Listtypedef struct LNode* List;// 定义结构体 LNodestruct LNode &#123; // 数据域，用于存储元素的数组 ElementType Element[Maxsize]; // 当前线性表的长度 int length;&#125;; 有哨兵 1234567891011121314151617// 在顺序表 Tb1 中进行顺序查找元素 K 的位置// 参数：// - List Tb1: 顺序表的指针，表示要进行查找的顺序表// - ElementType K: 要查找的元素// 返回值：// - 如果找到元素 K，返回其在顺序表 Tb1 中的位置；如果未找到，返回 -1。int SequentialSearch(List Tb1, ElementType K)&#123; int i; // 将要查找的元素 K 放在顺序表 Tb1 的第一个位置，作为哨兵 Tb1-&gt;Element[0] = K; // 从顺序表的末尾开始逆序遍历，查找元素 K 的位置 for (i = Tb1-&gt;length; Tb1-&gt;Element[i] != K; i--); // 如果 i 等于 0，说明未找到元素 K，返回 -1 // 否则返回找到的元素 K 在顺序表 Tb1 中的位置 return i ;&#125; 无哨兵 123456789101112131415// 在顺序表 Tb1 中进行顺序查找元素 K 的位置// 参数：// - List Tb1: 顺序表的指针，表示要进行查找的顺序表// - ElementType K: 要查找的元素// 返回值：// - 如果找到元素 K，返回其在顺序表 Tb1 中的位置；如果未找到，返回 -1。int SequentialSearch(List Tb1, ElementType K)&#123; int i; // 从顺序表的末尾开始逆序遍历，查找元素 K 的位置 for (i = Tb1-&gt;length; i &gt; 0 &amp;&amp; Tb1-&gt;Element[i] != K; i--); // 如果 i 等于 0，说明未找到元素 K，返回 -1 // 否则返回找到的元素 K 在顺序表 Tb1 中的位置 return i == 0 ? -1 : i;&#125; 二分查找（Binary Search）要求：数组连续，有序思路：利用mid，right，left三者的比较缩小范围，查找值left&gt;right?查找失败：结束;复杂度：log（n） 1234567891011121314151617181920212223242526272829// 在有序顺序表 Tb1 中进行二分查找元素 K 的位置// 参数：// - List Tb1: 有序顺序表的指针，表示要进行查找的顺序表// - ElementType K: 要查找的元素// 返回值：// - 如果找到元素 K，返回其在顺序表 Tb1 中的位置（数组下标）；如果未找到，返回 -1。int BinarySearch(List Tb1, ElementType K)&#123; int mid, right, left, notFound = -1; left = 1; // 左边界，初始为第一个元素位置 right = Tb1-&gt;length; // 右边界，初始为最后一个元素位置 mid = (left + right) / 2; // 中间位置 while (left &lt;= right) &#123; // 如果中间元素大于要查找的元素 K，说明要查找的元素在左半部分 if (Tb1-&gt;Element[mid] &gt; K) right = mid - 1; // 如果中间元素小于要查找的元素 K，说明要查找的元素在右半部分 else if (Tb1-&gt;Element[mid] &lt; K) left = mid + 1; // 查找成功，返回元素 K 的位置（数组下标） else return mid; // 更新中间位置 mid = (left + right) / 2; &#125; // 循环结束仍未找到，返回未找到标志 -1 return notFound;&#125; 树的定义和表示 定义：树是由n（n&gt;&#x3D;0）个结点构成的有限集合 每一个树都有一个根结点（root），用r表示 其余结点可以分为数个互不相交的有限集合，每个集合又是一个树，称为原来树的子树 每颗树的子树互不相交，除了根结点外，每个结点只有一个父结点，每个有N个结点的树有N-1条边 树的一些基本术语： 结点的度：结点的子树个数。 树的度: 是所有结点中最大的度数。 节点的层次：规定根结点在一层，其他任一节点层次是其父结点的层次＋1 树的深度：树中所有结点的最大层次 二叉树及存储结构 二叉树的定义和性质定义：有穷的集合 集合可以为空 若不为空，则有左子树和右子树两个互不交叉的二叉树 性质： 一个二叉树第i层最大的结点数为2^i-1^ ,i&gt;&#x3D;1 深为k的二叉树最大的结点数为2^k-1^ ，k&gt;&#x3D;1 对于任意非空二叉树，n0代表叶结点个数，n2代表度数为2的非叶结点个数，那么满足n0&#x3D;n2+1 二叉树的存储结构 顺序存储结构完全二叉树：按照从上到下，从左到右的顺序存储n个节点完全二叉树的父子结点关系 非根结点序号为i&#x2F;2 序号结点为i的左孩子结点的序号为2i 序号结点为i的右孩子结点的序号为2i+1 一般二叉树采用此种存储方法会造成空间的浪费 链表存储结构 1234567891011// 定义二叉树结点的结构体，使用 typedef 别名 BinTree 表示指向该结构体的指针类型typedef struct TreeNode *BinTree;// 使用别名 Position 表示指向二叉树结点的指针类型typedef BinTree Position;// 定义二叉树结点的结构体struct TreeNode&#123; ElementType Data; // 存储结点的数据 BinTree Left; // 左子树的指针 BinTree Right; // 右子树的指针&#125;; 二叉树的遍历 先序 中序 后序 先序访问根结点遍历左子树遍历右子树 123456789101112131415161718// 前序遍历二叉树// 参数：// - BinTree BT: 二叉树的根结点指针// 返回值：// - 无，函数用于打印二叉树的前序遍历结果。void PreorderTraversal(BinTree BT)&#123; // 判断当前结点是否为空 if (BT) &#123; // 如果当前结点不为空，打印当前结点的数据 printf(&quot;%d &quot;, BT-&gt;Data); // 递归遍历左子树 PreorderTraversal(BT-&gt;Left); // 递归遍历右子树 PreorderTraversal(BT-&gt;Right); &#125;&#125; 中序遍历左子树访问根结点遍历右子树 123456789101112131415161718// 中序遍历二叉树// 参数：// - BinTree BT: 二叉树的根结点指针// 返回值：// - 无，函数用于打印二叉树的中序遍历结果。void InorderTraversal(BinTree BT)&#123; // 判断当前结点是否为空 if (BT) &#123; // 递归遍历左子树 InorderTraversal(BT-&gt;Left); // 如果当前结点不为空，打印当前结点的数据 printf(&quot;%d &quot;, BT-&gt;Data); // 递归遍历右子树 InorderTraversal(BT-&gt;Right); &#125;&#125; 后序遍历左子树遍历右子树访问根结点 123456789101112131415161718// 后序遍历二叉树// 参数：// - BinTree BT: 二叉树的根结点指针// 返回值：// - 无，函数用于打印二叉树的后序遍历结果。void PostorderTraversal(BinTree BT)&#123; // 判断当前结点是否为空 if (BT) &#123; // 递归遍历左子树 PostorderTraversal(BT-&gt;Left); // 递归遍历右子树 PostorderTraversal(BT-&gt;Right); // 如果当前结点不为空，打印当前结点的数据 printf(&quot;%d &quot;, BT-&gt;Data); &#125;&#125; 中序非递归思路：利用堆栈 遇到一个结点就把它堆栈，然后遍历其左子树 遍历完左子树后将该结点弹出并访问 利用有指针中序遍历该结点右子树 123456789101112131415161718192021222324// 中序遍历二叉树（非递归版本）// 参数：// - BinTree BT: 二叉树的根结点指针// 返回值：// - 无，函数用于打印二叉树的中序遍历结果。void InorderTraversal(BinTree BT)&#123; BinTree T = BT; // 定义辅助指针T，初始指向根结点 Stack S = CreatStack(MaxSize); // 创建一个栈S，用于辅助遍历 while (T || !isEmpty(S)) // 当T不为空或栈S不为空时继续遍历 &#123; while (T) // 将指针T沿左子树一直向下，直到叶子结点 &#123; Push(S, T); // 将结点指针T入栈 T = T-&gt;Left; // 移动指针T指向左孩子结点 &#125; if (!isEmpty(S)) // 当栈S不为空时，弹出栈顶元素 &#123; T = Pop(S); // 弹出并取出栈顶元素，赋值给指针T printf(&quot;%5d&quot;, T-&gt;Data); // 打印当前结点的数据 T = T-&gt;Right; // 将指针T指向当前结点的右孩子结点 &#125; &#125; 层序思路：利用队列层序基本过程：遍历从根结点开始，首先将根结点入队，然后执行循环：结点出队，访问该结点，其左右儿子入队 123456789101112131415161718192021222324// 层序遍历二叉树// 参数：// - BinTree BT: 二叉树的根结点指针// 返回值：// - 无，函数用于打印二叉树的层序遍历结果。void LevelOrderTraversal(BinTree BT)&#123; BinTree T; // 定义辅助指针T，用于遍历二叉树的结点 Queue Q; // 定义队列Q，用于存储待遍历的结点 if (!BT) return; // 若二叉树为空树，直接返回 // 初始化队列 Q = CreatQueue(MaxSize); AddQ(Q, BT); // 将根结点入队列 while (!isEmpty(Q)) &#123; // 取出队列的头结点，并访问该结点 T = DeletQ(Q); printf(&quot;%5d&quot;, T-&gt;Data); // 如果当前结点有左子节点，将左子节点入队列 if (T-&gt;Left) AddQ(Q, T-&gt;Left); // 如果当前结点有右子节点，将右子节点入队列 if (T-&gt;Right) AddQ(Q, T-&gt;Right); &#125;&#125; 例求二叉树高度123456789101112131415161718192021222324// 中序遍历二叉树并计算二叉树的高度// 参数：// - BinTree BT: 二叉树的根结点指针// 返回值：// - int: 二叉树的高度int InOrderTraversal(BinTree BT)&#123; int Hr, Hl, Maxh; if (BT) &#123; // 递归遍历左子树，并获取左子树的高度 Hl = InOrderTraversal(BT-&gt;Left); // 递归遍历右子树，并获取右子树的高度 Hr = InOrderTraversal(BT-&gt;Right); // 计算当前树的高度，即左右子树高度的最大值加1（加1是因为要算上当前结点） Maxh = (Hl &gt; Hr ? Hl : Hr) + 1; return Maxh; &#125; else &#123; // 代表该树为空树，高度为0 return 0; &#125;&#125; 第四章（树.中）二叉搜索树二叉搜索树又称为二叉排序树或二叉选择树 满足以下性质： 二叉树可以为空 非空左子树所有键值小于根结点键值 非空右子树所有键值大于根结点键值 左子树和右子树都是二叉搜索树 查找 从查找跟结点开始，若根结点为空，直接返回NULL 若根结点不为空，根结点关键字和X进行比较 若根节点键值大于X则从左子树继续搜索 若根节点键值小于X则从右子树继续搜索 若两者相等，搜索查找完成，结束 12345678910111213141516// 在二叉搜索树中查找元素 X// 参数：// - ElementType X: 待查找的元素// - BinTree BT: 二叉搜索树的根结点指针// 返回值：// - Position: 若找到元素 X，返回对应结点的指针，否则返回 NULL。Position Find(ElementType X, BinTree BT)&#123; if (!BT) return NULL; // 若当前结点为空树（NULL），说明未找到 X，返回 NULL if (BT-&gt;Data &gt; X) return Find(X, BT-&gt;Left); // 若当前结点值大于 X，说明 X 在左子树中，继续在左子树中查找 else if (BT-&gt;Data &lt; X) return Find(X, BT-&gt;Right); // 若当前结点值小于 X，说明 X 在右子树中，继续在右子树中查找 else return BT; // 若当前结点值等于 X，说明找到了 X，返回当前结点指针&#125; 但非递归函数执行效率更高，可将递归函数改为迭代函数 1234567891011121314151617181920// 在二叉搜索树中循环查找元素 X// 参数：// - ElementType X: 待查找的元素// - BinTree BT: 二叉搜索树的根结点指针// 返回值：// - Position: 若找到元素 X，返回对应结点的指针，否则返回 NULL。Position InterFind(ElementType X, BinTree BT)&#123; while (BT) &#123; if (BT-&gt;Data &gt; X) BT = BT-&gt;Left; // 如果当前结点值大于 X，说明 X 在当前结点的左子树中，移动到左子树继续查找 else if (BT-&gt;Data &lt; X) BT = BT-&gt;Right; // 如果当前结点值小于 X，说明 X 在当前结点的右子树中，移动到右子树继续查找 else return BT; // 如果当前结点值等于 X，说明找到了 X，返回当前结点指针 &#125; // 如果树为空，返回 NULL return NULL;&#125; 最大元素一定在最右分支端结点上 最小元素一定在最左分支端结点上 查找最小元素递归 12345678910111213// 递归查找二叉搜索树中的最小元素// 参数：// - BinTree BT: 二叉搜索树的根结点指针// 返回值：// - Position: 返回最小元素所在结点的指针，若树为空则返回 NULL。Position FindMin(BinTree BT)&#123; if (!BT) return NULL; // 若当前结点为空树（NULL），说明树为空，直接返回 NULL // 若当前结点的左子树为空，说明当前结点为最小元素所在结点，直接返回当前结点指针 else if (!BT-&gt;Left) return BT; // 否则递归调用 FindMin 函数，在当前结点的左子树中继续查找最小元素 else return FindMin(BT-&gt;Left);&#125; 查找最大元素迭代 123456789101112131415// 迭代查找二叉搜索树中的最大元素// 参数：// - BinTree BT: 二叉搜索树的根结点指针// 返回值：// - Position: 返回最大元素所在结点的指针，若树为空则返回 NULL。Position FindMax(BinTree BT)&#123; if (BT) &#123; // 沿右结点查找，直到最右叶结点 while (BT-&gt;Right) BT = BT-&gt;Right; &#125; return BT;&#125; 插入方法类似find 123456789101112131415161718192021222324// 向二叉搜索树中插入元素 X// 参数：// - ElementType X: 要插入的元素值// - BinTree BST: 二叉搜索树的根结点指针// 返回值：// - BinTree: 返回插入后的二叉搜索树的根结点指针BinTree Insert(ElementType X, BinTree BST)&#123; // 若该树为空，生成并返回一个只包含一个结点的二叉树 if (!BST) &#123; BST = malloc(sizeof(struct TreeNode)); BST-&gt;Data = X; BST-&gt;Right = BST-&gt;Left = NULL; //将新结点的左右子树指针初始化为空。 &#125; else &#123; if (BST-&gt;Data &gt; X) BST-&gt;Left = Insert(X, BST-&gt;Left); // 将 X 插入左子树 else if (BST-&gt;Data &lt; X) BST-&gt;Right = Insert(X, BST-&gt;Right); // 将 X 插入右子树 &#125; return BST;&#125; 3.删除分三种情况 若删除的为叶结点，则直接删除，并将父结点指针置为NULL 若删除的结点只有一个孩子结点，则将父结点指向要删除结点的孩子结点 若要删除的结点有左右两颗子树，则用其他结点替代要删除的结点，左子树的最大元素或者右子树的最小元素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 从二叉搜索树中删除元素 X// 参数：// - ElementType X: 要删除的元素值// - BinTree BST: 二叉搜索树的根结点指针// 返回值：// - BinTree: 返回删除元素后的二叉搜索树的根结点指针BinTree Delete(ElementType X, BinTree BST)&#123; Position Tmp; // 若树为空，表示未找到要删除的元素 X，打印提示信息并直接返回 if (!BST) &#123; printf(&quot;未查找到&quot;); return NULL; &#125; else if (BST-&gt;Data &gt; X) BST-&gt;Left = Delete(X, BST-&gt;Left); // 在左子树中继续查找并删除元素 X else if (BST-&gt;Data &lt; X) BST-&gt;Right = Delete(X, BST-&gt;Right); // 在右子树中继续查找并删除元素 X else &#123; // 找到要删除的结点 // 被删除的结点有左右两个子结点 if (BST-&gt;Left &amp;&amp; BST-&gt;Right) &#123; Tmp = FindMin(BST-&gt;Right); // 用右子树中最小值替代被删除结点的值 BST-&gt;Data = Tmp-&gt;Data; BST-&gt;Right = Delete(BST-&gt;Data, BST-&gt;Right); &#125; else &#123; // 被删除的结点有一个或无子结点 Tmp = BST; // 如果左边是空的，则把右边指针指向父亲结点 if (!BST-&gt;Left) BST = BST-&gt;Right; else if (!BST-&gt;Right) BST = BST-&gt;Left; free(Tmp); &#125; &#125; return BST;&#125; 平衡二叉树平衡因子BF(T)&#x3D; hL- hR,其中hL和hR分别为左右子树高度平衡二叉树：空树，或者任一结点左右子树高度差的绝对值不超过1即|BF(T)|&lt;&#x3D;1 给定结点树为n的avl树的最大高度为O(log2n) 平衡二叉树的调整： 判断被破坏点的位置确定旋转方向 RR旋转 LL旋转 LR旋转 RL旋转 小白专场（空）第五章（树.下）堆 优先队列：特殊的队列，取出元素的顺序时依照元素的优先权大小，而不是元素进入队列的先后顺序优先队列的完全二叉树 结构性：用数组表示的完全二叉树 有序性：任一结点的关键字是其子树所有结点的最大值或者最小值 抽象数据描述： 最大堆创建 1234567891011121314151617181920212223typedef struct HeapStruct *MaxHeap;struct HeapStruct &#123; // 存储堆元素的数组 ElementType *Elements; // 堆当前元素个数 int Size; // 堆的最大容量 int Capacity;&#125;// 创建最大堆MaxHeap CreateMaxHeap(int MaxSize)&#123; // 分配内存空间用于存储最大堆 MaxHeap H = malloc(sizeof(struct HeapStruct)); // 分配内存空间用于存储堆元素的数组 H-&gt;Elements = malloc((MaxSize + 1) * sizeof(ElementType)); // 初始化堆的相关属性 H-&gt;Size = 0; H-&gt;Capacity = MaxSize; // 设置哨兵，哨兵的值为最大可能的元素值 H-&gt;Elements[0] = MaxData; return H;&#125; 最大堆的插入将新增结点插入到从父结点到跟结点的有序序列中 123456789101112131415161718192021// 向最大堆中插入元素void insert(MaxHeap H, ElementType item)&#123; int i; // 判断最大堆是否已满 if (isFull(H)) &#123; printf(&quot;最大堆已满&quot;); return; &#125; // 将元素插入堆的末尾 i = ++H-&gt;Size; // 向上调整结点，找到插入位置 for (; H-&gt;Elements[i / 2] &lt; item; i /= 2) &#123; // 将父结点的值下滤到当前结点 H-&gt;Elements[i] = H-&gt;Elements[i / 2]; &#125; // 将元素插入到找到的位置 H-&gt;Elements[i] = item;&#125; 最大堆的删除取出根结点最大值元素，同时删除堆的一个结点 1234567891011121314151617181920212223242526272829303132// 从最大堆中删除最大元素ElementType DeletMax(MaxHeap H)&#123; int Parent, Child; ElementType MaxItem, temp; // 判断最大堆是否为空 if (IsEmpty(H)) &#123; printf(&quot;最大堆已空&quot;); return; &#125; // 取出根结点最大值，用最大堆中最后一个元素从根结点开始向下过滤下层结点 MaxItem = H-&gt;Elements[1]; temp = H-&gt;Elements[H-&gt;Size--]; for (Parent = 1; Parent * 2 &lt;= H-&gt;Size; Parent = Child) &#123; // 将Child指向左右儿子中较大的一个 Child = Parent * 2; // 如果有右儿子并且右儿子的值大于左儿子，则Child指向右儿子 if ((Child != H-&gt;Size) &amp;&amp; (H-&gt;Elements[Child] &lt; H-&gt;Elements[Child + 1])) Child++; // 如果temp的值大于等于Child结点的值，则找到了temp应该插入的位置，退出循环 if (temp &gt;= H-&gt;Elements[Child]) break; else // 将较大的Child结点上滤到Parent结点位置 H-&gt;Elements[Parent] = H-&gt;Elements[Child]; &#125; // 将temp插入到找到的位置 H-&gt;Elements[Parent] = temp; return MaxItem;&#125; 最大堆的建立：将已经存在的N个元素按照最大堆的要求存放在一个一维数组中 ​ 线性复杂度下建立最大堆 ​ N个元素按线性存入，完全满足二叉树结构特性 ​ 调整各个结点的位置，以满足最大堆的有序性 哈弗曼树例：将百分制成绩转换为五分制成绩结点不同的查找频率可构造更加有效的生成树 哈夫曼树的定义带权路径长度（WPL）：设二叉树有n个叶子结点，每个叶子结点带有权值wk，从根节点到每个叶子结点的长度为lk，则每个叶子结点的带权路径长度之和为 哈弗曼树在做一个问题，如何排序结点使得WPL值最小 哈夫曼树的构造 每次把权值最小的两棵树合并 12345678910111213141516171819202122232425typedef struct TreeNode *HuffmanTree;struct TreeNode &#123; int Weight; // 结点的权值 HuffmanTree Left, Right; // 左右子树的指针&#125;;// 哈夫曼树的构建HuffmanTree Huffman(MinHeap H) &#123; // 假设H-&gt;Size个权值已经存在H-&gt;Elements[]-&gt;Weight中 int i; HuffmanTree T; BuildMinHeap(H); // 将最小堆转换为最小优先队列 // 通过贪心算法构建哈夫曼树 for (i = 1; i &lt; H-&gt;Size; i++) &#123; // 建立新结点 T = malloc(sizeof(struct TreeNode)); T-&gt;Left = DeleteMin(H); // 从最小优先队列中删除最小权值的结点作为左子树 T-&gt;Right = DeleteMin(H); // 从最小优先队列中删除次小权值的结点作为右子树 T-&gt;Weight = T-&gt;Left-&gt;Weight + T-&gt;Right-&gt;Weight; // 计算新结点的权值 Insert(H, T); // 将新结点插入最小优先队列 &#125; T = DeleteMin(H); // 最小优先队列中最后剩下的结点即为哈夫曼树的根结点 return T;&#125;// 时间复杂度: NlogN 哈夫曼树的特点： 没有度为一的结点 n个叶子结点的哈夫曼树共有2n-1个结点 哈夫曼树任意非叶节点的左右子树交换后仍是哈夫曼树 哈夫曼树和哈夫曼编码 ​ 不等长编码：出现频率高的字符用的编码短些，出现频率低的字符用的编码高些 ​ 如何进行不等长编码？ 编码可能出现二义性，根据二义性引出前缀码的概念：任何字符的编码都不是另一字符编码的前缀 可以无义地解码 二叉树用于编码：左右分支0，1字符只在叶结点上 用哈夫曼树可以实现二叉树编码代价最小 集合及运算集合可以用数组存储 查找某个元素的集合 12345678910int Find(SetType S[],ElementType X)&#123; //在数组中查找值为X的元素所属集合 //MaxSize是全局变量，为数组S的最大长度 int i; for(int i = 0; i &lt; MaxSize &amp;&amp; S[i].Data != X; i ++) if(i&gt;=MaxSize)return -1; for(;S[i]-&gt;Parent&gt;=0;i = S[i].Parent); return i;&#125; 集合的并运算 分别找到X1和X2两个元素所在集合的根结点 如果他们不同根，则将一个根结点的父结点指针设置为另一个根结点的数组下标 12345678void Union(SetType S[],ElementType X1,ElementType X2)&#123; int Root1,Root2; Root1 = Find(S,X1); Root2 = Find(S,X2); if(Root1!=Root2) S[Root2].Parent=Root1;&#125; 为了改善合并以后的查找性能，可以采取小的集合合并到大的集合中，可以修改union函数，即将第一个结点的Parent修改为负的元素个数，对应其绝对值即为元素个数，方便比较 第六章图图的定义:六度空间理论(Six Degrees of Separation)任何两个人之间不超六个人之间认识 ​ 图可以解决的问题 花费最少可以转换为最小生成树的问题 线性表和树可以描述为图的一个特殊情况 表示多对多的关系 包含: ​ 一组顶点：通常用V(Vertex)表示顶点集合 ​ 一组边：通常用E(Edge)表示边的集合 边是顶点对：(v,w)属于E,其中v,w属于V v——w 有向边&lt;v,w&gt;表示从v指向w的边（单行线）v——&gt; w 不考虑重边和自回路 抽象数据类型定义： 常见术语： 红色数字称为权重,有权重的我们称之为网络 邻接矩阵表示法邻接矩阵是对称的，只需要存一半的元素即可，省去一半的存储空间 浪费空间：存稀疏图（点很多而边很少）有大量无效元素对于稠密图，特别是稀疏图比较合算 邻接表表示法邻接表：G[N]是指针数组，对应矩阵每一行一个链表，只存非零元素，顺序没有要求 方便找任一顶点的所有”邻接点“ 节约稀疏图空间需要N个头指针和2E个结点（每个结点至少需要连个域） 图的遍历DFS 深度优先搜索N条边E个结点邻接表存图O(N+E)邻接矩阵存图O(N2) BFS 广度优先搜索 为什么两种遍历?图连不通怎么办? 连通：如果v到w存在一条（无向）路径，则称v到w是连通的 路径：v到w的路径是一系列顶点（v,v1,v2,v3,vn,w）,其中任意相邻顶点间都有图中的边。路径的长度是路径中的边数（如果带权，是所有边数权重之和）。如果v到w是所有顶点都不同，则称之为简单路径。 回路：起点等于终点的路径 连通图；图中任意两点均连通 连通分量：无向图的极大连通子图 极大顶点数：再加一个顶点就不连通的 极大边数：包含子图中所有顶点相连的所有边 强连通：有向图中顶点v和w之间存在双向路径，则称v和w强连通 强连通图：有向图中任意两顶点均强连 强连通分量：有向图的极大强连通子图每调用一次DFS(V),就把V所在连通分量遍历一遍，BFS(V)也是一样 拯救007void save007(Graph G){ for(each V in G) { if(!visited[G]&amp;&amp;FirstJump(G)) { answer &#x3D; DFS(V); if(answer&#x3D;&#x3D;YES)break; } } if(answer&#x3D;&#x3D;YES)output(“Yes”); else output(“No”);} void DFS(Vertex V){ visited[V]&#x3D;true; if(IsSafe(V))answer &#x3D; YES; else { &#x2F;&#x2F;for(V的每个邻接点W) for(each W in G) if(!visited[W]&amp;&amp;Jump(V,W)) { answer &#x3D; DFS(W); if(answer&#x3D;&#x3D;YES)break; } } return answer;} 123456789101112131415161718192021222324252627282930六度空间 算法思路：对每个节点进行广度优先搜索搜索过程累计访问的节点需要记录“层数”，仅计算6层以内结点数 int BFS(Vertex V){ visited[V] &#x3D; true; count &#x3D; 1; level &#x3D; 0; last &#x3D; V; Enqueue(V,Q); while(!IsEmpty(Q)) { V &#x3D; Dequeue(Q); for(V每个邻接点W) if(!visited[W]) { visited[W] &#x3D; true; Enqueue(W,Q); count++; tail &#x3D; W; } if(V&#x3D;&#x3D;last) { level++; last &#x3D; tail; } if(level &#x3D;&#x3D; 6)break; } return count;} 12345678910111213141516171819202122232425 邻接矩阵表示的图创建一个图12345678typedef struct GNode *PtrToGNode;struct GNode&#123; int Nv;//顶点数 int Ne;//边数 WeightType G[MaxVertexNum][MaxVertexNum]; DataType Data[MaxVertexNum];&#125;;typedef PtrToGNode MGraph;//以邻接矩阵存储图的类型 MGraph 初始化初始化一个有VertexNum个顶点但是没有边的图 123456789101112MGraph CreatGraph(int VertexNum)&#123; MGraph Graph; Graph = (MGraph)malloc(sizeof(struct GNode)); Graph-&gt;Nv = VertexNum; Graph-&gt;Ne = 0; for(V = 0; V &lt; Graph-&gt;Nv; V ++) for(W = 0; W &lt; Graph-&gt;Ne; W ++) Graph-&gt;G[V][W] = 0; //如果有权值可以使Graph-&gt;G[V][W]=INFINITY; return Graph;&#125; 向MGraph插入一条边1234567891011121314typedef struct ENode *PtrToENode;struct ENode&#123; Vertex V1,V2;//有向边V1，V2 WeightType Weight;//权重&#125;;typedef PtrToENode Edge;//把相应的权重赋值给相应的邻接矩阵void InsertEdge(MGraph Graph,Edge E)&#123; //有向图 Graph-&gt;G[E-&gt;V1][E-&gt;V2] = E-&gt;Weight; //若为无向图还需要插入一条V2V1边 Graph-&gt;G[E-&gt;V2][E-&gt;V1] = E-&gt;Weight;&#125; 完整建立一个MGraph12345678910111213141516int G[MAXN][MAXN],Nv,Ne;void BuildGraph()&#123; int i,j,v1,v2,w; scanf(&quot;%d&quot;,&amp;Nv); for( i = 0; i &lt; Nv; i ++) for( j = 0; j &lt; Nv; j ++) G[i][j] = 0; scanf(&quot;%d&quot;,&amp;Ne); for( i = 0; i &lt; Ne; i ++) &#123; scanf(&quot;%d %d %d&quot;,&amp;v1,&amp;v2,&amp;w); G[v1][v2]=w; G[v2][v1]=w; &#125;&#125; 用邻接表表示的图邻接表：G[N]是指针数组，对应矩阵每行一个链表，只存非零元素 123456789101112131415161718192021typedef struct GNode *PtrToGNode;struct GNode&#123; int Nv; int Ne; AdjList G; //邻接表&#125;;typedef PtrToGNode LGraph;typedef struct Vnode&#123; PtrToAdjVNode FirstEdge; DataType Data;&#125;AdjList[MaxVertexNum];//AdjList 邻接表类型typedef struct AdjVNode PtrToAdjVNode;struct AdjVNode&#123; Vertex AdjV;//邻接表下标 WeightType Weight; PtrToAdjVNode Next;&#125; 初始化 123456789101112LGraph CreatGraph(int VertexNum)&#123; Vertex V,W; LGraph Graph; Graph = (LGraph)malloc(sizeof(struct GNode)); Graph-&gt;Nv = VertexNum; Graph-&gt;Ne = 0; for( V = 0; V &lt; Graph-&gt;Nv; V ++) Graph-&gt;G[V].FirstEdeg = NULL; return Graph;&#125; 插入边 123456789101112131415161718192021void InsertEdge(LGraph Graph,Edge E)&#123; PtrToAdjVNode NewNode; //给V2建立新结点 NewNode = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode)); NewNode-&gt;AdjV = E-&gt;V2; NewNode-&gt;Weight = E-&gt;Weight; //将V2插入V1表头 NewNode-&gt;Next = Graph-&gt;G[E-&gt;V1].FirstEdge; Graph-&gt;G[E-&gt;V1].FirstEdge = NewNode; //若是无向图，则需要插入V2V1边 //给V1建立新结点 NewNode = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode)); NewNode-&gt;AdjV = E-&gt;V1; NewNode-&gt;Weight = E-&gt;Weight; //将V1插入V2表头 NewNode-&gt;Next = Graph-&gt;G[E-&gt;V2].FirstEdge; Graph-&gt;G[E-&gt;V2].FirstEdge = NewNode;&#125;","categories":[{"name":"计算机四大件","slug":"计算机四大件","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%9B%E5%A4%A7%E4%BB%B6/"},{"name":"数据结构与算法","slug":"计算机四大件/数据结构与算法","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"前端页面设计-6-退款表单设计","slug":"前端页面设计-6-退款表单设计","date":"2023-07-12T16:00:00.000Z","updated":"2023-08-06T11:12:02.788Z","comments":true,"path":"2023/07/13/前端页面设计-6-退款表单设计/","link":"https://blog.csdn.net/artly1/article/details/131608781?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2023/07/13/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1-6-%E9%80%80%E6%AC%BE%E8%A1%A8%E5%8D%95%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}],"author":"artly1"},{"title":"前端页面设计-5-基本页面设计","slug":"前端页面设计-5-基本页面设计","date":"2023-07-11T16:00:00.000Z","updated":"2023-08-06T11:12:07.847Z","comments":true,"path":"2023/07/12/前端页面设计-5-基本页面设计/","link":"https://blog.csdn.net/artly1/article/details/131608651?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2023/07/12/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1-5-%E5%9F%BA%E6%9C%AC%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}],"author":"artly1"},{"title":"前端页面设计-4-携程旅行页面设计","slug":"前端页面设计-4-携程旅行页面设计","date":"2023-07-10T16:00:00.000Z","updated":"2023-08-06T11:12:11.936Z","comments":true,"path":"2023/07/11/前端页面设计-4-携程旅行页面设计/","link":"https://blog.csdn.net/artly1/article/details/131312727?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2023/07/11/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1-4-%E6%90%BA%E7%A8%8B%E6%97%85%E8%A1%8C%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}],"author":"artly1"},{"title":"前端页面设计-3-页面案例设计","slug":"前端页面设计-3-页面案例设计","date":"2023-07-09T16:00:00.000Z","updated":"2023-08-06T11:12:15.975Z","comments":true,"path":"2023/07/10/前端页面设计-3-页面案例设计/","link":"https://blog.csdn.net/artly1/article/details/131328670?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2023/07/10/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1-3-%E9%A1%B5%E9%9D%A2%E6%A1%88%E4%BE%8B%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}],"author":"artly1"},{"title":"matlab建模基础知识","slug":"matlab建模基础知识","date":"2023-07-08T16:00:00.000Z","updated":"2023-08-06T09:49:58.995Z","comments":true,"path":"2023/07/09/matlab建模基础知识/","link":"https://blog.csdn.net/artly1/article/details/131621211?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2023/07/09/matlab%E5%BB%BA%E6%A8%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"","categories":[{"name":"matlab","slug":"matlab","permalink":"http://yoursite.com/categories/matlab/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"http://yoursite.com/tags/matlab/"}],"author":"artly1"},{"title":"matlab数学建模——画图","slug":"matlab数学建模——画图","date":"2023-07-08T16:00:00.000Z","updated":"2023-08-06T09:52:11.047Z","comments":true,"path":"2023/07/09/matlab数学建模——画图/","link":"https://blog.csdn.net/artly1/article/details/131622585?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2023/07/09/matlab%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E2%80%94%E2%80%94%E7%94%BB%E5%9B%BE/","excerpt":"","text":"","categories":[{"name":"matlab","slug":"matlab","permalink":"http://yoursite.com/categories/matlab/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"http://yoursite.com/tags/matlab/"}],"author":"artly1"},{"title":"matlab数学建模——插值与拟合","slug":"matlab数学建模——插值与拟合","date":"2023-07-08T16:00:00.000Z","updated":"2023-08-06T09:51:54.526Z","comments":true,"path":"2023/07/09/matlab数学建模——插值与拟合/","link":"https://blog.csdn.net/artly1/article/details/131623122?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2023/07/09/matlab%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E2%80%94%E2%80%94%E6%8F%92%E5%80%BC%E4%B8%8E%E6%8B%9F%E5%90%88/","excerpt":"","text":"","categories":[{"name":"matlab","slug":"matlab","permalink":"http://yoursite.com/categories/matlab/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"http://yoursite.com/tags/matlab/"}],"author":"artly1"},{"title":"matlab数学建模——求极限、求导、求积分","slug":"matlab数学建模——求极限、求导、求积分","date":"2023-07-08T16:00:00.000Z","updated":"2023-08-06T09:54:01.335Z","comments":true,"path":"2023/07/09/matlab数学建模——求极限、求导、求积分/","link":"https://blog.csdn.net/artly1/article/details/131621842?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2023/07/09/matlab%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E2%80%94%E2%80%94%E6%B1%82%E6%9E%81%E9%99%90%E3%80%81%E6%B1%82%E5%AF%BC%E3%80%81%E6%B1%82%E7%A7%AF%E5%88%86/","excerpt":"","text":"","categories":[{"name":"matlab","slug":"matlab","permalink":"http://yoursite.com/categories/matlab/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"http://yoursite.com/tags/matlab/"}],"author":"artly1"},{"title":"matlab数学建模——线性规划、0-1整数规划","slug":"matlab数学建模——线性规划、0-1整数规划","date":"2023-07-08T16:00:00.000Z","updated":"2023-08-06T09:54:23.053Z","comments":true,"path":"2023/07/09/matlab数学建模——线性规划、0-1整数规划/","link":"https://blog.csdn.net/artly1/article/details/131627018?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2023/07/09/matlab%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E3%80%810-1%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/","excerpt":"","text":"","categories":[{"name":"matlab","slug":"matlab","permalink":"http://yoursite.com/categories/matlab/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"http://yoursite.com/tags/matlab/"}],"author":"artly1"},{"title":"前端页面设计-2-照片墙","slug":"前端页面设计-2-照片墙","date":"2023-07-08T16:00:00.000Z","updated":"2023-08-06T11:12:19.434Z","comments":true,"path":"2023/07/09/前端页面设计-2-照片墙/","link":"https://blog.csdn.net/artly1/article/details/131296262?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2023/07/09/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1-2-%E7%85%A7%E7%89%87%E5%A2%99/","excerpt":"","text":"","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}],"author":"artly1"},{"title":"51单片机实验1-流水灯的设计（流水灯，蜂鸣器，爆闪灯）","slug":"51单片机实验1-流水灯的设计（流水灯，蜂鸣器，爆闪灯）","date":"2023-07-07T16:00:00.000Z","updated":"2023-08-06T09:30:54.931Z","comments":true,"path":"2023/07/08/51单片机实验1-流水灯的设计（流水灯，蜂鸣器，爆闪灯）/","link":"https://blog.csdn.net/artly1/article/details/131611655?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2023/07/08/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AE%9E%E9%AA%8C1-%E6%B5%81%E6%B0%B4%E7%81%AF%E7%9A%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E6%B5%81%E6%B0%B4%E7%81%AF%EF%BC%8C%E8%9C%82%E9%B8%A3%E5%99%A8%EF%BC%8C%E7%88%86%E9%97%AA%E7%81%AF%EF%BC%89/","excerpt":"","text":"","categories":[{"name":"51单片机","slug":"51单片机","permalink":"http://yoursite.com/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"51单片机","slug":"51单片机","permalink":"http://yoursite.com/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"author":"artly1"},{"title":"51单片机实验2-花样流水灯的设计（花样流水灯，倒车警示灯）","slug":"51单片机实验2-花样流水灯的设计（花样流水灯，倒车警示灯）","date":"2023-07-07T16:00:00.000Z","updated":"2023-08-06T09:30:49.849Z","comments":true,"path":"2023/07/08/51单片机实验2-花样流水灯的设计（花样流水灯，倒车警示灯）/","link":"https://blog.csdn.net/artly1/article/details/131612497?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2023/07/08/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AE%9E%E9%AA%8C2-%E8%8A%B1%E6%A0%B7%E6%B5%81%E6%B0%B4%E7%81%AF%E7%9A%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E8%8A%B1%E6%A0%B7%E6%B5%81%E6%B0%B4%E7%81%AF%EF%BC%8C%E5%80%92%E8%BD%A6%E8%AD%A6%E7%A4%BA%E7%81%AF%EF%BC%89/","excerpt":"","text":"","categories":[{"name":"51单片机","slug":"51单片机","permalink":"http://yoursite.com/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"51单片机","slug":"51单片机","permalink":"http://yoursite.com/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"author":"artly1"},{"title":"51单片机实验3-中断控制的LED灯（单一外部中断控制LED灯，两个外部中断控制LED灯，交通管制路口）","slug":"51单片机实验3-中断控制的LED灯（单一外部中断控制LED灯，两个外部中断控制LED灯，交通管制路口）","date":"2023-07-07T16:00:00.000Z","updated":"2023-08-06T09:30:22.266Z","comments":true,"path":"2023/07/08/51单片机实验3-中断控制的LED灯（单一外部中断控制LED灯，两个外部中断控制LED灯，交通管制路口）/","link":"https://blog.csdn.net/artly1/article/details/131613006?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2023/07/08/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AE%9E%E9%AA%8C3-%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E7%9A%84LED%E7%81%AF%EF%BC%88%E5%8D%95%E4%B8%80%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6LED%E7%81%AF%EF%BC%8C%E4%B8%A4%E4%B8%AA%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6LED%E7%81%AF%EF%BC%8C%E4%BA%A4%E9%80%9A%E7%AE%A1%E5%88%B6%E8%B7%AF%E5%8F%A3%EF%BC%89/","excerpt":"","text":"","categories":[{"name":"51单片机","slug":"51单片机","permalink":"http://yoursite.com/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"51单片机","slug":"51单片机","permalink":"http://yoursite.com/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"author":"artly1"},{"title":"51单片机实验4-计时器设计（LED灯实现二进制计数,简易计数报警,呼吸灯）","slug":"51单片机实验4-计时器设计（LED灯实现二进制计数-简易计数报警-呼吸灯）","date":"2023-07-07T16:00:00.000Z","updated":"2023-08-06T09:30:18.755Z","comments":true,"path":"2023/07/08/51单片机实验4-计时器设计（LED灯实现二进制计数-简易计数报警-呼吸灯）/","link":"https://blog.csdn.net/artly1/article/details/131613533?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2023/07/08/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AE%9E%E9%AA%8C4-%E8%AE%A1%E6%97%B6%E5%99%A8%E8%AE%BE%E8%AE%A1%EF%BC%88LED%E7%81%AF%E5%AE%9E%E7%8E%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%AE%A1%E6%95%B0-%E7%AE%80%E6%98%93%E8%AE%A1%E6%95%B0%E6%8A%A5%E8%AD%A6-%E5%91%BC%E5%90%B8%E7%81%AF%EF%BC%89/","excerpt":"","text":"","categories":[{"name":"51单片机","slug":"51单片机","permalink":"http://yoursite.com/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"51单片机","slug":"51单片机","permalink":"http://yoursite.com/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"author":"artly1"},{"title":"51单片机实验5-矩阵按键的应用","slug":"51单片机实验5-矩阵按键的应用","date":"2023-07-07T16:00:00.000Z","updated":"2023-08-06T09:34:10.107Z","comments":true,"path":"2023/07/08/51单片机实验5-矩阵按键的应用/","link":"https://blog.csdn.net/artly1/article/details/131613860?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2023/07/08/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AE%9E%E9%AA%8C5-%E7%9F%A9%E9%98%B5%E6%8C%89%E9%94%AE%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"","text":"","categories":[{"name":"51单片机","slug":"51单片机","permalink":"http://yoursite.com/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"51单片机","slug":"51单片机","permalink":"http://yoursite.com/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"author":"artly1"},{"title":"51单片机实验6-LED点阵的应用","slug":"51单片机实验6-LED点阵的应用","date":"2023-07-07T16:00:00.000Z","updated":"2023-08-06T09:34:32.634Z","comments":true,"path":"2023/07/08/51单片机实验6-LED点阵的应用/","link":"https://blog.csdn.net/artly1/article/details/131613998?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2023/07/08/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AE%9E%E9%AA%8C6-LED%E7%82%B9%E9%98%B5%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"","text":"","categories":[{"name":"51单片机","slug":"51单片机","permalink":"http://yoursite.com/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"51单片机","slug":"51单片机","permalink":"http://yoursite.com/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"author":"artly1"},{"title":"前端页面设计-1-基础知识","slug":"前端页面设计-1-基础知识","date":"2023-07-07T16:00:00.000Z","updated":"2023-08-06T11:12:22.712Z","comments":true,"path":"2023/07/08/前端页面设计-1-基础知识/","link":"https://blog.csdn.net/artly1/article/details/131286567?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2023/07/08/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1-1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}],"author":"artly1"},{"title":"计算机网络复习","slug":"计算机网络复习-1","date":"2022-12-20T16:00:00.000Z","updated":"2023-08-06T10:05:20.689Z","comments":true,"path":"2022/12/21/计算机网络复习-1/","link":"https://blog.csdn.net/artly1/article/details/128161905?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2022/12/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0-1/","excerpt":"","text":"","categories":[{"name":"计算机四大件","slug":"计算机四大件","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%9B%E5%A4%A7%E4%BB%B6/"},{"name":"计算机网络","slug":"计算机四大件/计算机网络","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"author":"artly1"},{"title":"mysql常用命令","slug":"mysql常用命令","date":"2022-12-17T16:00:00.000Z","updated":"2023-07-22T12:22:58.450Z","comments":true,"path":"2022/12/18/mysql常用命令/","link":"https://blog.csdn.net/artly1/article/details/128360916","permalink":"http://yoursite.com/2022/12/18/mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"","categories":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}],"author":"artly1"},{"title":"NVIDIA Sky Hackathon 训练模型安装","slug":"NVIDIA-Sky-Hackathon-训练模型安装","date":"2022-11-29T16:00:00.000Z","updated":"2023-08-06T10:14:35.819Z","comments":true,"path":"2022/11/30/NVIDIA-Sky-Hackathon-训练模型安装/","link":"https://blog.csdn.net/artly1/article/details/128095964?spm=1001.2014.3001.5502","permalink":"http://yoursite.com/2022/11/30/NVIDIA-Sky-Hackathon-%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E5%AE%89%E8%A3%85/","excerpt":"","text":"","categories":[{"name":"Hackathon","slug":"Hackathon","permalink":"http://yoursite.com/categories/Hackathon/"}],"tags":[{"name":"Hackathon","slug":"Hackathon","permalink":"http://yoursite.com/tags/Hackathon/"}],"author":"artly1"}],"categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"},{"name":"项目实战","slug":"项目实战","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"},{"name":"信息管理系统","slug":"项目实战/信息管理系统","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"数学建模","slug":"数学建模","permalink":"http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"算法","slug":"数学建模/算法","permalink":"http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E7%AE%97%E6%B3%95/"},{"name":"学生管理系统","slug":"项目实战/学生管理系统","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"计算机四大件","slug":"计算机四大件","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%9B%E5%A4%A7%E4%BB%B6/"},{"name":"数据结构与算法","slug":"计算机四大件/数据结构与算法","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"matlab","slug":"matlab","permalink":"http://yoursite.com/categories/matlab/"},{"name":"51单片机","slug":"51单片机","permalink":"http://yoursite.com/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"计算机网络","slug":"计算机四大件/计算机网络","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/categories/mysql/"},{"name":"Hackathon","slug":"Hackathon","permalink":"http://yoursite.com/categories/Hackathon/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"},{"name":"matlab","slug":"matlab","permalink":"http://yoursite.com/tags/matlab/"},{"name":"51单片机","slug":"51单片机","permalink":"http://yoursite.com/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Hackathon","slug":"Hackathon","permalink":"http://yoursite.com/tags/Hackathon/"}]}