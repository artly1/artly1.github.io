{"meta":{"title":"artly的小窝","subtitle":"","description":"test description","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2023-07-18T01:36:16.268Z","updated":"2023-07-18T01:36:16.268Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"哈喽😄，进来的朋友~首先感谢您来到我博客，再是您访问了这个页面来了解。 鄙人杨世豪，现就读于天津中德应用技术大学21级物联网工程专业。 中文常用昵称“夏漱石”，因为高中期间喜欢比较喜欢夏目漱石老师，再加上喜欢动漫，爱看fate，对历史人物人很有感触，就给自己取了这么一个名字，但后来这个名字容易撞车，就用自己另一个喜欢的动漫角色取了“artly1”这个名字。本人并不优秀，就是普普通通的一名学生，对于自己的未来依旧很迷茫，但怎么说呢，一步一步走走看吧。 目前这个博客主要用来总结自己系统学习的相关内容，内容也没有多深奥，主要是总结方便自己之后回忆。所以有巨佬请勿喷😵——以上。 Ps：如果想要交换友链的话，那就在下边留下你的信息。"},{"title":"所有分类","date":"2023-06-27T02:52:53.596Z","updated":"2023-06-27T02:52:53.596Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2023-06-27T02:42:54.000Z","updated":"2023-06-27T02:42:54.377Z","comments":true,"path":"archives/index.html","permalink":"http://yoursite.com/archives/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2023-06-27T02:57:53.373Z","updated":"2023-06-27T02:57:53.373Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":""},{"title":"Page","date":"2013-12-26T14:52:56.000Z","updated":"2023-03-31T12:13:05.237Z","comments":true,"path":"page/index.html","permalink":"http://yoursite.com/page/index.html","excerpt":"","text":"This is a page test."},{"title":"所有标签","date":"2023-06-27T02:52:01.217Z","updated":"2023-06-27T02:52:01.217Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"数据结构与算法","slug":"数据结构与算法","date":"2023-07-17T07:24:40.000Z","updated":"2023-07-18T08:19:52.075Z","comments":true,"path":"2023/07/17/数据结构与算法/","link":"","permalink":"http://yoursite.com/2023/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","excerpt":"","text":"第一章（数据结构和算法）数据结构 官方定义-没有统一 解决问题的方法效率，跟数据的组织方式有关 空间的使用 解决问题的方法效率，跟空间的利用率有关 算法的效率 解决问题的方法效率，跟算法的巧妙程度有关 抽象数据类型 算法 定义 1.一个有限指令集 2.接收一些输入 3.产生输出 4.在一定有限步骤后结束 5.每一条指令必须有充分明确的目标，不可以有歧义，在计算机处理范围内，描述不依赖于任何一种计算机语言以及具体的实现手段 算法的好坏 时间复杂度S（n）和空间复杂度T（n) 最坏情况复杂度T worst (n) 平均复杂度T avg (n) Tworst(n)&gt;&#x3D;Tavg(n 复杂度分析 复杂度分析的一些小窍门 T(n)是表示算法的时间复杂度。 O(n)是一种表示算法复杂度的符号,例如，T(n) &#x3D; O(n^2)表示算法的时间复杂度为n的平方。 f(n)”在算法复杂度分析中通常用来表示函数关于输入规模n的增长率,f(n)”可以是一个具体的函数,也可以是一个泛指的函数。 第二章(线性表 堆栈 队列)线性表 多项式表示 顺序储存结构直接表示 顺序储存结构表示非零项 每个多项式可以看成系数和指数二元组的集合 链式结构储存非零项 链表中每个节点储存一个非零项，每个节点包括两个数据域和一个指针域 coef expon link 系数 指数 next，指向下一个结构 123456789// 多项式结点的指针类型，用于表示一个多项式typedef struct PolyNode *Polynomial;// 多项式结点的定义struct PolyNode&#123; int cofe; // 系数（coefficient）：表示项的常数系数 int expon; // 指数（exponent）：表示项的幂次 Polynomial link; // 指向下一个项的指针（用于构建链表结构）&#125;; 链表的储存形式为： 线性表顺序储存 线性表是由同类型数据元素构成有序序列的线性集合 表中元素个数成为线性表的长度 表中若无元素，称之为空表 表中的起始位置称为表头，结束位置称为表尾 ​ 线性表的抽象数据类型描述 线性表利用数组连续存储空间的顺序存放线性表的各元素 123456789101112// 定义一个名为 List 的指向结构体 LNode 的指针类型typedef struct LNode* List;// 定义结构体 LNode，表示线性表struct LNode&#123; ElementType Data[Maxsize]; // ElementType 可以是任何你想存储的数据类型 int Last; // Last 表示线性表的最后一个元素的索引&#125;;// 声明一个结构体 LNode 类型的变量 L，用于创建线性表struct LNode L;// 声明一个 List 类型的指针变量 Ptrl，用于指向线性表的头节点List Ptrl; 访问下表为i的元素方法为：L.Data[i]或者PtrL-&gt;Data[i]线性表的长度为L.last+1或者PtrL-&gt;Last+1 初始化 12345678910111213// 函数名：MakeEmpty// 功能：创建一个空的线性表，并返回指向线性表头节点的指针// 返回值：返回指向线性表头节点的指针 ListList MakeEmpty()&#123; List PtrL; // 声明一个 List 类型的指针变量 PtrL，用于指向线性表的头节点 // 使用 malloc 分配内存来创建一个新的线性表头节点，并将其地址赋值给 PtrL PtrL = (List)malloc(sizeof(struct LNode)); // 初始化线性表，将 Last 设置为 -1，表示当前线性表为空 PtrL-&gt;Last = -1; // 返回指向新创建线性表头节点的指针 return PtrL;&#125; 查找 1234567891011121314151617181920// 函数名：Find// 功能：在线性表 PtrL 中查找元素 X 的位置// 参数：// - ElementType X: 要查找的元素// - List PtrL: 指向线性表头节点的指针// 返回值：// - 成功找到元素 X 返回其在线性表中的位置（索引），从 0 开始// - 没有找到元素 X 返回 -1int Find(ElementType X, List PtrL)&#123; int i = 0; // 初始化计数器 i，用于遍历线性表中的元素 // 循环遍历线性表，查找元素 X while (i &lt;= PtrL-&gt;Last &amp;&amp; PtrL-&gt;Data[i] != X) i++; // 若找到元素 X，则返回其在线性表中的位置（索引） if (i &gt; PtrL-&gt;Last) return -1; // 没有找到元素 X，返回 -1 else return i; // 成功找到元素 X，返回其位置（索引）&#125; 顺序储存的插入和删除 插入（在i的位置上插入一个值为X的元素（1&lt;&#x3D;i&lt;&#x3D;n+1) 先移动再插入 123456789101112131415161718192021222324252627282930313233// 函数名：Insert// 功能：向线性表 PtrL 中的第 i 个位置插入元素 X// 参数：// - ElementType X: 要插入的元素// - int i: 要插入的位置（索引），从 1 开始// - List PtrL: 指向线性表头节点的指针// 返回值：无void Insert(ElementType X, int i, List PtrL)&#123; int j; // 定义临时变量 j，用于循环中的计数 // 判断线性表是否已满，如果已满则无法插入元素 if (PtrL-&gt;Last == MAXSIZE - 1)//通过比较线性表的最后一个元素索引 Last 和线性表的最大容量 MAXSIZE-1 来判断线性表是否已满。 &#123; printf(&quot;该表已满&quot;); return; &#125; // 判断插入位置 i 是否合法 if (i &gt;= PtrL-&gt;Last + 2 || i &lt; 1)//检查插入位置 i 是否合法，不能超过当前线性表长度加 1，且不能小于 1。 &#123; printf(&quot;位置不合法&quot;); return; &#125; // 从后往前遍历线性表，将第 i 个位置及其后的元素都往后移动一个位置 for (j = PtrL-&gt;Last; j &gt;= i - 1; j--) &#123; PtrL-&gt;Data[j + 1] = PtrL-&gt;Data[j]; &#125; // 将元素 X 插入到第 i 个位置 // 注意：由于数组下标从 0 开始，而 i 从 1 开始计数，所以插入位置应为 i-1 PtrL-&gt;Data[i - 1] = X; // 更新线性表的最后一个元素的索引，将 Last 加 1，使其指向最后一个元素 PtrL-&gt;Last++;&#125; 删除操作(删除第i个元素）后面元素依次向前移动 123456789101112131415161718192021222324// 函数名：Delete// 功能：删除线性表 PtrL 中的第 i 个位置上的元素// 参数：// - int i: 要删除的位置（索引），从 1 开始// - List PtrL: 指向线性表头节点的指针// 返回值：无void Delete(int i, List PtrL)&#123; int j; // 定义临时变量 j，用于循环中的计数 // 检查插入位置 i 是否合法 if (i &gt;= PtrL-&gt;Last + 2 || i &lt; 1) &#123; printf(&quot;不存在第%d个元素&quot;, i); return; &#125; // 从第 i 个位置开始，将后面的元素依次往前移动一个位置 for (j = i; j &lt;= PtrL-&gt;Last; j++) &#123; PtrL-&gt;Data[j - 1] = PtrL-&gt;Data[j]; &#125; // 更新线性表的最后一个元素的索引，将 Last 减 1，表示删除了一个元素 PtrL-&gt;Last--; return;&#125; 链式储存和查找 链式储存解决了线性整体移动的问题，不要求逻辑上相邻的两个元素物理上也相邻，通过链建立数据元素之间的逻辑关系 插入删除不需要移动数据元素，只需要修改“链” 123456789101112// 定义指向结构体 LNode 的指针类型 Listtypedef struct LNode *List;// 定义结构体 LNode，表示链表节点struct LNode&#123; ElementType Data; // 存储节点的数据，ElementType 可以是任何你希望存储的数据类型 List Next; // 指向下一个节点的指针&#125;;// 声明一个结构体 LNode 类型的变量 L，用于创建链表的头节点struct LNode L;// 声明一个 List 类型的指针变量 PtrL，用于指向链表的头节点List PtrL; 求表长 12345678910111213141516171819// 函数名：Length// 功能：计算链表 PtrL 的长度（节点个数）// 参数：// - List PtrL: 指向链表头节点的指针// 返回值：链表的长度（节点个数）int Length(List PtrL)&#123; // 令 p 指向表的第一个节点，即头节点之后的第一个实际节点 List p = PtrL-&gt;Next; int j = 0; // 初始化计数器 j，用于记录节点个数 // 循环遍历链表，直到到达链表的结尾 while (p) &#123; p = p-&gt;Next; // 移动到下一个节点 j++; // 计数器 j 自增，记录节点个数 &#125; return j; // 返回计数器 j，即为链表的长度&#125; 查找 按序号查找 123456789101112131415161718192021222324// 函数名：Findkth// 功能：在链表 PtrL 中查找第 k 个节点// 参数：// - int k: 要查找的节点位置（索引），从 1 开始计数// - List PtrL: 指向链表头节点的指针// 返回值：// - 如果找到第 k 个节点，返回指向该节点的指针// - 如果没有找到第 k 个节点或链表为空，返回 NULLList Findkth(int k, List PtrL)&#123; List p = PtrL; // 令 p 指向链表的头节点 int i = 1; // 初始化计数器 i，用于记录当前节点的位置（索引） // 循环遍历链表，查找第 k 个节点或链表的结尾 while (p != NULL &amp;&amp; i &lt; k) &#123; p = p-&gt;Next; // 移动到下一个节点 i++; // 计数器 i 自增，记录当前节点的位置（索引） &#125; // 如果找到第 k 个节点，则返回指向该节点的指针 p if (i == k) return p; else return NULL; // 没有找到第 k 个节点或链表为空，返回 NULL&#125; 按值查找 // 函数名：Find // 功能：在链表 PtrL 中查找元素 X 的节点 // 参数： // - ElementType X: 要查找的元素 // - List PtrL: 指向链表头节点的指针 // 返回值： // - 如果找到元素 X 的节点，返回指向该节点的指针 // - 如果没有找到元素 X 或链表为空，返回 NULL List Find(ElementType X, List PtrL) &#123; List p = PtrL; // 令 p 指向链表的头节点 // 循环遍历链表，查找元素 X 的节点或链表的结尾 while (p != NULL &amp;&amp; p-&gt;Data != X) p = p-&gt;Next; // 移动到下一个节点 // 如果找到元素 X 的节点，则返回指向该节点的指针 p // 如果没有找到元素 X 或链表为空，则返回 NULL return p; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525. #### 链式储存的插入和删除- 插入操作（在第i个结点位置上插入一个值为X的新结点，换句话说就是在第i-1个结点后插入一个值为X的新节点） - 构造一个新结点用s指 - 找到链表的第i-1个结点，用p指 - 修改指针 ```c // 函数名：Insert // 功能：向链表 PtrL 的第 i 个位置插入元素 X // 参数： // - ElementType X: 要插入的元素 // - int i: 要插入的位置（索引），从 1 开始 // - List PtrL: 指向链表头节点的指针 // 返回值：返回指向链表头节点的指针 List Insert(ElementType X, int i, List PtrL) &#123; List p, s; // 在链表头插入元素 if (i == 1) &#123; // 申请一个新的节点 s s = (List)malloc(sizeof(struct LNode)); s-&gt;Data = X; s-&gt;Next = PtrL; // 返回指向新头节点 s 的指针，即链表的新头指针 return s; &#125; // 在其他位置插入元素 // 此处查找的节点为第 i-1 个节点 p = Findkth(i - 1, PtrL); // 如果第 i-1 个节点不存在 if (p == NULL) &#123; printf(&quot;参数出错&quot;); return NULL; &#125; else &#123; // 申请一个新的节点 s s = (List)malloc(sizeof(struct LNode)); s-&gt;Data = X; // 将新节点 s 插入到第 i-1 个节点后面 s-&gt;Next = p-&gt;Next; p-&gt;Next = s; // 返回原链表的头指针 PtrL，表示链表没有改变头节点 return PtrL; &#125; &#125; ![](https://cdn.jsdelivr.net/gh/artly1/Image/202307171636241.png) ​ 删除操作（删除第i个结点）（1&lt;&#x3D;i&lt;&#x3D;n) 先找到第i-1个结点，用p指向 然后用s指针指向第i个结点，即为p结点的下一个结点 修改指针，删除s所指向的结点 最后释放s所指向结点的空间free 12345678910111213141516171819202122232425262728293031323334353637383940414243// 函数名：Delete// 功能：删除链表 PtrL 中的第 i 个节点// 参数：// - int i: 要删除的节点位置（索引），从 1 开始// - List PtrL: 指向链表头节点的指针// 返回值：返回指向链表头节点的指针List Delete(int i, List PtrL)&#123; List p, s; // 删除头节点 if (i == 1) &#123; s = PtrL; // 如果链表不为空，将头指针后移一位 if (PtrL != NULL) PtrL = PtrL-&gt;Next; else return NULL; // 链表为空，返回空指针 free(s); // 释放原头节点的内存 return PtrL; // 返回新的头指针 &#125; // 删除其他位置的节点 // 查找第 i-1 个节点，即要删除位置的前一个节点 p = Findkth(i - 1, PtrL); // 如果第 i-1 个节点不存在 if (p == NULL) &#123; printf(&quot;第%d个结点不存在&quot;, i - 1); return NULL; &#125; else if (p-&gt;Next == NULL) &#123; printf(&quot;第%d个结点不存在&quot;, i); return NULL; &#125; else &#123; s = p-&gt;Next; // s 指向第 i 个节点 p-&gt;Next = s-&gt;Next; // 删除操作，将第 i-1 个节点的指针域 Next 指向第 i+1 个节点 free(s); // 释放第 i 个节点的内存 return PtrL; // 返回原链表的头指针 PtrL &#125;&#125; 广义表和多重链表一元多项式可以用上述式子表示，二元多项式又该如何表示？ 广义表是线性表的推广 对于线性表来说，n个元素都是基本的单元素 广义表中，这些元素不仅是单元素也可以是另一个广义表 12345678910111213// 定义指向结构体 GNode 的指针类型 GListtypedef struct GNode *GList;// 定义结构体 GNode，表示广义表的节点struct GNode&#123; int Tag; // 标志域，0 表示结点是单元素，1 表示结点是广义表 union//union：这是一个联合体，它是一种特殊的数据结构，允许在相同的内存位置存储不同类型的数据。在这里，union 中包含了两个成员：ElementType Data 和 GList Sublist。Data 用于存储单元素的数据，Sublist 用于存储子广义表的指针。 &#123; ElementType Data; // 数据域 Data，用于存储单元素数据 GList Sublist; // 指针域 Sublist，用于存储子广义表的指针 &#125; URegion; // 联合体，数据域 Data 和指针域 Sublist 复用存储空间 GList Next; // 指向后继结点的指针&#125;; 多重链表多重链表中的结点属于多个链 多重链表中的结点指针域有很多， 但是包含两个指针域的链表并不一定是多重链表， 比如双向链表不是多重链表 多重链表可以用在树和图中实现存储 堆栈什么是堆栈? 堆栈是具有一定操作约束的线性表，只在一端做插入，删除Last In First Out（LIFO）后入先出 中缀表达式：运算符位于两个数字之间 后缀表达式：运算符位于两个数字之后 抽象数据类型 原理图 堆栈的顺序存储栈的顺序存储结构通常是由一个一维数组和一个记录栈顶元素位置的变量组成 12345678910// 定义存储数据元素的最大值#define Maxsize &lt;存储数据元素的最大值&gt;// 定义指向结构体 SNode 的指针类型 Stacktypedef struct SNode *Stack;// 定义结构体 SNode，表示栈struct SNode&#123; ElementType Data[Maxsize]; // 用于存储数据元素的数组，数组大小为 Maxsize int Top; // 栈顶指针，表示栈顶元素在数组中的索引&#125;; 入栈 1234567891011121314151617181920// 函数名：Push// 功能：将元素 item 入栈// 参数：// - Stack PtrL: 指向栈的指针// - ElementType item: 要入栈的元素// 返回值：无void Push(Stack PtrL, ElementType item)&#123; // 检查栈是否已满 if (PtrL-&gt;Top == Maxsize - 1) &#123; printf(&quot;堆栈满&quot;); // 输出错误信息，表示栈已满 return; &#125; else &#123; PtrL-&gt;Data[++(PtrL-&gt;Top)] = item; // 将元素 item 入栈，栈顶指针 Top 自增 return; &#125;&#125; 出栈 123456789101112131415161718// 函数名：Pop// 功能：将栈顶元素出栈，并返回该元素的值// 参数：// - Stack PtrL: 指向栈的指针// 返回值：返回栈顶元素的值，如果栈为空，返回 ERROR（出错值）ElementType Pop(Stack PtrL)&#123; // 检查栈是否为空 if (PtrL-&gt;Top == -1) &#123; printf(&quot;堆栈空&quot;); // 输出错误信息，表示栈为空 return ERROR; // 返回 ERROR（出错值） &#125; else &#123; return (PtrL-&gt;Data[(PtrL-&gt;Top)--]); // 将栈顶元素出栈，并返回该元素的值，栈顶指针 Top 自减 &#125;&#125; 用数组实现两个堆栈，最大利用数组空间，若有空间则可以实现入栈 两个栈分别从数组的两头开始向中间生长，当两个栈的栈顶指针相遇时，表示两个栈都已经满 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 定义存储数据元素的最大个数#define MaxSize &lt;存储数据元素的最大个数&gt;// 定义结构体 DoubleStack，表示双栈struct DoubleStack &#123; ElementType Data[MaxSize]; // 用于存储数据元素的数组，数组大小为 MaxSize int Top1; // 栈1的栈顶指针 int Top2; // 栈2的栈顶指针&#125;;// 创建一个双栈 S，同时初始化栈1的栈顶指针 Top1 为 -1，栈2的栈顶指针 Top2 为 MaxSizestruct DoubleStack S;S.Top1 = -1;S.Top2 = MaxSize;// 函数名：Push// 功能：将元素 item 入栈// 参数：// - struct DoubleStack *PtrS: 指向双栈的指针// - ElementType item: 要入栈的元素// - int Tag: 表示入栈到哪个栈，Tag=1 表示栈1，Tag=2 表示栈2// 返回值：无void Push(struct DoubleStack *PtrS, ElementType item, int Tag) &#123; // 检查栈是否已满 if (PtrS-&gt;Top2 - PtrS-&gt;Top1 == 1) &#123; printf(&quot;堆栈满&quot;); // 输出错误信息，表示双栈已满 return; &#125; // 判断入栈到哪个栈，Tag=1 表示栈1，Tag=2 表示栈2 if (Tag == 1) PtrS-&gt;Data[++(PtrS-&gt;Top1)] = item; // 将元素 item 入栈到栈1，栈1的栈顶指针 Top1 自增 else PtrS-&gt;Data[--(PtrS-&gt;Top2)] = item; // 将元素 item 入栈到栈2，栈2的栈顶指针 Top2 自减&#125;// 函数名：Pop// 功能：将栈顶元素出栈，并返回该元素的值// 参数：// - struct DoubleStack *PtrS: 指向双栈的指针// - int Tag: 表示出栈哪个栈，Tag=1 表示栈1，Tag=2 表示栈2// 返回值：返回栈顶元素的值，如果栈为空，返回 NULL（出错值）ElementType Pop(struct DoubleStack *PtrS, int Tag) &#123; // 判断出栈哪个栈，Tag=1 表示栈1，Tag=2 表示栈2 if (Tag == 1) &#123; // 检查栈1是否为空 if (PtrS-&gt;Top1 == -1) &#123; printf(&quot;堆栈1空&quot;); // 输出错误信息，表示栈1为空 return NULL; // 返回 NULL（出错值） &#125; else return PtrS-&gt;Data[(PtrS-&gt;Top1)--]; // 将栈1的栈顶元素出栈，并返回该元素的值，栈1的栈顶指针 Top1 自减 &#125; else &#123; // 检查栈2是否为空 if (PtrS-&gt;Top2 == MaxSize) &#123; printf(&quot;堆栈空&quot;); // 输出错误信息，表示栈2为空 return NULL; // 返回 NULL（出错值） &#125; else return PtrS-&gt;Data[(PtrS-&gt;Top2)++]; // 将栈2的栈顶元素出栈，并返回该元素的值，栈2的栈顶指针 Top2 自增 &#125;&#125; 堆栈的链式存储 链式存储结构实际上就是一个单链表，叫做链栈，插入和删除操作只能在链栈的栈顶进行 12345678// 定义指向结构体 SNode 的指针类型 Stacktypedef struct SNode *Stack;// 定义结构体 SNode，表示栈节点struct SNode &#123; ElementType Data; // 数据域，用于存储栈节点的数据元素 struct SNode *Next; // 指针域，指向下一个栈节点的指针&#125;; 初始化 12345678910111213// 函数名：CreatStack// 功能：创建一个空栈，并返回指向栈顶节点的指针// 参数：无// 返回值：返回指向栈顶节点的指针Stack CreatStack()&#123; Stack s; // 声明一个指向栈节点的指针 s // 分配内存，创建一个栈节点 s = (Stack)malloc(sizeof(struct SNode)); // 初始化栈节点的指针域 Next 为 NULL，表示栈为空 s-&gt;Next = NULL; return s; // 返回指向栈顶节点的指针&#125; 判断堆栈s是否为空 1234int Empty(Stack s)&#123; return (s-&gt;Next == NULL);&#125; 入栈 1234567891011121314151617// 函数名：Push// 功能：将元素 item 入栈// 参数：// - ElementType item: 要入栈的元素// - Stack s: 指向栈顶节点的指针// 返回值：无void Push(ElementType item, Stack s)&#123; // 创建一个新的栈节点 struct SNode *Tmpcell; Tmpcell = (struct SNode *)malloc(sizeof(struct SNode)); // 设置新栈节点的数据域 Element 为要入栈的元素 item Tmpcell-&gt;Element = item; // 将新栈节点插入到栈顶节点之后 Tmpcell-&gt;Next = s-&gt;Next; s-&gt;Next = Tmpcell;&#125; 出栈 12345678910111213141516171819202122232425// 函数名：Pop// 功能：将栈顶元素出栈，并返回该元素的值// 参数：// - Stack s: 指向栈顶节点的指针// 返回值：返回栈顶元素的值，如果栈为空，返回 NULL（出错值）ElementType Pop(Stack s)&#123; struct SNode *Firstcell; // 声明一个指向栈节点的指针 Firstcell，用于暂存要出栈的栈顶节点 ElementType TopElement; // 声明一个变量 TopElement，用于存储要出栈的栈顶元素 // 检查栈是否为空 if (Empty(s)) &#123; printf(&quot;堆栈空&quot;); // 输出错误信息，表示栈为空 return NULL; // 返回 NULL（出错值） &#125; else &#123; // 将栈顶节点出栈，注意保存要删除的元素和栈顶元素 Firstcell = s-&gt;Next; // Firstcell 指向要删除的栈顶节点 s-&gt;Next = Firstcell-&gt;Next; // 将栈顶指针 Next 指向删除节点的下一个节点，即出栈操作 TopElement = Firstcell-&gt;Element; // 将要出栈的栈顶元素存储到 TopElement 中 free(Firstcell); // 释放删除的节点的内存，即释放栈顶节点的内存 return TopElement; // 返回栈顶元素的值 &#125;&#125; 堆栈的应用 中缀表达式转换为后缀表达式 运算数：直接输出 左括号：入栈 右括号：栈顶元素出栈并输出，直到遇到左括号 运算符：优先级大于栈顶运算符，入栈；优先级小于等于栈顶运算符出栈输出，继续比较新的栈顶运算符 处理完毕后，将堆栈剩余元素一并输出 队列 队列及顺序存储具有一定操作约束的线性表 插入和删除操作：只能在一端插入，而在另一端删除 数据插入：入队列 数据删除：出队列 先进先出（FIFO）First In First Out 抽象数据描述 队列存储的实现 队列的顺序存储结构通常由一个一维数组和一个记录队列头元素位置的变量ront以及一个记录队列尾元素位置的变量rear组成 1234567891011// 定义存储数据元素的最大个数#define Maxsize &lt;数据元素的最大个数&gt;// 定义队列结构体 QNodestruct QNode &#123; ElementType Data[Maxsize]; // 用于存储数据元素的数组，数组大小为 Maxsize int rear; // 队尾指针，指向队列最后一个元素的下标 int front; // 队首指针，指向队列第一个元素之前的位置&#125;;// 定义指向队列结构体 QNode 的指针类型 Queuetypedef struct QNode *Queue;// front 指的是第一个元素之前的位置 在顺环队列判断是否满的问题上使用额外标记Tag域或者Size 入队 1234567891011121314151617// 函数名：AddQ// 功能：向队列尾部添加元素// 参数：// - Queue PtrL: 指向队列的指针// - ElementType item: 要添加的元素// 返回值：无void AddQ(Queue PtrQ, ElementType item)&#123; // 检查队列是否已满 if ((PtrQ-&gt;rear + 1) % Maxsize == PtrQ-&gt;front) &#123; printf(&quot;队列满&quot;); // 输出错误信息，表示队列已满 return; // 返回，不执行入队操作 &#125; // 将队尾指针后移一位，考虑循环队列的情况 PtrQ-&gt;rear = (PtrQ-&gt;rear + 1) % Maxsize; 出队 123456789101112131415161718192021// 函数名：DQ// 功能：从队列头部删除元素，并返回该元素的值// 参数：// - Queue PtrQ: 指向队列的指针// 返回值：返回队列头部元素的值，如果队列为空，返回 ERROR（出错值）ElementType DQ(Queue PtrQ)&#123; // 检查队列是否为空 if (PtrQ-&gt;rear == PtrQ-&gt;front) &#123; printf(&quot;队列空&quot;); // 输出错误信息，表示队列为空 return ERROR; // 返回 ERROR（出错值） &#125; else &#123; // 将队首指针后移一位，考虑循环队列的情况 PtrQ-&gt;front = (PtrQ-&gt;front + 1) % Maxsize; // 返回队列头部元素的值 return PtrQ-&gt;Data[PtrQ-&gt;front]; &#125;&#125; 队列的链式存储1234567891011121314// 定义链式队列节点结构体 Nodestruct Node &#123; ElementType Data; // 数据域，用于存储节点的数据元素 struct Node *Next; // 指针域，指向下一个节点的指针&#125;;// 定义链式队列结构体 QNodestruct QNode &#123; struct Node *rear; // 队尾指针，指向队列中最后一个元素的节点 struct Node *front; // 队首指针，指向队列中第一个元素的节点&#125;;// 定义指向链式队列结构体 QNode 的指针类型 Queuetypedef struct QNode *Queue;// 声明一个指向链式队列结构体 QNode 的指针 PtrQQueue PtrQ; 出队 12345678910111213141516171819202122232425262728// 函数名：DQ// 功能：从队列头部删除元素，并返回该元素的值// 参数：// - Queue PtrQ: 指向链式队列的指针// 返回值：返回队列头部元素的值，如果队列为空，返回 ERROR（出错值）ElementType DQ(Queue PtrQ)&#123; struct Node *Frontcell; // 声明一个指向链式队列节点的指针 Frontcell，用于暂存要出队的节点 ElementType Frontelement; // 声明一个变量 Frontelement，用于存储要出队的队列头部元素 // 检查队列是否为空 if (PtrQ-&gt;front == NULL) &#123; printf(&quot;空&quot;); // 输出错误信息，表示队列为空 return ERROR; // 返回 ERROR（出错值） &#125; // 将队首节点出队 Frontcell = PtrQ-&gt;front; // Frontcell 指向要出队的队列头部节点 // 分情况讨论，队列只有一个元素和多个元素 if (PtrQ-&gt;front == PtrQ-&gt;rear) PtrQ-&gt;front = PtrQ-&gt;rear = NULL; // 如果队列只有一个元素，出队后将队首指针和队尾指针都设置为 NULL，表示队列为空 else PtrQ-&gt;front = PtrQ-&gt;front-&gt;Next; // 如果队列有多个元素，将队首指针后移，即将第二个节点设置为队首节点 Frontelement = Frontcell-&gt;Data; // 将要出队的队列头部元素存储到 Frontelement 中 free(Frontcell); // 释放出队的节点的内存，即释放队列头部节点的内存 return Frontelement; // 返回队列头部元素的值，表示成功出队&#125; 多项式问题 加法运算的实现采用不带头结点的单项链表。按照指数递减的顺序排列各项 1234567struct PolyNode&#123; int coef;//系数 int expon;//指数 struct PolyNode *link;&#125;;typedef struct PolyNode *Polynomial;Polynomial P1,P2; 算法思路P1-&gt;expon&#x3D;&#x3D;P2-&gt;expon:系数相加，若结果不为0，则作为结果多项式对应系数。同时，P1和P2 都指向下一项P1-&gt;expon&gt;P2-&gt;expon将P1存入当前多项式，并使P1指向下一项P1-&gt;expon &lt; P2-&gt;expon将P2存入当前多项式，并使P2指向下一项 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 函数名：Polynomial Polyadd(Polynomial P1, Polynomial P2)// 功能：多项式相加// 参数：// - Polynomial P1: 第一个多项式的头结点指针// - Polynomial P2: 第二个多项式的头结点指针// 返回值：返回多项式相加后的结果多项式的头结点指针Polynomial Polyadd(Polynomial P1, Polynomial P2)&#123; Polynomial front, rear, temp; int sum; rear = (Polynomial)malloc(sizeof(struct PolyNode)); front = rear; // front 这里指的是多项式链表头结点 while (P1 &amp;&amp; P2) &#123; switch (Compare(P1-&gt;expon, P2-&gt;expon)) &#123; case 1: Attach(P1-&gt;coef, P1-&gt;expon, &amp;rear); P1 = P1-&gt;link; break; case -1: Attach(P2-&gt;coef, P2-&gt;expon, &amp;rear); P2 = P2-&gt;link; break; case 0: sum = P1-&gt;coef + P2-&gt;coef; if (sum) Attach(sum, P1-&gt;expon, &amp;rear); P1 = P1-&gt;link; P2 = P2-&gt;link; break; &#125; &#125; // 还有未处理完的另一个多项式的所有结点依此复制 for (; P1; P1 = P1-&gt;link) Attach(P1-&gt;coef, P1-&gt;expon, &amp;rear); for (; P2; P2 = P2-&gt;link) Attach(P2-&gt;coef, P2-&gt;expon, &amp;rear); rear-&gt;link = NULL; // 将链表最后一个节点的 next 指针置为 NULL，表示链表结束 temp = front; front = front-&gt;link; // 头结点的下一个节点即为结果多项式的头结点 free(temp); // 释放头结点的内存，防止内存泄漏 return front; // 返回结果多项式的头结点指针&#125;// 函数名：void Attach(int c, int e, Polynomial *pRear)// 功能：将系数为 c，指数为 e 的节点添加到链表中// 参数：// - int c: 系数值// - int e: 指数值// - Polynomial *pRear: 链表尾节点的指针的指针，用于更新链表尾节点// 返回值：无void Attach(int c, int e, Polynomial *pRear)&#123; Polynomial P; P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;coef = c; P-&gt;expon = e; P-&gt;link = NULL; (*pRear)-&gt;link = P; *pRear = P; // 修改 pRear 值，使其指向链表尾部节点，以便下次添加节点时可以直接在尾部插入&#125; 题意理解与多项式表示 数据结构设计 12345678910111213// 定义多项式结点指针类型 Polynomial，是指向 struct PolyNode 结构体的指针typedef struct PolyNode *Polynomial;// 定义多项式结点结构体 PolyNodestruct PolyNode&#123; int coef; // 系数，用于存储多项式项的系数值 int expon; // 指数，用于存储多项式项的指数值 Polynomial link; // 指向下一个多项式结点的指针，用于将多项式的各项连接在一起&#125;;// 这个代码片段定义了一个简单的链式存储结构用于表示多项式。// 多项式的每一项包含两个部分：系数 coef 和指数 expon。// 用链表将各项连接在一起，每个节点通过 link 指针指向下一个节点。// 多项式的头结点可以用 Polynomial 类型的指针来表示，即指向第一个多项式节点的指针。 程序框架及读入多项式 123456789101112131415161718192021// 函数名：main// 功能：主函数，用于调用多项式相关函数// 返回值：整数类型，表示程序的结束状态int main()&#123; // 声明多项式 P1, P2, PP, PS Polynomial P1, P2, PP, PS; // 读入第一个多项式 P1 P1 = ReadPoly(); // 读入第二个多项式 P2 P2 = ReadPoly(); // 将两个多项式 P1 和 P2 相乘，结果存储在 PP 中 PP = Mult(P1, P2); // 打印相乘结果多项式 PP PrintPoly(PP); // 将两个多项式 P1 和 P2 相加，结果存储在 PS 中 PS = Add(P1, P2); // 打印相加结果多项式 PS PrintPoly(PS); return 0; // 返回程序的结束状态，表示成功执行&#125; 读取多项式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 函数名：Polynomial ReadPoly()// 功能：读取一个多项式，并以链表形式返回该多项式的头结点指针// 返回值：多项式的头结点指针Polynomial ReadPoly()&#123; // 声明多项式头结点指针 P, Rear 和临时指针 t Polynomial P, Rear, t; int c, e, N; // 从标准输入读取多项式的项数 N scanf(&quot;%d&quot;, &amp;N); // 创建链表头空结点 P，Rear 指向头结点 P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;link = NULL; Rear = P; // 依次读入 N 个多项式项，并将其插入链表尾部 while (N--) &#123; scanf(&quot;%d %d&quot;, &amp;c, &amp;e); Attach(c, e, &amp;Rear); // 将当前项插入多项式尾部 &#125; // 删除临时生成的头结点，并将链表的真正头结点指针 P 返回 t = P; P = P-&gt;link; free(t); return P;&#125;// 函数名：void Attach(int c, int e, Polynomial *pRear)// 功能：将系数为 c，指数为 e 的节点添加到链表中// 参数：// - int c: 系数值// - int e: 指数值// - Polynomial *pRear: 链表尾节点的指针的指针，用于更新链表尾节点// 返回值：无void Attach(int c, int e, Polynomial *pRear)&#123; // 创建新的多项式节点 P，并分别赋值系数和指数 Polynomial P; P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;coef = c; P-&gt;expon = e; P-&gt;link = NULL; // 将新节点 P 插入链表尾部，更新链表尾节点指针 pRear (*pRear)-&gt;link = P; *pRear = P;&#125; 加法乘法及多项式的输出 上面已经写过此代码 两个多项式相乘 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// 函数名：Polynomial Mult(Polynomial P1, Polynomial P2)// 功能：计算两个多项式 P1 和 P2 的乘积，结果以链表形式返回// 参数：// - Polynomial P1: 第一个多项式的头结点指针// - Polynomial P2: 第二个多项式的头结点指针// 返回值：多项式的头结点指针，表示乘积多项式Polynomial Mult(Polynomial P1, Polynomial P2)&#123; // 声明多项式头结点指针 P, Rear 和临时指针 t1, t2, t Polynomial P, Rear, t1, t2, t; int c, e; // 如果 P1 或 P2 为空，则返回空指针 if (!P1 || !P2) return NULL; // 复制 P1 的头结点，用于计算结果多项式 P t1 = P1; // 复制 P2 的头结点，用于遍历 P2 t2 = P2; // 创建链表头空结点 P，Rear 指向头结点 P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;link = NULL; Rear = P; // 第一重循环，计算 P1 的第一项和 P2 的每一项的乘积，插入到结果多项式 P 中 while (t2) &#123; // 将 P1 的第一项与 P2 的当前项相乘，并将结果插入到结果多项式 P 中 Attach(t1-&gt;coef * t2-&gt;coef, t1-&gt;expon + t2-&gt;expon, &amp;Rear); // 将 P2 的指针 t2 后移，继续处理下一项 t2 = t2-&gt;link; &#125; // 将 P1 的指针 t1 后移，继续处理下一项 t1 = t1-&gt;link; // 第二重循环，计算 P1 的每一项和 P2 的每一项的乘积，插入到结果多项式 P 中 while (t1) &#123; // 重新将 P2 的指针 t2 移回 P2 的头结点，并将 Rear 指针指向结果多项式 P 的头结点 t2 = P2; Rear = P; // 遍历 P2，计算 P1 的当前项与 P2 的每一项的乘积，并插入到结果多项式 P 中 while (t2) &#123; // 计算当前项的指数和系数 e = t1-&gt;expon + t2-&gt;expon; c = t1-&gt;coef * t2-&gt;coef; // 找到合适的位置插入或处理相等指数的情况 while (Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon &gt; e) Rear = Rear-&gt;link; // 处理相等指数的情况，相同指数项的系数相加 if (Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon == e) &#123; if (Rear-&gt;link-&gt;coef == c) Rear-&gt;link-&gt;coef += c; else &#123; // 删除节点，系数为 0 的项 t = Rear-&gt;link; Rear-&gt;link = t-&gt;link; free(t); &#125; &#125; // 不相等则申请新的结点并插入 else &#123; t = (Polynomial)malloc(sizeof(struct PolyNode)); t-&gt;coef = c; t-&gt;expon = e; // 插入过程 t-&gt;link = Rear-&gt;link; Rear-&gt;link = t; Rear = Rear-&gt;link; &#125; t2 = t2-&gt;link; &#125; // 处理完 P1 的一项，将指针后移，继续处理下一项 t1 = t1-&gt;link; &#125; // 删除临时生成的头结点，并将链表的真正头结点指针 P 返回 t2 = P; P = P-&gt;link; free(t2); return P;&#125; 多项式输出 12345678910111213141516171819202122232425262728293031// 函数名：void PrintPoly(Polynomial P)// 功能：打印多项式 P 的系数和指数// 参数：// - Polynomial P: 多项式的头结点指针// 返回值：无void PrintPoly(Polynomial P)&#123; int flag = 0; // flag 用于调整输出格式，初始为 0 // 如果多项式为空，则打印 &quot;0 0&quot; 表示零多项式，并直接返回 if (!P) &#123; printf(&quot;0 0\\n&quot;); return; &#125; // 遍历多项式链表并输出系数和指数 while (P) &#123; // 当 flag 为 0 时，输出第一项，不加空格；否则输出空格 if (!flag) flag = 1; else printf(&quot; &quot;); // 输出当前多项式节点的系数和指数 printf(&quot;%d %d&quot;, P-&gt;coef, P-&gt;expon); // 指针后移，处理下一项 P = P-&gt;link; &#125; // 打印完所有项后换行 printf(&quot;\\n&quot;);&#125; 第三章树与树的表示 顺序查找 查找：根据给定某个关键字K，从集合R中找出关键字与K相同的记录 静态查找：集合中记录是固定的，没有删除和插入操作只有查找操作 动态查找：集合中记录是动态的，除了查找操作，还可能有删除和插入操作&#96; 12345678910// 定义一个指向结构体 LNode 的指针类型 Listtypedef struct LNode* List;// 定义结构体 LNodestruct LNode &#123; // 数据域，用于存储元素的数组 ElementType Element[Maxsize]; // 当前线性表的长度 int length;&#125;; 有哨兵 1234567891011121314151617// 在顺序表 Tb1 中进行顺序查找元素 K 的位置// 参数：// - List Tb1: 顺序表的指针，表示要进行查找的顺序表// - ElementType K: 要查找的元素// 返回值：// - 如果找到元素 K，返回其在顺序表 Tb1 中的位置；如果未找到，返回 -1。int SequentialSearch(List Tb1, ElementType K)&#123; int i; // 将要查找的元素 K 放在顺序表 Tb1 的第一个位置，作为哨兵 Tb1-&gt;Element[0] = K; // 从顺序表的末尾开始逆序遍历，查找元素 K 的位置 for (i = Tb1-&gt;length; Tb1-&gt;Element[i] != K; i--); // 如果 i 等于 0，说明未找到元素 K，返回 -1 // 否则返回找到的元素 K 在顺序表 Tb1 中的位置 return i ;&#125; 无哨兵 123456789101112131415// 在顺序表 Tb1 中进行顺序查找元素 K 的位置// 参数：// - List Tb1: 顺序表的指针，表示要进行查找的顺序表// - ElementType K: 要查找的元素// 返回值：// - 如果找到元素 K，返回其在顺序表 Tb1 中的位置；如果未找到，返回 -1。int SequentialSearch(List Tb1, ElementType K)&#123; int i; // 从顺序表的末尾开始逆序遍历，查找元素 K 的位置 for (i = Tb1-&gt;length; i &gt; 0 &amp;&amp; Tb1-&gt;Element[i] != K; i--); // 如果 i 等于 0，说明未找到元素 K，返回 -1 // 否则返回找到的元素 K 在顺序表 Tb1 中的位置 return i == 0 ? -1 : i;&#125; 二分查找（Binary Search）要求：数组连续，有序思路：利用mid，right，left三者的比较缩小范围，查找值left&gt;right?查找失败：结束;复杂度：log（n） 1234567891011121314151617181920212223242526272829// 在有序顺序表 Tb1 中进行二分查找元素 K 的位置// 参数：// - List Tb1: 有序顺序表的指针，表示要进行查找的顺序表// - ElementType K: 要查找的元素// 返回值：// - 如果找到元素 K，返回其在顺序表 Tb1 中的位置（数组下标）；如果未找到，返回 -1。int BinarySearch(List Tb1, ElementType K)&#123; int mid, right, left, notFound = -1; left = 1; // 左边界，初始为第一个元素位置 right = Tb1-&gt;length; // 右边界，初始为最后一个元素位置 mid = (left + right) / 2; // 中间位置 while (left &lt;= right) &#123; // 如果中间元素大于要查找的元素 K，说明要查找的元素在左半部分 if (Tb1-&gt;Element[mid] &gt; K) right = mid - 1; // 如果中间元素小于要查找的元素 K，说明要查找的元素在右半部分 else if (Tb1-&gt;Element[mid] &lt; K) left = mid + 1; // 查找成功，返回元素 K 的位置（数组下标） else return mid; // 更新中间位置 mid = (left + right) / 2; &#125; // 循环结束仍未找到，返回未找到标志 -1 return notFound;&#125; 树的定义和表示 定义：树是由n（n&gt;&#x3D;0）个结点构成的有限集合 每一个树都有一个根结点（root），用r表示 其余结点可以分为数个互不相交的有限集合，每个集合又是一个树，称为原来树的子树 每颗树的子树互不相交，除了根结点外，每个结点只有一个父结点，每个有N个结点的树有N-1条边 树的一些基本术语： 结点的度：结点的子树个数。 树的度: 是所有结点中最大的度数。 节点的层次：规定根结点在一层，其他任一节点层次是其父结点的层次＋1 树的深度：树中所有结点的最大层次 二叉树及存储结构 二叉树的定义和性质定义：有穷的集合 集合可以为空 若不为空，则有左子树和右子树两个互不交叉的二叉树 性质： 一个二叉树第i层最大的结点数为2^i-1^ ,i&gt;&#x3D;1 深为k的二叉树最大的结点数为2^k-1^ ，k&gt;&#x3D;1 对于任意非空二叉树，n0代表叶结点个数，n2代表度数为2的非叶结点个数，那么满足n0&#x3D;n2+1 二叉树的存储结构 顺序存储结构完全二叉树：按照从上到下，从左到右的顺序存储n个节点完全二叉树的父子结点关系 非根结点序号为i&#x2F;2 序号结点为i的左孩子结点的序号为2i 序号结点为i的右孩子结点的序号为2i+1 一般二叉树采用此种存储方法会造成空间的浪费 链表存储结构 1234567891011// 定义二叉树结点的结构体，使用 typedef 别名 BinTree 表示指向该结构体的指针类型typedef struct TreeNode *BinTree;// 使用别名 Position 表示指向二叉树结点的指针类型typedef BinTree Position;// 定义二叉树结点的结构体struct TreeNode&#123; ElementType Data; // 存储结点的数据 BinTree Left; // 左子树的指针 BinTree Right; // 右子树的指针&#125;; 二叉树的遍历 先序 中序 后序 先序访问根结点遍历左子树遍历右子树 123456789101112131415161718// 前序遍历二叉树// 参数：// - BinTree BT: 二叉树的根结点指针// 返回值：// - 无，函数用于打印二叉树的前序遍历结果。void PreorderTraversal(BinTree BT)&#123; // 判断当前结点是否为空 if (BT) &#123; // 如果当前结点不为空，打印当前结点的数据 printf(&quot;%d &quot;, BT-&gt;Data); // 递归遍历左子树 PreorderTraversal(BT-&gt;Left); // 递归遍历右子树 PreorderTraversal(BT-&gt;Right); &#125;&#125; 中序遍历左子树访问根结点遍历右子树 123456789101112131415161718// 中序遍历二叉树// 参数：// - BinTree BT: 二叉树的根结点指针// 返回值：// - 无，函数用于打印二叉树的中序遍历结果。void InorderTraversal(BinTree BT)&#123; // 判断当前结点是否为空 if (BT) &#123; // 递归遍历左子树 InorderTraversal(BT-&gt;Left); // 如果当前结点不为空，打印当前结点的数据 printf(&quot;%d &quot;, BT-&gt;Data); // 递归遍历右子树 InorderTraversal(BT-&gt;Right); &#125;&#125; 后序遍历左子树遍历右子树访问根结点 123456789101112131415161718// 后序遍历二叉树// 参数：// - BinTree BT: 二叉树的根结点指针// 返回值：// - 无，函数用于打印二叉树的后序遍历结果。void PostorderTraversal(BinTree BT)&#123; // 判断当前结点是否为空 if (BT) &#123; // 递归遍历左子树 PostorderTraversal(BT-&gt;Left); // 递归遍历右子树 PostorderTraversal(BT-&gt;Right); // 如果当前结点不为空，打印当前结点的数据 printf(&quot;%d &quot;, BT-&gt;Data); &#125;&#125; 中序非递归思路：利用堆栈 遇到一个结点就把它堆栈，然后遍历其左子树 遍历完左子树后将该结点弹出并访问 利用有指针中序遍历该结点右子树 123456789101112131415161718192021222324// 中序遍历二叉树（非递归版本）// 参数：// - BinTree BT: 二叉树的根结点指针// 返回值：// - 无，函数用于打印二叉树的中序遍历结果。void InorderTraversal(BinTree BT)&#123; BinTree T = BT; // 定义辅助指针T，初始指向根结点 Stack S = CreatStack(MaxSize); // 创建一个栈S，用于辅助遍历 while (T || !isEmpty(S)) // 当T不为空或栈S不为空时继续遍历 &#123; while (T) // 将指针T沿左子树一直向下，直到叶子结点 &#123; Push(S, T); // 将结点指针T入栈 T = T-&gt;Left; // 移动指针T指向左孩子结点 &#125; if (!isEmpty(S)) // 当栈S不为空时，弹出栈顶元素 &#123; T = Pop(S); // 弹出并取出栈顶元素，赋值给指针T printf(&quot;%5d&quot;, T-&gt;Data); // 打印当前结点的数据 T = T-&gt;Right; // 将指针T指向当前结点的右孩子结点 &#125; &#125; 层序思路：利用队列层序基本过程：遍历从根结点开始，首先将根结点入队，然后执行循环：结点出队，访问该结点，其左右儿子入队 123456789101112131415161718192021222324// 层序遍历二叉树// 参数：// - BinTree BT: 二叉树的根结点指针// 返回值：// - 无，函数用于打印二叉树的层序遍历结果。void LevelOrderTraversal(BinTree BT)&#123; BinTree T; // 定义辅助指针T，用于遍历二叉树的结点 Queue Q; // 定义队列Q，用于存储待遍历的结点 if (!BT) return; // 若二叉树为空树，直接返回 // 初始化队列 Q = CreatQueue(MaxSize); AddQ(Q, BT); // 将根结点入队列 while (!isEmpty(Q)) &#123; // 取出队列的头结点，并访问该结点 T = DeletQ(Q); printf(&quot;%5d&quot;, T-&gt;Data); // 如果当前结点有左子节点，将左子节点入队列 if (T-&gt;Left) AddQ(Q, T-&gt;Left); // 如果当前结点有右子节点，将右子节点入队列 if (T-&gt;Right) AddQ(Q, T-&gt;Right); &#125;&#125; 例求二叉树高度123456789101112131415161718192021222324// 中序遍历二叉树并计算二叉树的高度// 参数：// - BinTree BT: 二叉树的根结点指针// 返回值：// - int: 二叉树的高度int InOrderTraversal(BinTree BT)&#123; int Hr, Hl, Maxh; if (BT) &#123; // 递归遍历左子树，并获取左子树的高度 Hl = InOrderTraversal(BT-&gt;Left); // 递归遍历右子树，并获取右子树的高度 Hr = InOrderTraversal(BT-&gt;Right); // 计算当前树的高度，即左右子树高度的最大值加1（加1是因为要算上当前结点） Maxh = (Hl &gt; Hr ? Hl : Hr) + 1; return Maxh; &#125; else &#123; // 代表该树为空树，高度为0 return 0; &#125;&#125;","categories":[{"name":"计算机四大件","slug":"计算机四大件","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%9B%E5%A4%A7%E4%BB%B6/"},{"name":"数据结构与算法","slug":"计算机四大件/数据结构与算法","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"","slug":"计算机网络复习","date":"2023-07-15T08:02:41.187Z","updated":"2023-07-15T08:03:16.756Z","comments":true,"path":"2023/07/15/计算机网络复习/","link":"","permalink":"http://yoursite.com/2023/07/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"计算机网络 一.计算机网络概述 计算机网络的概念：（*） 1.计算机网络的定义： 计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路链接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。 2.计算机网络的组成： 终端系统/资源子网：提供共享的软件资源和硬件资源通信子网：提供信息交换的网络结点和通信线路。 3.计算机网络的类型： 按照拓朴分类： 星型结构 树形结构 总线型结构 环形结构 网状结构按照范围分类：局域网LAN 城域网MAN 广域网 WAN 补充：个人区域网PAN 互联网Internet按照传输方式分类：有线网络（IEEE802.3） 无线网络：（ IEEE802.11 WLAN无线局域网（wireless） WPAN无线个域网） 计算机网络体系结构 1.传输方式： 按照传输的方向分： 单工：只能单方向传输的工作模式双工：在同一时间，线路上只能允许一个方向的数据通过全双工：双方可以同时进行数据通信按照传输对象（方式）分： 单播： 1对1多播：1对多广播：1对all 2.数据交换： 电路交换：整个报文从源头到终点连续的传输报文交换：整个报文先传达到相邻节点，全部存储下来查找转发表，再转发到下一个节点分组交换：将一个报文分成多个分组，传送到相邻结点，在查找转发表，在转发到下一个结点 3.通信协议和体系结构： 网络协议三要素：语法 语义 时序OSI参考模型： 应用层：使用应用程序通过网络服务。表示层：表示层用于处理交互数据的表示方式，例如格式转换，数据的加密和解密，数据压缩和回复等功能会话层：负责维护通信中两个结点之间的会话建立维护和断开，以及数据的交换传输层：提供端到端之间的数据传输服务，实现对数据进行控制和操作的功能。网络层：单位 分组，在数据链路层的基础之上，提供点到点之间的通信，提供路由功能，实现拥塞控制，网络互联等功能。数据链路层：单位 帧，在物理层的基础之上，提供结点到结点之间的服务，采取差错控制和流量控制的方法实现网路互联物理层：单位bit，利用传输介质为通信的网络节点之间的建立TCP/IP参考模型： 网络接口层：物理层和数据链路层网际层：网络层传输层应用层：会话层，表示层，应用层 二.物理层 1.物理层的基本概念： 1.1四大特性：（***） 机械特性：接口是怎么样的电气特性：用多少伏的电功能特性：线路上电平电压的特性过程特性：实现不同功能所发射信号的顺序 1.2两种信号： 模拟信号—特定频段的信号—有更加丰富的表现形式------抗干扰能力弱数字信号—不是1就是0--------抗干扰能力强 1.3调制和编码： 调制：模拟信号转换编码： 数字信号转换编码的步骤：采样 量化 编码区别： 数据可以通过编码手段转成数字信号，也可以通过调制手段将数据转成模拟型号。数字数据可以通过数字发送器转化为数字信号（编码），也可以通过调制器转化为模拟信号。模拟信号可以通过PCM编码器转化为数字信号（编码），也可以通过放大器调制器转化为模拟型号（调制）。 1.4传输介质： 双绞线： 传输距离100-500（中继器 最多四个，超过就失真了）屏蔽双绞线STP：抗干扰强，贵一些非屏蔽双绞线：便宜，抗干扰差制作标准：568B：橙白，橙，绿白，蓝，蓝白，绿，棕白，棕 ：八种568A：13，26调换—绿白，绿，绿白，蓝，蓝白，橙，棕白，棕 光纤： 多模光纤： 芯较粗（50或62.5）。可以传多种模式的光。但其模间色散较大，这就限制了传输数字信号的频率，而且随距离的增加会更加的严重。例如：600MB/KM的光纤在2KM时只有300MB的宽带了。因此多模光纤传输距离就比较的近，一般只有几公里。距离：2KM单模光纤： 单模光纤：中间纤芯很细（芯径一般是8-10），只能传一种模式的光，因此。其模间色散很小，适合语远程通讯，但还存在着材料色散和波导色散，这样单模光纤对光源的谱宽和稳定性有较高的要求，即谱宽要窄。稳定性要好。距离：100KM 同轴电缆：淘汰了 无线：无线信号频率 IEEE802.11 1.5三大部分： 源系统：发送数据的一端传输系统：传输过程中的各种传输介质目的系统：接收数据的电脑 2.物理层的基本通信技术 2.1四种信道复用技术 2.1.1复用技术 复用技术是指一种在传输路径上综合多路道信道，然后恢复原机制或则解除终端各信道复用技术的过程将多种不同的信号在同一信道上进行传输，复用技术主要是用来解决不同信号传输时应该如何区分。 2.1.2频分复用FDM 频分多路复用，是在适于某种传输媒介的传输频带内，若干个频谱互不重叠的信号一并传输的方式，简称FDM。在每路信号进入传输频带前，先要以此搬移频率（调制），而在接收端，在搬回到原来的频段，恢复每路的原信号，从而使传输频带得到多路信号的复用。划分不同频率来并行传输信号 2.1.3时分复用TDM 时分复用TDM是采用同一物理连接的不同时段来传输不同的信号，也能达到多路传输的此目的。时分多路复用以时间作为信号分割的参量，故必须使各路信号在时间轴上互不重叠。时分复用TDM就是将提供给整个信道传输信息的时间划分为若干时间片（简称时隙），并将这些时隙分给每一个信号源使用划分不同的时间段来传输信号 2.1.4波分复用WDM（波） 是将两种或多种不i同波长的光载波信号（携带各种信息）在发送端经复用器（亦称合波器）汇合在一起，并耦合到光线路的同一根光纤中进行传输技术根据光波的波长进行传输（合波器耦合） 2.1.5码分复用 码分复用CDM是靠不同的编码来区分各路原始信号的一种复用方式，主要和各种多址技术结合产生了各种接入技术，包括无线和有线接入。在同一时间同一频率根据传输的数据码进行区分 2.数据传输方式 2.1通过同时间传输数量分为 串行传输 使用一条数据线，将数据一位一位的依次输入，每一位数据占据一个固定的时间长度。只需要少数几条先就可以在系统间交换信息，特别适用于计算机语计算机，外设之间的远距离通信。并行传输 并行传输指的是数据以成组的方式，在多条并行信道上同时进行传输，是在传输中有多个数据位同时在设备之间进行的传输。 2.2通过数据报文的双方的行为分为 同步传输 同步：在计算机网络中，定时的因素称为位同步。同步是要接收按照发送放放送的每个位的起止时刻和速率来接受数据，否则会产生误差。同步传输的比特分组要大得多。他不会独立的发送每个字符，每个字符都有自己的开始位和停止位，而是把他们组合起来发送。我们将这些组合称为数据帧，或简称帧异步传输： 异步传输将比特分成小组进行传输，小组可以是8位的1个字符或更长。发送方可以在任何时刻发送这些比特组，而接受方从不知道它们会在什么时候到达。 3.3通过传输的信号分 基带传输：传输数字信号叫做基带传输频带传输：传输模拟信号叫做频带传输（300-3400HZ） 3.4通过传输方向分 单工 半双工 全双工 3.5通过传输对象分 单播 组播 广播 三.数据链路层 1.数据链路层的基础概念 1.1数据链路层的概念 数据链路层是在物理层和网际层之间的协议，提供相邻结点的可靠数据传输 1.2帧的概念 数据链路层的协议数据单元组成： 帧头：源MAC地址，目的MAC地址，类型（MAC地址用于在网络中唯一标示一个网卡，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的MAC地址）数据帧尾：校验 1.3以太网数据帧中的MAC和LLC MAC（一种协议，对接物理层） MAC介质控制访问作用：数据帧的封装/卸载，帧的寻址和识别，帧的接收语发送，链路的管理，帧的差错控制等。MAC子层的存在屏蔽了不同的物理链路层种类的差异性LLC（对接网络层） LLC逻辑控制访问作用：LLC子层的主要功能为传输可靠性保障和控制，数据包的分段与重组。数据包的顺序传播。注解： 该协议位于OSI七层协议中数据链路层，数据链路层分为上层LLC（逻辑链路控制），和下层的MAC（媒体访问控制），MAC主要负责控制与链接物理层的物理介质。在发送数据的时候，MAC协议可以事先判断是否发送数据，如果可以发送将给数据加上一些控制信息，最终将数据以及控制信息以规定的格式发送到物理层；在接收数据的时候，MAC协议首先判断输入的信息并是否发生传输错误，如果没有错误，则去掉控制信息发送至LLC（逻辑链路控制）层。 1.4数据链路层的两种传输方式 单播 广播 1.5数据链路层的三个基本问题（***） 封装成帧（PPP） 封装成帧就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧，接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。透明传输 透明传输是指不管所传数据是什么样的比特组合，都应当能够在链路上传输差错检测（奇数校验 偶数校验 CRC：需要计算） 收到正确的帧就要向发送端发送确认，发送算在一定的期限内若没有收到对方的确认，就认为出现了差错，因而就进行重传，直到收到对方的确认为止， 1.6局域网中的设备 网桥（在物理层和数据链路层之间） 两个端口的交换机 集线器（在物理层 共享带宽） 集线器的英文为：“HUB”是“中心”的意思，集线器的主要功能是对接受的信号进行再生整形放大，以扩大网络的传输距离，同时把所有结点集中在以它为中心的结点上。 交换机（数据链路层 独享带宽） 交换机（Switch）意为“开关”是一种用于电（光）信号转发的网络设备。它可以为接入交换机的任意两个网络结点提供独享的电信号通路。最常见的交换机式以太网交换机。 2数据链路层的通信协议 2.1冲突域和广播域（*） 冲突域 交换机的每一个端口都是一个冲突域；冲突域只能发生在一个网段广播域 交换机的所有端口都在一个广播域；广播域在一个或多个网段内发生区别 广播域可以跨网段冲突域是基于第一层（物理层），而广播域是基于第二层（数据链路层）HUB所有端口都在同一个广播域，冲突域内，Switch所有端口都在同意广播域内，而每一个端口就是一个冲突域。同一冲突域共享宽带 2.2虚拟局域网（实验）VLAN（***） VLAN（Virtual local Area Network）即虚拟局域网，是将一个物理的LAN在逻辑上划分成多个广播域的通信技术。VLAN间不能直接通信，而VLAN间不能直接通信，从而将广播报文限制在一个VLAN内。优点和目的 划分广播域：减少垃圾数据增强局域网的安全性提高健壮性灵活构建工作组划分VLAN的方式 基于端口 给交换机的每个接口配置不同的PVID，当一个数据帧进入交换机接口时，如果没有带VLAN标签，且该接口上配置了PVID。如果进入的帧已经带有VLAN标签，那么交换机不会在增加VLAN标签，即使接口已经配置了PVIDAccess：只允许通过一个VLANTrunk：允许通过多个VLANHybird基于子网 配置好子网域VLAN映射表，如果交换设备收到的是untagged（不带VLAN标签）帧，交换设备根据报文中的源IP地址信息，确认添加的VLAN iD。将指定网段或IP地址发出的报文在指定的VLAN中传输，减轻了网络管理着的任务量，且有利于管理基于MAC地址 先配置好MAC地址和VLAN映射关系表，当终端用户的物理位置发生改变，不需要重新配置VLAN。提高了终端用户的安全性和接入的灵活性基于协议 将网络中提供的服务类型域VLAN相绑定，方便管理和维护。需要对网络中所有的协议类型和VLAN ID 的映射关系表进行初始配置。需要分析各种协议的地址格式并进行相应的转换，消耗交换机较多的资源，速度上稍具劣势。基于匹配策略 先在交换机上配置好终端的MAC地址和IP地址，并与VLAN 并联。只有符合条件的终端才能加入指定VLAN。符合策略的终端加入指定VLAN后，严禁修改IP地址和MAC地址，否则会导致终端从指定VLAN中退出。 2.3：CSMA/CD（总线型）（***） CSDN/CD即载波侦听多路访问/冲突检测，是广播信道中采用一种随机访问技术的竞争型访问方法，具有多目标地址的特点，总线型网络传输数据四大特点（重要） 先听再发边听边发冲突停止延迟后发 2.4：PPP（单播） 点对点通信是一对一通道，因此不会发生碰撞，因此比较简单，采用PPP协议；其中PPP协议就是用户计算机和ISP（互联网服务提供商）进行通信时使用的数据链路层的协议PPP最初设计是为两个对等节点之间的IP流量传输提供一种封装协议。 2.5：CRC（需要单独的深入学习） 循环冗余校验 是数据通信领域中最常用的一种查错校验码，其特征是信息字段和校验字段的长度可以任意选定。循环冗余检查（CRC）是一种数据传输检错功能。l 例题：要发送的数据为1101011011，采用CRC的生成多项式是P（x）=x^4+x+1.求余数。 四.网络层 1.网络层的作用 提供点到点的服务 单位：分组网络层的目的是实现两个端系统之间的数据透明传输，具体功能包括寻址和路由选择，连接的建立，保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。 2.网际层协议IP IP协议&nbsp; &nbsp;&nbsp; 实现网络互连，使参与互联的性能各异的网络从用户方面看起来像一个统一的网络。ARP地址解析协议 根据IP地址获取物理地址RARP反地址解析协议&nbsp; &nbsp; &nbsp; 根据物理地址获取ip地址ICMP网际控制报文协议 提供差错报告和询问报文，以提高IP数据交付成功的机会。通过ICMP传输控制消息，控制消息是指网络通不通，主机是否可达，路由是否可用等网络本身的消息。IGMP网际组管理协议 用于探寻，转发本局域网内的组成员关系。适用于管理协议多播组成员的一种通信协议。IP主机和相邻路由器利用IGMP来创建多播组的组成员。组播方式解决了单播情况下数据的重复拷贝及带宽的重复占用，也解决了广播方式下带宽资源的浪费 3.IP地址 3.1IP地址的概念 IP地址使IP协议提供的一种统一的地址格式，他为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。组成：一个IP地址由4个字节，32位组成，一般用点分十进制的方式表现，IP地址和MAC地址的区别 IP地址是一个逻辑地址，MAC地址是物理地址MAC地址是唯一的但是IP地址不受唯一的MAC地址主要是工作在第二层，IP地址在网际层MAC地址是48位，IP地址一般是32位（v6是128位）IP地址的分配取决于网络拓扑，MAC地址分配取决于制造商 3.2IP地址的组成 主机地址和网络地址组成的主机地址/主机号 标识某一台设备的地址网络地址/网络号 标识某一网段的地址子网掩码 子网掩码用于区分网络号和主机号,是网络号为1，主机号为0。它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只能有一个作用，就是将某一个IP地址划分成为网络地址和主机地址两部分 3.3IP地址的分类 3.3.1A类 一个A类IP地址是指，在IP地址的四段号码中，第一段号为网络号码，剩下的三段号码为本地计算机的号码。A类IP地址中网络的标识长度为8位，主机标识的长度为24位，A类网络地址数量较少，有126个网络，每一个网络可以容纳主机数量高达1600多万台. A类IP地址 地址范围1.0.0.1到127.255.255.254第一个字节为网络号，第一个字节第一位为0 3.3.2B类 一个B类地址是指，在IP地址的四段号码中，前两段号码为网络号码。B类IP地址中网络的标识长度为16位，主机标识的长度为16位，B类网络地址适用于中等规模的网络，有16384个网络，每个网络所能容纳的计算机数6万多台。 B类IP地址 地址范围128.0.01-191.255.255.254前两个字节为网络号，第一个字节前两位是10 3.3.3C类 一个C类IP地址是指，在IP地址的四段号码中，前三段号码为网络号码，剩下的一段号码为本地计算机的号码。C类IP地址中网络的标识长度为24位，主机标识的长度为8位，C网络地址数量较多，有209万余个网络。适用于小规模的局域网络，每个网络最多只能包含254台计算机。C类IP地址范围192.0.0.1-223.255.255.254前三个字节为网络号，第一个字节前两位是110 3.3.4D类 D类IP地址在历史上呗叫做多播地址，及组播地址。在以太网中，多播地址命名了一组应该在这个网络中应用接收到一个分组的站点。多播地址的最高位必须是“1110”，范围从224.0.0.0到239.255.255.255 3.3.5E类 保留 3.3.6特殊地址 网络地址：主机号全为0的地址不可用广播地址：主机号全为1的地址不可用回环地址：127.0.0.0 测试使用 4.IPv6 因为IPv4地址满足不了需求，出现匮乏的情况，所以就诞生了IPv6地址继续使用。v6地址由128位，16字节组成，一般表现形式为十六进制。 4.网络层的路由 4.1路由 路由是什么？ 路由是指分组从源到目的地时，决定端到端路径的网络范围的进程。路由是指导报文转发的路径信息，通过路由可以确认转发IP报文的路径路由是网络层最主要的工作任务路由器 网络层的基础设备数据转发一个端口代表一个网段，路由器中存放着通往各个网段的表格，叫做路由表路由表 又称路由择域信息库，是一个存储在路由器或者联网计算机中的电子表格（文件）或者类数据库。路由表存储着指向特定网络地址的路径网关 又称网间连接器，协议转换器。用于两个高层协议不同的网络互连。网关既可以用于广域网互连，也可以用于局域网互连路由获取方式 直连路由静态路由动态路由 4.2路由的配置方式 静态路由 静态路由：由管理员手工配置，配置方便，对系统要求低，适用于拓扑结构简单稳定的小型网络缺省路由：是一种特殊的路由，当报文没有在路由表中找到匹配的具体表项时才能使用的路由动态路由 动态路由 通过动态路由协议来实现不同网段的路由互通动态路由协议有自己的路由算法，能够自动适应网络拓扑的变化，适用于具有一定数量的三层设备的网络动态路由协议 RPI RPI：路由信息协议基于矢量的动态路由协议适用于中小规模的网络拓扑，最大跳数为15OSPF OSPF:开放式最短路径优先基于链路状态的路由使用SPF算法，计算最短路径。树形协议BGP BGP是自治系统间的路由协议。自治系统之间的路由协议自治系统间的路由协议IS-IS IS-IS：中间系统到中间系统与OSPF类似，IS-IS是基于路由路划分区域，OSPF利用接口划分内部网关协议RIP和OSPF的区别 RIP是基于矢量的协议，OSPF是基于链路状态RIP适用于中小型网络拓扑，OSPF适用于较大规模的网络OSPF支持可变长度子网掩码（VLSM）。RIP不支持ODPF的收敛速度比RIP更加的迅速 5.划分子网 子网划分 100 台电脑接入 c类地址最多提供254台主机，但冗余154 主机号上进行子网划分 划分2个子网 192.168.1.10000000和192.168.1.00000000 192.168.1.0000 0000/24（24表示网络号） 255.255.255.0&nbsp;&nbsp;254（254个主机，2的八次方为256，但是全0和全1不能用，所以减去2为254） 192.168.1.0000 0000/25（25表示前边24个网络号加上划分为子网的位，一共25位） 255.255.255.1000 0000&nbsp; 126（分出126个主机，2的7次方为128，但全0和全1不能用，所以126） (网络号 24+子网号 1) 网络号 25 +主机号7&nbsp; &nbsp; 占据的这个子网号就可以分为0和1来，就将子网划分成了2个 划分4个子网，则就占2个主机号192.168.1.00000000/26，剩下6位主机号，则可分2的六次方-2太主机=62 192.168.1.11000000 192.168.1.00000000 192.168.1.10000000 192.168.1.01000000 五.传输层 1.传输层概念 1.1传输层 传输层提供端到端服务从通信和信息处理的角度看，传输层向上层应用层提供通信服务所谓的端口，就好像是门牌号一样，客户端可以通过IP地址找到对应的服务器端，但是服务器端是有很多的端口的，每个应用程序对应一个端口号，通过类似门牌号的端口号，客户端才能真正的访问到该服务器。为了对端口号进行区分，将每个端口进行编号，这就是端口号 1.2端口号 FTP：21（20）* FTP（文件传输协议）21连接；20传输数据TELNET：23*：TELNET(远程登录)SMTP：25* SMTP(电子邮件传输协议)POP3（邮局协议版本3）：110DNS：53*：DNS（域名系统）TFTP：69：TFTP（简单文件传输协议）HTTP：80*：HTTP（超文本传输协议）SNMP：161：SNMP（简单网络管理协议）HTTPS：443*：HTTPS（超文本传输安全协议） 2.传输层的两个重要协议 3.1TCP 传输控制协议：TCP TCP是TCP/IP体系中较为复杂的协议，是传输层中最重要的协议 TCP的主要特点是： TCP是面向连接的传输层协议TCP提供可靠的交付服务TCP提供全双工通信TCP是面向字节流 窗口 固定窗口：如果窗口过小，当传输比较大的数据的时候需要不停的对数据进行确认，这个时候就会造成很大的延迟滑动窗口：滑动窗口通俗的讲就是一种流量控制技术。它本质上是描述接收方TCP数据报缓冲区大小的数据，发送根据这个数据来计算自己最多能发送所长的数据，如果发送方收到接收方的窗口大小为0的TCP数据报，那么发送方将停止发送数据，等到接受方发送窗口大小不为0的数据报的到来拥塞处理和流量控制 TCP的三次握手和流量控制 3.2UDP 用户数据报协议：UDPUDP是在IP数据报服务之上增加了一些功能，增加了复用和分用的功能以及差错检测的功能UDP的主要特点是： UDP是无连接的UDP尽最大努力交付UDP面向报文且没有拥塞控制UDP开销较小传输效率较高UDP首部的概念 六.应用层 1.应用层的作用 通过位于不同主机中的多个应用进程之间的通信和协同工作来完成，应用层的内容就是具体定义通信规则www 主机名 2.应用层中常见的协议 域名系统DNS 域名结构：每一个域名用标号隔开。 mail.cctv.com (三级域名.二级域名.顶级域名)域名服务器：迭代 （自己一个一个去问）递归（传递，归来，别人帮你问，你问了他不知道，他帮你问，再回答你）域名和ip地址的转换端口号：53文件传输协议FTP 使用TCP连接，传输数据端口号：21（20）。&nbsp;20发送数据远程终端协议TELNET 使用TCP连接，远程登录到远地的另外一台主机上端口号：23万维网和HTTP协议 超文本传输协议，是一个简单的请求-响应协议端口号：80电子邮件协议 SMTP电子邮件传输协议（发送邮件）：端口号25POP3邮局协议版本3（接收邮件）：端口号110DHCP动态主机配置协议 指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。端口号68 七.网络安全 1.网络安全概论 1.1网络安全 网络安全（Cyber Security）是指网络系统的硬件，软件及其系统中的数据受到保护，不因偶然的或者恶意的原因而遭到破坏，更改，泄露。系统连续可靠正常的运行，网络服务不中断。 1.2计算机网络面临的威胁主要分为两类 1.2.1主动攻击 主动的去做一些在网络基础上的恶意行为。恶意串改信息数据，发布恶意程序脚本等篡改恶意程序拒绝服务 1.2.2被动攻击 被动攻击主要是收集信息而不是进行访问，不改变数据本身的结构，也不对软硬件数据造成影响截取窃听流量分析 1.2网络系统特性 保密性：信息不泄露给非授权用户，实体或过程，或供其利用的特性完整性：数据未经授权不能进行改变的特性，即信息在存储或传输过程中保持不被修改，不被破坏和丢失的特性可用性：可被授权实体访问并按需求使用的特性。即当需要时能否存取所需信息。例如网络环境下拒绝服务，破坏网络和有关系统的正常运行等后属于对可用性的攻击可靠性：对信息的传播及内容具有控制能力不可抵赖性：出现安全问题时提供依据与手段 2.加密和交互 2.1加密和解密 2.1.1加密 是以某种特殊的算法改变原有的信息数据，使得未授权的用户即即使获得了已加密的信息，但因不知解密的方法，仍然无法了解信息的内容加密手段 MD5加密（信息-摘要算法）：128位AES加密（称秘钥加密）：128,192,256位SHAI加密（安全哈希算法）：160位RSA加密：公钥加密，私钥解密：1204位 2.1.2解密 加密的逆过程就是解密 2.2公钥和私钥 2.2.1对称加密 采用单钥密码系统的加密方式，同一个秘钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单秘钥加密。 2.2.2非对称加密 使用非对称的加密方式时，会产生两把钥匙。发送方利用自己的公钥加密，接收方利用自己的私钥解密数字签名的四大特点 防止重放攻击：攻击者利用网络监听或则其他方式盗取认证凭据，之后再把它重新发给认证服务器。在数字签名中，如果采用了对签名报文加盖时间戳等或添加流水号等技术，就可以有效防止重放攻击防止数据伪造：其他人不能伪造对消息的签名，因为私有秘钥只能签名者自己知道，所有其他人不可以构造出正确的签名结果数据防止数据篡改：数字签名与原始文件或摘要一起发送给接受者，一旦信息被篡改，接受者可以通过计算摘要和验证签名来判断该文件无效，从而保证了文件的完整性防止数据抵赖：数字签名既可以作为身份认证的依据，也可以作为签名者签名操作的证据。要防止接受者抵赖，可以在数字签名系统中要求接收者返回一个自己的签名的表示收到报文，给发送者或者信任第三方。如果接受者不返回任何信息，此次通信可终止或重新的开始，签名方也没有任何的损失，由此双方均不可抵赖。 2.3防火墙 防火墙是一种访问控制技术，可以严格控制进出网络边界的分组，禁止任何不必要的通信，来减少潜在入侵的发生 防火墙的区域们 Local本地区域 顶级安全区域，安全优先级为100local就是防火墙本身的区域比如ping指令等网际控制协议的回复，需要local域的权限凡是由防火墙主动发出的报文均可认为是从local区域中发出是需要防火墙响应并处理（而不是转发）的报文均可认为是Local区域接收Trust受信区 高级安全区域，安全优先级为85通常用来定义内部用户所在的网络，也可以理解为应该是防护最严密的地区DMZ非军事化区 中级安全区域，安全优先级50通常用来定义内部服务器坐在网络作用是把WEB。E-mail等允许外部访问的服务器单独接在该区域端口，使整个需要访问，实现内外网分离，达到用户需求。DMZ可以理解为一个不同于外网或内网的特殊网络区域，DMZ内通常放置一些不含机密信息的公用服务器，比如Web，Mail，FTP中的服务。这样来自外网的访问者可以访问DMZ中服务，但不可能接触到存放在内网中的公司机密或私人信息等，及时DMZ中服务器受到破坏，也不会对内网中的机密信造成影响Untrust非受信区 低级安全区域，安全优先级为5通常用来定义Internet等不安全的网络，用于网络入口线的接入。","categories":[],"tags":[]},{"title":"第一篇","slug":"第一篇","date":"2023-04-03T15:13:53.000Z","updated":"2023-07-17T10:43:54.377Z","comments":true,"path":"2023/04/03/第一篇/","link":"","permalink":"http://yoursite.com/2023/04/03/%E7%AC%AC%E4%B8%80%E7%AF%87/","excerpt":"","text":"aaaaaaaa ##题目 一级标题第一 题目斜体 加粗 111 111 11 11 12python uuu","categories":[{"name":"分类A","slug":"分类A","permalink":"http://yoursite.com/categories/%E5%88%86%E7%B1%BBA/"},{"name":"分类B","slug":"分类B","permalink":"http://yoursite.com/categories/%E5%88%86%E7%B1%BBB/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/tags/%E6%B5%8B%E8%AF%95/"},{"name":"好吧","slug":"好吧","permalink":"http://yoursite.com/tags/%E5%A5%BD%E5%90%A7/"}]},{"title":"测试","slug":"测试","date":"2017-07-04T16:00:00.000Z","updated":"2023-07-22T11:57:13.207Z","comments":true,"path":"2017/07/05/测试/","link":"https://xaoxuu.com/blog/2017-07-05-hexo-blog/","permalink":"http://yoursite.com/2017/07/05/%E6%B5%8B%E8%AF%95/","excerpt":"","text":"","categories":[{"name":"Dev","slug":"Dev","permalink":"http://yoursite.com/categories/Dev/"},{"name":"Hexo","slug":"Dev/Hexo","permalink":"http://yoursite.com/categories/Dev/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}],"author":"xaoxuu"}],"categories":[{"name":"计算机四大件","slug":"计算机四大件","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%9B%E5%A4%A7%E4%BB%B6/"},{"name":"数据结构与算法","slug":"计算机四大件/数据结构与算法","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"分类A","slug":"分类A","permalink":"http://yoursite.com/categories/%E5%88%86%E7%B1%BBA/"},{"name":"分类B","slug":"分类B","permalink":"http://yoursite.com/categories/%E5%88%86%E7%B1%BBB/"},{"name":"Dev","slug":"Dev","permalink":"http://yoursite.com/categories/Dev/"},{"name":"Hexo","slug":"Dev/Hexo","permalink":"http://yoursite.com/categories/Dev/Hexo/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"测试","slug":"测试","permalink":"http://yoursite.com/tags/%E6%B5%8B%E8%AF%95/"},{"name":"好吧","slug":"好吧","permalink":"http://yoursite.com/tags/%E5%A5%BD%E5%90%A7/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]}